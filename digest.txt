Directory structure:
└── meeting-summary/
    ├── README.md
    ├── astro.config.mjs
    ├── components.json
    ├── eslint.config.js
    ├── package.json
    ├── tailwind.config.mjs
    ├── tsconfig.json
    ├── .env.example
    ├── .nvmrc
    ├── .prettierrc.json
    ├── .windsurfrules
    ├── public/
    ├── src/
    │   ├── auth.ts
    │   ├── env.d.ts
    │   ├── types.ts
    │   ├── components/
    │   │   ├── Welcome.astro
    │   │   ├── layout/
    │   │   │   └── Topbar.tsx
    │   │   ├── ui/
    │   │   │   └── button.tsx
    │   │   └── views/
    │   │       ├── LoginForm.tsx
    │   │       ├── SummaryForm.tsx
    │   │       └── SummaryList.tsx
    │   ├── db/
    │   │   ├── database.types.ts
    │   │   └── supabase.client.ts
    │   ├── layouts/
    │   │   ├── Layout.astro
    │   │   └── MainLayout.astro
    │   ├── lib/
    │   │   ├── apiService.ts
    │   │   └── utils.ts
    │   ├── middleware/
    │   │   └── index.ts
    │   ├── pages/
    │   │   ├── create.astro
    │   │   ├── index.astro
    │   │   ├── login.astro
    │   │   ├── summaries.astro
    │   │   ├── api/
    │   │   │   ├── generate-summary.ts
    │   │   │   └── summaries.ts
    │   │   └── edit/
    │   │       └── [id].astro
    │   └── styles/
    │       └── global.css
    ├── supabase/
    │   ├── config.toml
    │   ├── .gitignore
    │   ├── migrations/
    │   │   ├── 20250417183316_create_users.sql
    │   │   ├── 20250417183903_create_meeting_summaries.sql
    │   │   ├── 20250417184502_fix_update_modified_at_search_path.sql
    │   │   ├── 20250419065725_add_meeting_summaries_indexes.sql
    │   │   ├── 20250420151200_remove_notes_not_null.sql
    │   │   └── 20250420184550_title_column_added.sql
    │   └── .branches/
    │       └── _current_branch
    ├── .ai/
    │   ├── additional-rules.md
    │   ├── api-plan.md
    │   ├── create-new-summary-endpoint-curl-tests.md
    │   ├── create-new-summary-endpoint.md
    │   ├── db-plan.md
    │   ├── db.sql
    │   ├── generate-summary-endpoint-curl-tests.md
    │   ├── generate-summary-endpoint.md
    │   ├── prd.md
    │   ├── summaries-curl-tests.md
    │   ├── summaries-endpoint.md
    │   ├── tech-stack.md
    │   ├── ui-plan.md
    │   ├── ui-session.md
    │   ├── ui-shadcn-helper.md
    │   └── ui-view-implementation.md
    ├── .astro/
    │   ├── content-assets.mjs
    │   ├── content-modules.mjs
    │   ├── data-store.json
    │   ├── settings.json
    │   ├── types.d.ts
    │   └── collections/
    ├── .cursor/
    │   └── rules/
    │       ├── api-supabase-astro-init.mdc
    │       ├── astro.mdc
    │       ├── backend.mdc
    │       ├── db-supabase-migrations.mdc
    │       ├── frontend.mdc
    │       ├── react.mdc
    │       ├── shared.mdc
    │       └── ui-shadcn-helper.mdc
    ├── .github/
    │   └── copilot-instructions.md
    ├── .history/
    │   ├── tailwind.config_20250421130423.mjs
    │   ├── tailwind.config_20250421133817.mjs
    │   └── src/
    │       ├── auth_20250421132412.ts
    │       ├── auth_20250421133017.ts
    │       ├── auth_20250421133031.ts
    │       ├── auth_20250421133115.ts
    │       ├── auth_20250421133124.ts
    │       ├── auth_20250421133310.ts
    │       ├── auth_20250421133311.ts
    │       ├── auth_20250421133312.ts
    │       ├── auth_20250421133327.ts
    │       ├── auth_20250421133432.ts
    │       ├── auth_20250421133433.ts
    │       ├── auth_20250421133459.ts
    │       ├── auth_20250421133541.ts
    │       ├── auth_20250421134605.ts
    │       ├── auth_20250421134917.ts
    │       ├── auth_20250421135118.ts
    │       ├── auth_20250421135154.ts
    │       ├── auth_20250421135202.ts
    │       ├── auth_20250421135258.ts
    │       ├── auth_20250421141317.ts
    │       ├── auth_20250421141426.ts
    │       ├── auth_20250421141430.ts
    │       ├── auth_20250421141432.ts
    │       ├── env.d_20250419200309.ts
    │       ├── env.d_20250421133747.ts
    │       ├── env.d_20250421133750.ts
    │       ├── env.d_20250421133803.ts
    │       ├── components/
    │       │   └── views/
    │       │       ├── SummaryForm_20250421130012.tsx
    │       │       ├── SummaryForm_20250421134808.tsx
    │       │       ├── SummaryForm_20250421134811.tsx
    │       │       ├── SummaryForm_20250421135309.tsx
    │       │       ├── SummaryForm_20250421135358.tsx
    │       │       ├── SummaryForm_20250421135359.tsx
    │       │       ├── SummaryForm_20250421135453.tsx
    │       │       ├── SummaryForm_20250421135539.tsx
    │       │       ├── SummaryForm_20250421135541.tsx
    │       │       ├── SummaryForm_20250421135542.tsx
    │       │       ├── SummaryForm_20250421135625.tsx
    │       │       ├── SummaryForm_20250421135627.tsx
    │       │       ├── SummaryForm_20250421135657.tsx
    │       │       ├── SummaryForm_20250421141210.tsx
    │       │       ├── SummaryForm_20250421141439.tsx
    │       │       ├── SummaryForm_20250421141507.tsx
    │       │       ├── SummaryList_20250421125923.tsx
    │       │       ├── SummaryList_20250421134746.tsx
    │       │       └── SummaryList_20250421134751.tsx
    │       ├── db/
    │       │   ├── supabase.client_20250419200154.ts
    │       │   ├── supabase.client_20250421133610.ts
    │       │   ├── supabase.client_20250421134640.ts
    │       │   ├── supabase.client_20250421140730.ts
    │       │   └── supabase.client_20250421141241.ts
    │       ├── lib/
    │       │   ├── apiService_20250421131015.ts
    │       │   ├── apiService_20250421133805.ts
    │       │   ├── apiService_20250421133812.ts
    │       │   ├── apiService_20250421134716.ts
    │       │   └── apiService_20250421134957.ts
    │       ├── middleware/
    │       │   ├── index_20250419234052.ts
    │       │   ├── index_20250421133625.ts
    │       │   ├── index_20250421133626.ts
    │       │   ├── index_20250421134655.ts
    │       │   └── index_20250421135005.ts
    │       └── pages/
    │           └── api/
    │               ├── generate-summary_20250420232756.ts
    │               ├── generate-summary_20250421133657.ts
    │               ├── generate-summary_20250421133706.ts
    │               ├── summaries_20250420232716.ts
    │               ├── summaries_20250421133728.ts
    │               ├── summaries_20250421133822.ts
    │               ├── summaries_20250421133827.ts
    │               ├── summaries_20250421133908.ts
    │               ├── summaries_20250421133938.ts
    │               ├── summaries_20250421133942.ts
    │               ├── summaries_20250421133944.ts
    │               ├── summaries_20250421134314.ts
    │               ├── summaries_20250421134354.ts
    │               ├── summaries_20250421134842.ts
    │               ├── summaries_20250421134846.ts
    │               ├── summaries_20250421141346.ts
    │               ├── summaries_20250421141357.ts
    │               └── summaries_20250421141525.ts
    └── .husky/
        └── pre-commit

================================================
File: README.md
================================================
# Meeting Summarizer

## Opis Projektu

Meeting Summarizer to aplikacja webowa zaprojektowana w celu automatyzacji procesu tworzenia podsumowaĹ„ z transkrypcji spotkaĹ„ w jÄ™zyku polskim. Jest skierowana do uĹĽytkownikĂłw technicznych, takich jak programiĹ›ci, ktĂłrzy sÄ… odpowiedzialni za dokumentowanie spotkaĹ„. Aplikacja umoĹĽliwia uĹĽytkownikom przesĹ‚anie pliku tekstowego zawierajÄ…cego transkrypcjÄ™, edycjÄ™ transkrypcji, generowanie podsumowania przy uĹĽyciu modelu jÄ™zykowego (LLM), dalszÄ… edycjÄ™ podsumowania oraz zapisanie zarĂłwno oryginalnej transkrypcji, jak i wygenerowanego podsumowania w bazie danych. UĹĽytkownicy mogÄ… rĂłwnieĹĽ przeglÄ…daÄ‡ i edytowaÄ‡ wczeĹ›niej zapisane podsumowania. Minimum Viable Product (MVP) koncentruje siÄ™ na podstawowej funkcjonalnoĹ›ci, aby zapewniÄ‡ szybkie i sprawne generowanie podsumowaĹ„ spotkaĹ„.

## Stack Technologiczny

*   **Frontend:**
    *   [Astro.js](https://astro.build/): Framework do budowy szybkich stron internetowych z minimalnym uĹĽyciem JavaScript po stronie klienta.
    *   [React](https://reactjs.org/): Biblioteka JavaScript do budowy interfejsĂłw uĹĽytkownika.
    *   [Tailwind CSS](https://tailwindcss.com/): Utility-first framework CSS do szybkiego tworzenia interfejsĂłw.
    *   [Lucide React](https://lucide.dev/): Biblioteka ikon.
*   **Backend & Baza Danych:**
    *   [Supabase](https://supabase.com/): Backend-as-a-Service (BaaS) zapewniajÄ…cy uwierzytelnianie i bazÄ™ danych PostgreSQL.
*   **Inne:**
    *   LLM API (np. GPT-3.5 przez API lub lokalna instancja Ollama): Do generowania podsumowaĹ„.
    *   [ESLint](https://eslint.org/): Linter JavaScript.
    *   [Prettier](https://prettier.io/): Formater kodu.

## Uruchomienie Lokalnie

Wykonaj nastÄ™pujÄ…ce kroki, aby uruchomiÄ‡ projekt na swoim lokalnym komputerze:

**Wymagania WstÄ™pne:**

*   [Node.js](https://nodejs.org/en/) (v22.14.0)
*   [npm](https://www.npmjs.com/) lub [Yarn](https://yarnpkg.com/) - menedĹĽer pakietĂłw

**Instalacja:**

1.  Sklonuj repozytorium:

    ```bash
    git clone [URL repozytorium]
    cd meeting-summarizer
    ```

2.  Zainstaluj zaleĹĽnoĹ›ci za pomocÄ… npm lub yarn:

    ```bash
    npm install
    # lub
    yarn install
    ```

**Konfiguracja:**

1.  **Konfiguracja Supabase:**
    *   UtwĂłrz projekt Supabase na stronie [https://supabase.com/](https://supabase.com/).
    *   Uzyskaj adres URL Supabase i klucz `anon`.
    *   Skonfiguruj schemat bazy danych zgodnie z wymaganiami projektu (tabele do przechowywania transkrypcji i podsumowaĹ„).
    *   Skonfiguruj zmienne Ĺ›rodowiskowe za pomocÄ… adresu URL Supabase i klucza `anon`. PrzykĹ‚adowy plik `.env.example` moĹĽe wyglÄ…daÄ‡ tak (utwĂłrz plik `.env` i wypeĹ‚nij te wartoĹ›ci):

        ```
        PUBLIC_SUPABASE_URL="TWĂ“J_ADRES_URL_SUPABASE"
        PUBLIC_SUPABASE_ANON_KEY="TWĂ“J_KLUCZ_ANON_SUPABASE"
        ```

2.  **Konfiguracja LLM API:**
    *   Uzyskaj klucz API od dostawcy modelu jÄ™zykowego (np. OpenAI dla GPT-3.5) lub skonfiguruj lokalnÄ… instancjÄ™ Ollama.
    *   Skonfiguruj swĂłj klucz API jako zmiennÄ… Ĺ›rodowiskowÄ…:

        ```
        OPENAI_API_KEY="TWĂ“J_KLUCZ_API_OPENAI"
        ```

**Uruchomienie Aplikacji:**

```bash
npm run dev
# lub
yarn dev
```

Aplikacja zostanie uruchomiona w trybie deweloperskim i moĹĽesz uzyskaÄ‡ do niej dostÄ™p pod adresem `http://localhost:3000` (lub port okreĹ›lony w konfiguracji Astro).

## DostÄ™pne Skrypty

DostÄ™pne sÄ… nastÄ™pujÄ…ce skrypty:

*   `dev`: Uruchamia serwer deweloperski.
*   `build`: Buduje aplikacjÄ™ gotowÄ… do produkcji.
*   `preview`: PodglÄ…d zbudowanej aplikacji.
*   `lint`: Uruchamia ESLint do sprawdzania kodu.
*   `lint:fix`: Uruchamia ESLint i automatycznie naprawia problemy.
*   `format`: Uruchamia Prettier do formatowania kodu.

## Zakres Projektu

Ten projekt koncentruje siÄ™ na nastÄ™pujÄ…cych podstawowych funkcjonalnoĹ›ciach MVP:

*   PrzesyĹ‚anie plikĂłw tekstowych z transkrypcjami (.txt, do 1MB).
*   Edycja transkrypcji.
*   Generowanie podsumowaĹ„ za pomocÄ… LLM (ograniczone do ~500 znakĂłw).
*   Edycja wygenerowanych podsumowaĹ„.
*   Zapisywanie transkrypcji i podsumowaĹ„ w bazie danych (Supabase).
*   WyĹ›wietlanie listy zapisanych podsumowaĹ„.
*   Edycja istniejÄ…cych podsumowaĹ„.
*   Bezpieczny DostÄ™p: Wymagane uwierzytelnianie uĹĽytkownika.

**Ograniczenia:**

Wersja MVP **nie zawiera** nastÄ™pujÄ…cych funkcji:

*   Eksportowania podsumowaĹ„ do formatu Markdown.
*   Dodawania tagĂłw do podsumowaĹ„.
*   WyodrÄ™bniania zadaĹ„, decyzji lub otwartych kwestii - koncentruje siÄ™ tylko na gĹ‚Ăłwnym podsumowaniu tematycznym.
*   Zaawansowanych moĹĽliwoĹ›ci formatowania tekstu.
*   Wyszukiwania podsumowaĹ„ po nazwie lub treĹ›ci.
*   Licznika znakĂłw w interfejsie edycji.
*   Pomiaru czasu generowania podsumowania.

## Status Projektu

Ten projekt jest obecnie w fazie rozwoju, w etapie MVP (Minimum Viable Product).

## Licencja

Licencja MIT




================================================
File: astro.config.mjs
================================================
// @ts-check
import { defineConfig } from "astro/config";

import react from "@astrojs/react";
import sitemap from "@astrojs/sitemap";
import tailwindcss from "@tailwindcss/vite";
import node from "@astrojs/node";

// https://astro.build/config
export default defineConfig({
  output: "server",
  integrations: [react(), sitemap()],
  server: { port: 3003 },
  vite: {
    plugins: [tailwindcss()],
  },
  adapter: node({
    mode: "standalone",
  }),
  experimental: {
    session: true,
  },
});



================================================
File: components.json
================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.mjs",
    "css": "src/styles/global.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "rsc": false,
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}


  


================================================
File: eslint.config.js
================================================
import { includeIgnoreFile } from "@eslint/compat";
import eslint from "@eslint/js";
import eslintPluginPrettier from "eslint-plugin-prettier/recommended";
import eslintPluginAstro from "eslint-plugin-astro";
import jsxA11y from "eslint-plugin-jsx-a11y";
import pluginReact from "eslint-plugin-react";
import reactCompiler from "eslint-plugin-react-compiler";
import eslintPluginReactHooks from "eslint-plugin-react-hooks";
import path from "node:path";
import { fileURLToPath } from "node:url";
import tseslint from "typescript-eslint";

// File path setup
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const gitignorePath = path.resolve(__dirname, ".gitignore");

const baseConfig = tseslint.config({
  extends: [eslint.configs.recommended, tseslint.configs.strict, tseslint.configs.stylistic],
  rules: {
    "no-console": ["warn", { allow: ["error"] }],
    "no-unused-vars": "off",
  },
});

const jsxA11yConfig = tseslint.config({
  files: ["**/*.{js,jsx,ts,tsx}"],
  extends: [jsxA11y.flatConfigs.recommended],
  languageOptions: {
    ...jsxA11y.flatConfigs.recommended.languageOptions,
  },
  rules: {
    ...jsxA11y.flatConfigs.recommended.rules,
  },
});

const reactConfig = tseslint.config({
  files: ["**/*.{js,jsx,ts,tsx}"],
  extends: [pluginReact.configs.flat.recommended],
  languageOptions: {
    ...pluginReact.configs.flat.recommended.languageOptions,
    globals: {
      window: true,
      document: true,
    },
  },
  plugins: {
    "react-hooks": eslintPluginReactHooks,
    "react-compiler": reactCompiler,
  },
  settings: { react: { version: "detect" } },
  rules: {
    ...eslintPluginReactHooks.configs.recommended.rules,
    "react/react-in-jsx-scope": "off",
    "react-compiler/react-compiler": "error",
  },
});

export default tseslint.config(
  includeIgnoreFile(gitignorePath),
  baseConfig,
  jsxA11yConfig,
  reactConfig,
  eslintPluginAstro.configs["flat/recommended"],
  eslintPluginPrettier
);



================================================
File: package.json
================================================
{
  "name": "meeting-summarizer",
  "type": "module",
  "version": "0.0.1",
  "scripts": {
    "dev": "astro dev",
    "build": "astro build",
    "preview": "astro preview",
    "astro": "astro",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "format": "prettier --write ."
  },
  "dependencies": {
    "@astrojs/node": "^9.1.3",
    "@astrojs/react": "4.2.2",
    "@astrojs/sitemap": "3.3.0",
    "@radix-ui/react-slot": "^1.1.2",
    "@supabase/auth-helpers-shared": "^0.7.0",
    "@supabase/ssr": "^0.6.1",
    "@supabase/supabase-js": "^2.49.4",
    "@tailwindcss/vite": "4.0.17",
    "@types/react": "19.0.12",
    "@types/react-dom": "19.0.4",
    "astro": "5.5.5",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "lucide-react": "^0.487.0",
    "react": "19.0.0",
    "react-dom": "19.0.0",
    "sonner": "^2.0.3",
    "tailwind-merge": "^3.1.0",
    "tailwindcss": "4.0.17",
    "tw-animate-css": "^1.2.5",
    "zod": "^3.24.3"
  },
  "devDependencies": {
    "@eslint/compat": "1.2.7",
    "@eslint/js": "9.23.0",
    "@typescript-eslint/eslint-plugin": "8.28.0",
    "@typescript-eslint/parser": "8.28.0",
    "eslint": "9.23.0",
    "eslint-config-prettier": "10.1.1",
    "eslint-import-resolver-typescript": "4.2.5",
    "eslint-plugin-astro": "1.3.1",
    "eslint-plugin-import": "2.31.0",
    "eslint-plugin-jsx-a11y": "6.10.2",
    "eslint-plugin-prettier": "5.2.5",
    "eslint-plugin-react": "7.37.4",
    "eslint-plugin-react-compiler": "19.0.0-beta-aeaed83-20250323",
    "eslint-plugin-react-hooks": "5.2.0",
    "husky": "9.1.7",
    "lint-staged": "15.5.0",
    "prettier-plugin-astro": "0.14.1",
    "typescript-eslint": "8.28.0"
  },
  "lint-staged": {
    "*.{ts,tsx,astro}": [
      "eslint --fix"
    ],
    "*.{json,css,md}": [
      "prettier --write"
    ]
  }
}



================================================
File: tailwind.config.mjs
================================================
/** @type {import('tailwindcss').Config} */
const config = {
  content: [
    "./src/**/*.{astro,html,js,jsx,md,mdx,svelte,ts,tsx,vue}",
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
    "./@/**/*.{js,ts,jsx,tsx}", // Ensure shadcn components are included
  ],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: `var(--radius)`,
        md: `calc(var(--radius) - 2px)`,
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
        "caret-blink": {
          "0%,70%,100%": { opacity: "1" },
          "15%,55%": { opacity: "0" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "caret-blink": "caret-blink 1.2s ease-out infinite", // Added for potential future use
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
};

export default config;



================================================
File: tsconfig.json
================================================
{
  "extends": "astro/tsconfigs/strict",
  "include": [".astro/types.d.ts", "**/*"],
  "exclude": ["dist"],
  "compilerOptions": {
    "jsx": "react-jsx",
    "jsxImportSource": "react",
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}



================================================
File: .env.example
================================================
SUPABASE_URL=###
SUPABASE_KEY=###
OPENROUTER_API_KEY=###


================================================
File: .nvmrc
================================================
22.14.0


================================================
File: .prettierrc.json
================================================
{
  "semi": true,
  "singleQuote": false,
  "tabWidth": 2,
  "printWidth": 120,
  "trailingComma": "es5",
  "plugins": ["prettier-plugin-astro"],
  "overrides": [
    {
      "files": "*.astro",
      "options": {
        "parser": "astro"
      }
    }
  ]
}



================================================
File: .windsurfrules
================================================
# AI Rules for {{project-name}}

{{project-description}}

## Tech Stack

- Astro 5
- TypeScript 5
- React 19
- Tailwind 4
- Shadcn/ui

## Project Structure

When introducing changes to the project, always follow the directory structure below:

- `./src` - source code
- `./src/layouts` - Astro layouts
- `./src/pages` - Astro pages
- `./src/pages/api` - API endpoints
- `./src/middleware/index.ts` - Astro middleware
- `./src/db` - Supabase clients and types
- `./src/types.ts` - Shared types for backend and frontend (Entities, DTOs)
- `./src/components` - Client-side components written in Astro (static) and React (dynamic)
- `./src/components/ui` - Client-side components from Shadcn/ui
- `./src/lib` - Services and helpers
- `./src/assets` - static internal assets
- `./public` - public assets

When modifying the directory structure, always update this section.

## Coding practices

### Guidelines for clean code

- Use feedback from linters to improve the code when making changes.
- Prioritize error handling and edge cases.
- Handle errors and edge cases at the beginning of functions.
- Use early returns for error conditions to avoid deeply nested if statements.
- Place the happy path last in the function for improved readability.
- Avoid unnecessary else statements; use if-return pattern instead.
- Use guard clauses to handle preconditions and invalid states early.
- Implement proper error logging and user-friendly error messages.
- Consider using custom error types or error factories for consistent error handling.

## Frontend

### General Guidelines

- Use Astro components (.astro) for static content and layout
- Implement framework components in React only when interactivity is needed

### Guidelines for Styling

#### Tailwind

- Use the @layer directive to organize styles into components, utilities, and base layers
- Use arbitrary values with square brackets (e.g., w-[123px]) for precise one-off designs
- Implement the Tailwind configuration file for customizing theme, plugins, and variants
- Leverage the theme() function in CSS for accessing Tailwind theme values
- Implement dark mode with the dark: variant
- Use responsive variants (sm:, md:, lg:, etc.) for adaptive designs
- Leverage state variants (hover:, focus-visible:, active:, etc.) for interactive elements

### Guidelines for Accessibility

#### ARIA Best Practices

- Use ARIA landmarks to identify regions of the page (main, navigation, search, etc.)
- Apply appropriate ARIA roles to custom interface elements that lack semantic HTML equivalents
- Set aria-expanded and aria-controls for expandable content like accordions and dropdowns
- Use aria-live regions with appropriate politeness settings for dynamic content updates
- Implement aria-hidden to hide decorative or duplicative content from screen readers
- Apply aria-label or aria-labelledby for elements without visible text labels
- Use aria-describedby to associate descriptive text with form inputs or complex elements
- Implement aria-current for indicating the current item in a set, navigation, or process
- Avoid redundant ARIA that duplicates the semantics of native HTML elements

### Guidelines for Astro

- Leverage View Transitions API for smooth page transitions (use ClientRouter)
- Use content collections with type safety for blog posts, documentation, etc.
- Leverage Server Endpoints for API routes
- Use POST, GET  - uppercase format for endpoint handlers
- Use `export const prerender = false` for API routes
- Use zod for input validation in API routes
- Extract logic into services in `src/lib/services`
- Implement middleware for request/response modification
- Use image optimization with the Astro Image integration
- Implement hybrid rendering with server-side rendering where needed
- Use Astro.cookies for server-side cookie management
- Leverage import.meta.env for environment variables

### Guidelines for React

- Use functional components with hooks instead of class components
- Never use "use client" and other Next.js directives as we use React with Astro
- Extract logic into custom hooks in `src/components/hooks`
- Implement React.memo() for expensive components that render often with the same props
- Utilize React.lazy() and Suspense for code-splitting and performance optimization
- Use the useCallback hook for event handlers passed to child components to prevent unnecessary re-renders
- Prefer useMemo for expensive calculations to avoid recomputation on every render
- Implement useId() for generating unique IDs for accessibility attributes
- Consider using the new useOptimistic hook for optimistic UI updates in forms
- Use useTransition for non-urgent state updates to keep the UI responsive

### Backend and Database

- Use Supabase for backend services, including authentication and database interactions.
- Follow Supabase guidelines for security and performance.
- Use Zod schemas to validate data exchanged with the backend.
- Use supabase from context.locals in Astro routes instead of importing supabaseClient directly
- Use SupabaseClient type from `src/db/supabase.client.ts`, not from `@supabase/supabase-js`



================================================
File: src/auth.ts
================================================
/* eslint-disable no-console */
// src/auth.ts
// Central module for Supabase client initialization and server-side session check.

// Import createClient from the main supabase-js library for the BROWSER client instance
import { createClient } from "@supabase/supabase-js";
// Import APIContext type for server-side context
import type { APIContext } from "astro";
// Import Session type
import type { Session } from "@supabase/supabase-js";

// Import the shared SupabaseClient type alias from the server client file
// FIX: Import the SupabaseClient type from the designated file
import type { SupabaseClient } from "./db/supabase.client";

// Import your local Database type (needed if SupabaseClient alias wasn't used)
// import type { Database } from "./db/database.types"; // Adjust path as needed

// --- Supabase Browser Client Instance ---
// This client instance is used in React components that run in the browser.
// It handles client-side session persistence (cookies/localStorage).
// Use your actual Supabase URL and Anon Key from environment variables (PUBLIC prefixed for client access).
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY;

// Ensure env vars are checked in development, though Astro handles this somewhat via env.d.ts
if (typeof window !== "undefined" && import.meta.env.DEV && (!supabaseUrl || !supabaseAnonKey)) {
  console.warn(
    "PUBLIC_SUPABASE_URL or PUBLIC_SUPABASE_ANON_KEY are not set for the browser client. API calls may fail."
  );
}

// Initialize the browser client instance using createClient
// FIX: Use createClient for the browser instance as intended
export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  // No `browser: true` option in createClient, it's the default for browser environments
  // No custom cookie handling needed for createClient in the browser, SDK handles it.
  global: {
    fetch: fetch.bind(globalThis), // Ensure fetch is bound to globalThis in browser
  },
}) as SupabaseClient; // Assert to the shared type alias

// --- Supabase Server Session Check Helper (Astro SSR) ---
// This function is used in Astro pages/layouts for server-side authentication checks for ROUTE ACCESS.
// It requires the APIContext to access the server-side Supabase client provided by the middleware.

export async function getSession(context: APIContext): Promise<Session | null> {
  // Get the server-side Supabase client instance from context.locals
  // It is already typed as SupabaseClient from src/db/supabase.client in env.d.ts
  const supabaseServer: SupabaseClient = context.locals.supabase;

  if (!supabaseServer) {
    console.error(
      "getSession: Supabase client not found in context.locals. Ensure middleware is running and setting 'context.locals.supabase'."
    );
    // This indicates a critical setup error if middleware didn't run.
    return null;
  }

  // Use the server-side client to get the session from the request cookies
  // This checks if *any* user is authenticated for ROUTE protection.
  const {
    data: { session },
    error: authError,
  } = await supabaseServer.auth.getSession();

  if (authError) {
    console.error("getSession: Error fetching session on server:", authError);
    return null;
  }

  console.log(`getSession: Session found for route protection? ${!!session}`);
  return session;
}



================================================
File: src/env.d.ts
================================================
/// <reference types="astro/client" />

// Import the SupabaseClient type alias from your local client file
import { type SupabaseClient } from "./db/supabase.client";

declare global {
  namespace App {
    interface Locals {
      // Use the imported SupabaseClient type alias, which is SupabaseClientBase<Database>
      // The Database type is brought in by the alias itself, no need to parameterize here
      supabase: SupabaseClient; // <--- Use the alias type directly for the server client instance
      // Add other server-side locals here if needed
      runtime: {
        env: ImportMetaEnv; // Make server-side env vars available in locals.runtime.env
      };
    }
  }
}

interface ImportMetaEnv {
  // Public variables (available client-side via import.meta.env.PUBLIC_...)
  readonly PUBLIC_SUPABASE_URL: string;
  readonly PUBLIC_SUPABASE_ANON_KEY: string;

  // Server-side variables (available only on the server via import.meta.env or locals.runtime.env)
  readonly SUPABASE_URL: string;
  readonly SUPABASE_KEY: string;
  readonly OPENROUTER_API_KEY: string; // Ensure this matches your .env file

  // Add any other server-side environment variables here
  // readonly SUPABASE_SERVICE_ROLE_KEY: string; // Example server-side key
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}



================================================
File: src/types.ts
================================================
// src/types.ts
// Import the Database type generated by Supabase CLI
// Adjust path as needed based on your project structure
import { type Database } from "./db/database.types";

// --- Shared Utility Type ---
export type Json = string | number | boolean | null | { [key: string]: Json | undefined } | Json[];

// --- Database Derived Types ---
// Alias types derived from the Supabase generated Database type for better readability
export type MeetingSummaryDbRow = Database["public"]["Tables"]["meeting_summaries"]["Row"];
export type MeetingSummaryDbInsert = Database["public"]["Tables"]["meeting_summaries"]["Insert"];
export type MeetingSummaryDbUpdate = Database["public"]["Tables"]["meeting_summaries"]["Update"];

// --- API Request DTOs ---

/**
 * DTO representing the request body for POST /api/summaries.
 * Matches the API specification for input data.
 * NOTE: Based on current DB schema and migrations, 'title' is NOT included here
 * as it seems to be generated by the backend or not provided via this specific DTO.
 */
export interface CreateSummaryRequestDTO {
  file_name?: string | null; // Optional in API, can be null or undefined
  transcription: string; // Required
  summary: string; // Required, max 500 characters in API spec (DB column is TEXT/string, Zod enforces length)
  llm_generated: boolean; // Required
  notes?: string | null; // Optional (API spec says 'string', can be empty string or null)
}

/**
 * DTO representing the request body for PUT /api/summaries/{id}.
 * Often similar to Create but might have different optionality or exclude fields.
 * Assuming it can update transcription, summary, file_name, notes, llm_generated.
 * Title is still assumed to be managed by backend or not updatable via this endpoint DTO.
 */
export interface UpdateSummaryRequestDTO {
  file_name?: string | null; // Optional
  transcription?: string; // Optional on update, but required if changing
  summary?: string; // Optional on update, but required if changing
  llm_generated?: boolean; // Optional
  notes?: string | null; // Optional
}

// --- API Response DTOs ---

/**
 * DTO representing the response body for successful POST /api/summaries (201 Created).
 * Based on the full DB row, mapping modified_at to updated_at, including 'title'.
 */
export type CreateSummaryResponseDTO = Omit<MeetingSummaryDbRow, "modified_at"> & {
  updated_at: MeetingSummaryDbRow["modified_at"]; // API uses 'updated_at'
  // MeetingSummaryDbRow already includes id, user_id, file_name, created_at, transcription, summary, llm_generated, notes, title
};

/**
 * DTO representing a single entry in the list response for GET /api/summaries.
 * Contains basic information for the list view, including 'title' and mapped 'updated_at'.
 * Matches the columns selected in the GET handler's service.
 */
export type MeetingSummaryListEntryDto = Pick<MeetingSummaryDbRow, "id" | "title" | "file_name" | "created_at"> & {
  updated_at: MeetingSummaryDbRow["modified_at"]; // Map DB 'modified_at' to API 'updated_at'
};

/**
 * DTO representing the full list response for GET /api/summaries.
 */
export type MeetingSummaryListDto = MeetingSummaryListEntryDto[];

/**
 * DTO representing the detailed information for a single summary (GET /api/summaries/{id}).
 * Includes all fields from the DB row except user_id, with mapped 'updated_at'.
 */
export type MeetingSummaryDetailsDto = Omit<
  MeetingSummaryDbRow,
  "user_id" | "modified_at" // user_id is omitted, modified_at is mapped
> & {
  updated_at: MeetingSummaryDbRow["modified_at"]; // API uses 'updated_at'
};

// --- Command/Service Layer Internal Types ---
// These types are used within the backend logic (handlers, services, repositories)
// Included here for completeness as they were in the provided types,
// but primarily relevant for backend implementation, not frontend views themselves.

/**
 * Type representing the structure of data inserted into the 'meeting_summaries' table.
 * Alias for the Supabase generated Insert type for this table.
 */
export type MeetingSummaryInsertData = MeetingSummaryDbInsert;

/**
 * Type representing the shape of a FULL row as returned by a SELECT query
 * like `select()`.
 * Alias for the Supabase generated Row type for this table.
 */
export type MeetingSummaryFullRow = MeetingSummaryDbRow;

/**
 * Type representing a subset of columns selected by the GET /api/summaries handler.
 * Explicitly defined to match the `.select()` call in SummaryService.
 */
export type MeetingSummarySelectedColumns = Pick<
  MeetingSummaryDbRow,
  "id" | "title" | "file_name" | "created_at" | "modified_at"
>;

/**
 * Command Model for query parameters for the list summaries endpoint (GET /api/summaries).
 * Represents the parsed and validated query parameters.
 */
export interface ListSummariesCommand {
  sort_by: "created_at" | "updated_at"; // API terms
  sort_order: "asc" | "desc";
  from_dt?: string; // ISO 8601 string (date only YYYY-MM-DD format expected by HTML input type="date")
  to_dt?: string; // ISO 8601 string (date only YYYY-MM-DD format expected by HTML input type="date")
}

/**
 * Type for parameters passed to the SummaryService's list method.
 * Uses Date objects for date range and DB column names for sorting.
 */
export interface ListSummariesServiceParams {
  userId: string;
  dateRange: { from?: Date; to?: Date };
  sortParams: {
    by: "created_at" | "modified_at"; // Service internal uses DB column names
    order: "asc" | "desc";
  };
}

// --- Other Command Models ---

/**
 * Command Model for the Generate Summary action (POST /api/generate-summary).
 */
export interface GenerateSummaryCommand {
  transcription: string; // The transcription text to summarize
}

/**
 * DTO representing the response from the Generate Summary action.
 */
export interface GenerateSummaryResponseDto {
  summary: string; // The generated summary text
}

// Note: Endpoint DELETE /api/summaries/{id} returns 204 No Content.
// Note: Endpoint PUT /api/summaries/{id} would likely need an UpdateMeetingSummaryCommand
// and an UpdateMeetingSummaryResponseDto. UpdateSummaryRequestDTO is defined above for frontend use.



================================================
File: src/components/Welcome.astro
================================================
<div
  class="relative w-full mx-auto min-h-screen bg-gradient-to-br from-indigo-900 via-purple-900 to-blue-900 p-4 sm:p-8"
>
  <div
    class="relative max-w-4xl mx-auto backdrop-blur-xl bg-gradient-to-b from-white/10 to-white/5 rounded-2xl shadow-2xl p-8 text-white border border-white/10"
  >
    <div class="space-y-8">
      <div class="text-center">
        <h1
          class="text-6xl font-bold mb-4 bg-gradient-to-r from-blue-200 via-purple-200 to-pink-200 text-transparent bg-clip-text drop-shadow-lg"
        >
          Witaj w 10xDevs Astro Starter!
        </h1>
        <p class="text-xl text-blue-100/90 drop-shadow-md">
          Ten projekt zostaĹ‚ zbudowany w oparciu o nowoczesny stack technologiczny:
        </p>
      </div>

      <div class="flex flex-col gap-6 max-w-2xl mx-auto">
        <div class="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-lg rounded-xl p-6 border border-white/10">
          <h2
            class="text-2xl font-semibold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-blue-200 to-purple-200"
          >
            Core
          </h2>
          <ul class="space-y-3">
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">Astro v5.5.5</span>
              <span class="text-blue-100/90">- Metaframework do aplikacji webowych</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">React v19</span>
              <span class="text-blue-100/90">- Biblioteka UI do komponentĂłw interaktywnych</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">TypeScript</span>
              <span class="text-blue-100/90">- Typowanie statyczne</span>
            </li>
          </ul>
        </div>

        <div class="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-lg rounded-xl p-6 border border-white/10">
          <h2
            class="text-2xl font-semibold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-blue-200 to-purple-200"
          >
            Stylowanie
          </h2>
          <ul class="space-y-3">
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm"
                >Tailwind CSS v4</span
              >
              <span class="text-blue-100/90">- Utility-first CSS framework</span>
            </li>
          </ul>
        </div>

        <div class="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-lg rounded-xl p-6 border border-white/10">
          <h2
            class="text-2xl font-semibold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-blue-200 to-purple-200"
          >
            Statyczna analiza kodu
          </h2>
          <ul class="space-y-3">
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">ESLint v9</span>
              <span class="text-blue-100/90">- Lintowanie kodu</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">Prettier</span>
              <span class="text-blue-100/90">- Formatowanie kodu</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm"
                >Husky i Lint-staged</span
              >
              <span class="text-blue-100/90">- Automatyczna analiza kodu przed commitowaniem</span>
            </li>
          </ul>
        </div>
      </div>

      <p class="text-lg text-center text-blue-100/90 mt-8 leading-relaxed">
        Starter zawiera wszystko, czego potrzebujesz do rozpoczÄ™cia tworzenia <br class="hidden sm:block" />
        <span class="font-semibold bg-gradient-to-r from-blue-200 to-purple-200 text-transparent bg-clip-text"
          >nowoczesnych aplikacji webowych!</span
        >
      </p>
    </div>
  </div>
</div>



================================================
File: src/components/layout/Topbar.tsx
================================================
// src/components/layout/Topbar.tsx
import * as React from "react";
import {
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuLink,
  navigationMenuTriggerStyle,
} from "@/components/ui/navigation-menu";
import { Button } from "@/components/ui/button";
import { supabase } from "@/auth"; // Use the shared supabase client
import { toast } from "sonner"; // Assuming sonner for toast
import { Loader2 } from "lucide-react"; // For spinner

const Topbar: React.FC = () => {
  const [isLoggingOut, setIsLoggingOut] = React.useState(false);

  const handleLogout = async () => {
    setIsLoggingOut(true);
    const { error } = await supabase.auth.signOut();
    setIsLoggingOut(false); // Reset loading state regardless of success/error

    if (error) {
      console.error("Logout Error:", error);
      toast({
        description: "WystÄ…piĹ‚ bĹ‚Ä…d podczas wylogowania.",
        variant: "destructive",
      });
      // Don't redirect automatically on error, user might want to try again
    } else {
      // Supabase listener or server-side check might handle redirect,
      // but client-side redirect ensures promptness.
      window.location.href = "/login";
    }
  };

  return (
    <header className="bg-primary text-primary-foreground p-4 shadow-md">
      <div className="container mx-auto flex items-center justify-between">
        <div className="text-xl font-bold">Meeting Summarizer</div>
        <NavigationMenu>
          <NavigationMenuList>
            <NavigationMenuItem>
              <NavigationMenuLink href="/summaries" className={navigationMenuTriggerStyle()}>
                Moje podsumowania
              </NavigationMenuLink>
            </NavigationMenuItem>
            <NavigationMenuItem>
              <NavigationMenuLink href="/create" className={navigationMenuTriggerStyle()}>
                Nowe podsumowanie
              </NavigationMenuLink>
            </NavigationMenuItem>
            <NavigationMenuItem>
              {/* Use a button inside the nav item for the logout action */}
              <Button
                variant="ghost"
                onClick={handleLogout}
                className="text-primary-foreground hover:bg-primary/90"
                disabled={isLoggingOut}
              >
                {isLoggingOut && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                Wyloguj
              </Button>
            </NavigationMenuItem>
          </NavigationMenuList>
        </NavigationMenu>
      </div>
    </header>
  );
};

export default Topbar;



================================================
File: src/components/ui/button.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }



================================================
File: src/components/views/LoginForm.tsx
================================================
// src/components/views/LoginForm.tsx
import * as React from "react";
import { useState } from "react";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { supabase } from "@/auth"; // Use the shared supabase client
import { Loader2 } from "lucide-react"; // Install lucide-react if not already: npx shadcn@latest add icon

const LoginForm: React.FC = () => {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setError(null); // Clear previous errors
    setIsLoading(true);

    // Call Supabase sign-in method
    const { error } = await supabase.auth.signInWithPassword({
      email,
      password,
    });

    if (error) {
      // Map Supabase error messages to user-friendly ones if needed
      setError(error.message);
      setIsLoading(false); // Reset loading on error
    } else {
      // On successful login, Supabase SDK manages the session in cookies/localStorage.
      // The MainLayout/middleware check on /summaries page load will see the session.
      // Force redirect immediately for better UX.
      window.location.href = "/summaries";
      // isLoading remains true briefly until the redirect happens, which is fine.
    }
  };

  return (
    <div className="w-full max-w-md p-8 space-y-6 bg-white rounded-lg shadow-md">
      <h2 className="text-2xl font-bold text-center">Zaloguj siÄ™</h2>
      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <Label htmlFor="email">Email</Label>
          <Input
            id="email"
            type="email"
            placeholder="marian@example.com"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
            disabled={isLoading} // Disable inputs while loading
          />
        </div>
        <div>
          <Label htmlFor="password">HasĹ‚o</Label>
          <Input
            id="password"
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
            disabled={isLoading} // Disable inputs while loading
          />
        </div>
        {error && <p className="text-sm font-medium text-red-500 text-center">{error}</p>}
        <Button type="submit" className="w-full" disabled={isLoading}>
          {isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
          Zaloguj
        </Button>
      </form>
    </div>
  );
};

export default LoginForm;



================================================
File: src/components/views/SummaryForm.tsx
================================================
// src/components/views/SummaryForm.tsx
import * as React from "react";
import { useState, useRef, useEffect, useCallback } from "react";
// Assuming '@/components/ui/label' and '@/components/ui/textarea' resolve correctly after checking filesystem and tsconfig.json
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea"; // Corrected the path to match the project structure
import { toast } from "sonner";
import { Loader2 } from "lucide-react";
import type { CreateSummaryRequestDTO, UpdateSummaryRequestDTO } from "@/types";
// import { supabase } from "@/auth"; // No longer needed directly for API calls needing auth token
import { apiService } from "@/lib/apiService"; // Import the apiService

interface SummaryFormProps {
  mode: "create" | "edit";
  summaryId?: string; // Required in 'edit' mode
}

const SummaryForm: React.FC<SummaryFormProps> = ({ mode, summaryId }) => {
  const [transcription, setTranscription] = useState("");
  const [summary, setSummary] = useState("");
  const [notes, setNotes] = useState<string | null>(""); // Initialize as empty string or null
  const [fileName, setFileName] = useState<string | null>(null); // For display in edit mode / payload in create
  const [isSummarizing, setIsSummarizing] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [loadError, setLoadError] = useState<string | null>(null); // For edit mode initial load error
  const [actionError, setActionError] = useState<string | null>(null); // For summarize/save errors
  const [isLLMGenerated, setIsLLMGenerated] = useState(false); // Track if current summary was LLM generated
  const [isInitialLoading, setIsInitialLoading] = useState(mode === "edit"); // Loading state for initial fetch in edit mode

  const fileInputRef = useRef<HTMLInputElement>(null);

  // Fetch summary details in edit mode
  const fetchSummary = useCallback(async (id: string) => {
    setIsInitialLoading(true);
    setLoadError(null); // Clear previous load errors
    try {
      // Use the apiService to fetch data
      const data = await apiService.getSummaryDetails(id);
      setTranscription(data.transcription || "");
      setSummary(data.summary || "");
      setNotes(data.notes || ""); // Initialize with empty string if notes is null
      setFileName(data.file_name || data.title || `Podsumowanie ${id}`); // Display file name or title
      setIsLLMGenerated(data.llm_generated);
      setIsInitialLoading(false);
    } catch (err: unknown) {
      // Changed err: any to err: unknown
      console.error("Failed to fetch summary details:", err);
      // Display inline load error for edit mode
      // Use type guard to safely access message property
      const errorMessage = err instanceof Error ? err.message : String(err);
      setLoadError("Nie udało się załadować podsumowania do edycji. Spróbuj ponownie. Szczegóły: " + errorMessage);
      setIsInitialLoading(false);
    }
  }, []);

  // Effect to load data in edit mode
  useEffect(() => {
    if (mode === "edit" && summaryId) {
      fetchSummary(summaryId);
    } else if (mode === "create") {
      // Clear states for create mode
      setTranscription("");
      setSummary("");
      setNotes(""); // Clear notes to empty string for new entry
      setFileName(null);
      setIsLLMGenerated(false);
      setIsInitialLoading(false); // No initial loading in create mode
      setLoadError(null);
      setActionError(null);
      // Clear file input value as well
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    }
  }, [mode, summaryId, fetchSummary]); // Depend on mode, summaryId, and memoized fetchSummary

  // Clear action error when user starts typing in transcription or summary or notes
  const handleTranscriptionChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setTranscription(e.target.value);
    setActionError(null); // Clear error when transcription changes
    // Decide if manual edit means it's no longer LLM generated?
    // Let's keep isLLMGenerated based on whether 'Podsumuj' was the *last* action populating summary.
  };

  const handleSummaryChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setSummary(e.target.value);
    setActionError(null); // Clear error when summary changes
    setIsLLMGenerated(false); // If user manually edits summary, it's not purely LLM generated anymore
  };

  const handleNotesChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setNotes(e.target.value);
    setActionError(null); // Clear error when notes change
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    setActionError(null); // Clear action errors on new file upload

    if (file) {
      if (file.size > 1024 * 1024) {
        // 1MB limit
        // Correct toast usage: message as first argument, options as second
        toast("Plik jest za duży (max 1 MB).", {
          variant: "destructive",
        });
        // Reset file input value to allow selecting the same file again after error
        if (fileInputRef.current) {
          fileInputRef.current.value = "";
        }
        setFileName(null);
        setTranscription(""); // Clear transcription as file is invalid
        setSummary(""); // Clear summary as transcription changed/failed
        setNotes(""); // Clear notes
        setIsLLMGenerated(false);
        return;
      }

      setFileName(file.name);
      setTranscription(""); // Clear old transcription
      setSummary(""); // Clear summary when a new transcription is loaded
      setNotes(""); // Clear notes
      setIsLLMGenerated(false); // Clear LLM status

      const reader = new FileReader();
      reader.onload = (e) => {
        const text = e.target?.result as string;
        setTranscription(text);
        // Correct toast usage
        toast(`Plik "${file.name}" wczytany.`);
      };
      reader.onerror = () => {
        setActionError("Nie udało się odczytać pliku.");
        setFileName(null);
        setTranscription("");
        setSummary("");
        setNotes("");
        setIsLLMGenerated(false);
        // Correct toast usage
        toast(`Błąd odczytu pliku "${file?.name}".`, {
          variant: "destructive",
        });
      };
      reader.readAsText(file);
    } else {
      // File input was cancelled or cleared
      setFileName(null);
      setTranscription("");
      setSummary("");
      setNotes("");
      setIsLLMGenerated(false);
      setActionError(null); // Clear error if file input is cancelled/cleared
    }
    // Reset file input value when done processing (success or error)
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  const handleSummarize = async () => {
    // Basic validation before calling API
    const isBusy = isInitialLoading || isSummarizing || isSaving; // Recalculate locally
    if (!transcription.trim() || isBusy) return; // Check if transcription is empty or only whitespace

    setIsSummarizing(true);
    setActionError(null); // Clear previous action errors

    try {
      // apiService is updated to handle/skip auth based on MVP rules
      const result = await apiService.generateSummary({ transcription });
      setSummary(result.summary);
      setIsLLMGenerated(true); // Mark as LLM generated
      // Correct toast usage
      toast("Podsumowanie wygenerowane pomyślnie.");
    } catch (err: unknown) {
      // Changed err: any to err: unknown
      // Explicitly type as any if error object structure is unknown
      console.error("Summarize error:", err);
      // Use type guard to safely access message property
      const errorMessage = err instanceof Error ? err.message : String(err);
      setActionError(`Błąd generowania podsumowania: ${errorMessage || "Nieznany błąd"}`);
      setSummary(""); // Clear summary on error
      setIsLLMGenerated(false); // Ensure flag is false on error
    } finally {
      setIsSummarizing(false);
    }
  };

  const handleSave = async () => {
    // Basic validation before calling API
    const isBusy = isInitialLoading || isSummarizing || isSaving; // Recalculate locally
    if (!summary.trim() || isBusy) return; // Check if summary is empty or only whitespace

    setIsSaving(true);
    setActionError(null); // Clear previous action errors

    try {
      if (mode === "create") {
        const payload: CreateSummaryRequestDTO = {
          file_name: fileName, // Include file name from state
          transcription: transcription, // Required
          summary: summary, // Required
          llm_generated: isLLMGenerated, // Use tracked status
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to create summary
        await apiService.createSummary(payload); // POST /api/summaries
        // Correct toast usage
        toast("Podsumowanie zapisane.");
        window.location.href = "/summaries"; // Redirect after create save
      } else if (mode === "edit" && summaryId) {
        const payload: UpdateSummaryRequestDTO = {
          // file_name is not typically updated in edit mode based on plan display
          // If file_name should be updatable, add: file_name: fileName,
          transcription: transcription, // Include transcription for update
          summary: summary, // Include summary for update
          llm_generated: isLLMGenerated, // Include status in update
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to update summary
        await apiService.updateSummary(summaryId, payload); // PUT /api/summaries/{id}

        // Correct toast usage
        toast("Zmiany zapisane.");
        // No redirect after edit save as per plan (user can click cancel/nav)
        setIsSaving(false); // Reset saving state on success if not redirecting
      }
    } catch (err: unknown) {
      // Changed err: any to err: unknown
      // Explicitly type as any if error object structure is unknown
      console.error("Save error:", err);
      // Display inline save error
      // Use type guard to safely access message property
      const errorMessage = err instanceof Error ? err.message : String(err);
      setActionError(`Błąd zapisu: ${errorMessage || "Nieznany błąd"}`);
      setIsSaving(false); // Reset saving state on error
    }
  };

  const handleCancel = () => {
    // Simple redirect, no confirmation needed as per plan
    window.location.href = "/summaries"; // Navigate back
  };

  // Determine if any major operation is in progress to disable controls
  const isBusy = isInitialLoading || isSummarizing || isSaving;
  // Determine if save button should be disabled (requires non-empty summary AND not busy)
  const isSaveDisabled = !summary.trim() || isBusy;
  // Determine if summarize button should be disabled (requires non-empty transcription AND not busy)
  const isSummarizeDisabled = !transcription.trim() || isBusy;

  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold">{mode === "create" ? "Nowe podsumowanie" : `Edytuj podsumowanie`}</h1>
      {/* Display title/file name in edit mode if available */}
      {mode === "edit" &&
        !isInitialLoading &&
        (fileName || summaryId) && ( // Only show if not initially loading
          // Added margin-bottom to separate from fields below
          <div className="text-lg font-semibold text-muted-foreground -mt-4 mb-4">{fileName || `ID: ${summaryId}`}</div>
        )}

      {/* Display initial load error in edit mode */}
      {loadError && mode === "edit" && <p className="text-sm font-medium text-red-500">{loadError}</p>}

      {/* Display spinner for initial load in edit mode */}
      {isInitialLoading ? (
        <div className="flex flex-col justify-center items-center h-64">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
          <span className="mt-2 text-muted-foreground">Ładowanie podsumowania...</span>
        </div>
      ) : (
        <>
          {/* File Upload Section (only in create mode) */}
          {mode === "create" && (
            // Added margin-bottom to separate from transcription field
            <div className="flex flex-col sm:flex-row items-start sm:items-center space-y-2 sm:space-y-0 sm:space-x-4 mb-4">
              <input
                id="file-upload"
                type="file"
                accept=".txt"
                ref={fileInputRef}
                onChange={handleFileChange}
                className="hidden" // Hide the default input
                disabled={isBusy} // Disable file input while busy
              />
              {/* Style label to look like a button */}
              <Label
                htmlFor="file-upload"
                className="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 h-10 px-4 py-2 bg-primary text-primary-foreground hover:bg-primary/90 cursor-pointer"
                data-disabled={isBusy} // Use data-disabled for styling based on isBusy
              >
                Wczytaj plik TXT (max 1 MB)
              </Label>
              {fileName && <span className="text-sm text-muted-foreground">{fileName}</span>}
            </div>
          )}

          <div>
            <Label htmlFor="transcription">Transkrypcja</Label>
            <Textarea
              id="transcription"
              value={transcription}
              onChange={handleTranscriptionChange} // Use refined handler
              placeholder="Wklej lub wczytaj tekst transkrypcji tutaj..."
              rows={10}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          <div>
            <Label htmlFor="summary">Podsumowanie</Label>
            <Textarea
              id="summary"
              value={summary}
              onChange={handleSummaryChange}
              placeholder="Wygeneruj lub wpisz podsumowanie tutaj..."
              rows={6}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Notes field - Add this field */}
          <div>
            <Label htmlFor="notes">Notatki (opcjonalnie)</Label>
            <Textarea
              id="notes"
              value={notes || ""} // Use empty string for controlled component if notes is null
              onChange={handleNotesChange}
              placeholder="Dodaj dodatkowe notatki..."
              rows={3}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Display action-specific errors (e.g., LLM error, save error) */}
          {actionError && (
            // Added margin-top and positioned above action buttons
            <p className="text-sm font-medium text-red-500 mt-4 text-center">{actionError}</p>
          )}

          {/* Action Buttons */}
          <div className="flex flex-col sm:flex-row justify-end gap-2 pt-4">
            <Button variant="outline" onClick={handleCancel} disabled={isBusy}>
              Anuluj
            </Button>
            <Button onClick={handleSummarize} disabled={isSummarizeDisabled}>
              {isSummarizing && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Podsumuj
            </Button>
            <Button onClick={handleSave} disabled={isSaveDisabled}>
              {isSaving && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Zapisz
            </Button>
          </div>

          {/* Footer displaying ID in edit mode */}
          {mode === "edit" &&
            summaryId &&
            !isInitialLoading && ( // Only show if in edit mode and not initially loading
              <div className="text-sm text-muted-foreground mt-4 border-t pt-4 text-center">
                {" "}
                {/* Added border and padding top */}
                ID Podsumowania: {summaryId}
              </div>
            )}
        </>
      )}
    </div>
  );
};

export default SummaryForm;



================================================
File: src/components/views/SummaryList.tsx
================================================
// src/components/views/SummaryList.tsx
import * as React from "react";
import { useState, useEffect, useCallback } from "react"; // Import useCallback
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Loader2, ArrowUpDown, Edit, Trash2 } from "lucide-react"; // Add Edit, Trash2 icons
import type { MeetingSummaryListEntryDto, ListSummariesCommand } from "@/types";
import { format } from "date-fns";
import { pl } from "date-fns/locale";
// import { supabase } from "@/auth"; // No longer needed directly for API calls needing auth token
import { apiService } from "@/lib/apiService"; // Import the apiService
import { toast } from "sonner"; // Import toast

// Import date-fns parseISO for parsing date strings from state
import { parseISO } from "date-fns";

const SummaryList: React.FC = () => {
  const [summaries, setSummaries] = useState<MeetingSummaryListEntryDto[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [filterFromDate, setFilterFromDate] = useState<string>(""); // YYYY-MM-DD format for input type="date"
  const [filterToDate, setFilterToDate] = useState<string>(""); // YYYY-MM-DD format for input type="date"
  // State for sort column should use API terms as sent to backend
  const [sortColumn, setSortColumn] = useState<ListSummariesCommand["sort_by"]>("created_at");
  const [sortOrder, setSortOrder] = useState<ListSummariesCommand["sort_order"]>("desc");

  // Memoize fetchSummaries to prevent re-creation on every render
  // useCallback is important here because fetchSummaries is a dependency of useEffect
  const fetchSummaries = useCallback(async (params: ListSummariesCommand) => {
    setIsLoading(true);
    setError(null); // Clear inline error on new fetch
    try {
      // Use the apiService to fetch data
      // apiService is updated to handle/skip auth based on MVP rules
      const data = await apiService.fetchSummaries(params);
      setSummaries(data);
    } catch (err: any) {
      console.error("Failed to fetch summaries:", err);
      // Display generic error message inline above the table
      setError("Nie udało się załadować listy podsumowań. Spróbuj ponownie później.");
      // Optionally, use toast for a less intrusive notification for list loading errors
      // toast({
      //   description: "Wystąpił błąd podczas ładowania listy.",
      //   variant: "destructive",
      // });
    } finally {
      setIsLoading(false);
    }
  }, []); // Dependencies are managed by the state changes that trigger useEffect

  useEffect(() => {
    // Fetch data on mount and when filter/sort params change
    // The date inputs give YYYY-MM-DD, which is sufficient for the backend to parse.
    fetchSummaries({
      from_dt: filterFromDate,
      to_dt: filterToDate,
      sort_by: sortColumn,
      sort_order: sortOrder,
    });
  }, [filterFromDate, filterToDate, sortColumn, sortOrder, fetchSummaries]); // Dependencies now include memoized fetchSummaries

  const handleSortChange = (column: ListSummariesCommand["sort_by"]) => {
    if (sortColumn === column) {
      // Toggle order if clicking the same column
      setSortOrder(sortOrder === "asc" ? "desc" : "asc");
    } else {
      // Set new column and default to desc order
      setSortColumn(column);
      setSortOrder("desc"); // Or 'asc', based on desired default when changing column
    }
    // fetchSummaries will be called by useEffect due to sort state change
  };

  const handleEditClick = (id: string) => {
    // Redirect to the edit page
    window.location.href = `/edit/${id}`;
  };

  const handleDeleteClick = async (id: string, title: string) => {
    if (confirm(`Czy na pewno chcesz usunąć podsumowanie "${title || id}"?`)) {
      try {
        // Use apiService to delete the summary
        await apiService.deleteSummary(id);
        toast({
          description: `Podsumowanie "${title || id}" usunięto.`,
          // variant: "success" // Requires success variant styling
        });
        // Refresh the list after deletion
        // Re-fetch with current filters/sort order
        fetchSummaries({
          from_dt: filterFromDate,
          to_dt: filterToDate,
          sort_by: sortColumn,
          sort_order: sortOrder,
        });
      } catch (err: any) {
        console.error("Failed to delete summary:", err);
        toast({
          description: `Nie udało się usunąć podsumowania "${title || id}". Szczegóły: ${err.message || ""}`,
          variant: "destructive",
        });
      }
    }
  };

  const handleCreateClick = () => {
    // Redirect to the create page
    window.location.href = "/create";
  };

  // Function to format date strings for display
  const formatDate = (dateString: string) => {
    if (!dateString) return "-";
    try {
      // Use date-fns parseISO for reliable parsing of ISO strings from API
      const date = parseISO(dateString);

      if (isNaN(date.getTime())) {
        return "Niepoprawna data";
      }
      // Format as dd.MM.yyyy HH:mm
      return format(date, "dd.MM.yyyy HH:mm", { locale: pl });
    } catch (e) {
      console.error("Failed to format date:", dateString, e);
      return "Błąd formatowania daty";
    }
  };

  return (
    <div className="space-y-6">
      {/* Page Title and New Summary Button */}
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-bold">Moje podsumowania</h1>
        <Button onClick={handleCreateClick}>Nowe podsumowanie</Button>
      </div>

      {/* Filtering Section */}
      {/* Added margin-top to separate from title */}
      <div className="flex flex-col sm:flex-row items-start sm:items-end gap-4 p-4 border rounded-md bg-card mt-4">
        <div className="flex flex-col gap-2 w-full sm:w-auto">
          <Label htmlFor="filterFrom">Utworzone od:</Label>
          <Input
            id="filterFrom"
            type="date"
            value={filterFromDate}
            onChange={(e) => setFilterFromDate(e.target.value)}
          />
        </div>
        <div className="flex flex-col gap-2 w-full sm:w-auto">
          <Label htmlFor="filterTo">Utworzone do:</Label>
          <Input id="filterTo" type="date" value={filterToDate} onChange={(e) => setFilterToDate(e.target.value)} />
        </div>
        {/* Filter button is redundant if filtering updates on date input change */}
        {/* <Button onClick={handleFilterClick}>Filtruj</Button> */}
      </div>

      {/* Error Display (inline for list loading) */}
      {error && <p className="text-sm font-medium text-red-500 mt-4">{error}</p>}

      {/* Summary Table */}
      <div className="border rounded-md overflow-hidden">
        <Table>
          <TableHeader className="bg-muted/50">
            <TableRow>
              {/* Title/File Name Header */}
              <TableHead className="min-w-[150px]">Nazwa/Tytuł</TableHead>
              {/* Created At Header (Sortable) */}
              <TableHead
                className="cursor-pointer hover:text-primary min-w-[150px]" // Added min-width for date columns
                onClick={() => handleSortChange("created_at")}
              >
                <div className="flex items-center">
                  {" "}
                  {/* Flex for text and icon alignment */}
                  Data utworzenia
                  {/* Display sort indicator */}
                  {sortColumn === "created_at" &&
                    (sortOrder === "asc" ? (
                      <ArrowUpDown className="ml-1 h-4 w-4 inline-block rotate-180" />
                    ) : (
                      <ArrowUpDown className="ml-1 h-4 w-4 inline-block" />
                    ))}
                  {/* Show muted icon if not sorting by this column */}
                  {sortColumn !== "created_at" && (
                    <ArrowUpDown className="ml-1 h-4 w-4 inline-block text-muted-foreground opacity-50" />
                  )}
                </div>
              </TableHead>
              {/* Updated At Header (Sortable) */}
              <TableHead
                className="cursor-pointer hover:text-primary min-w-[150px]" // Added min-width
                onClick={() => handleSortChange("updated_at")}
              >
                <div className="flex items-center">
                  {" "}
                  {/* Flex for text and icon alignment */}
                  Data modyfikacji
                  {/* Display sort indicator */}
                  {sortColumn === "updated_at" &&
                    (sortOrder === "asc" ? (
                      <ArrowUpDown className="ml-1 h-4 w-4 inline-block rotate-180" />
                    ) : (
                      <ArrowUpDown className="ml-1 h-4 w-4 inline-block" />
                    ))}
                  {/* Show muted icon if not sorting by this column */}
                  {sortColumn !== "updated_at" && (
                    <ArrowUpDown className="ml-1 h-4 w-4 inline-block text-muted-foreground opacity-50" />
                  )}
                </div>
              </TableHead>
              {/* Actions Header */}
              <TableHead className="text-right min-w-[120px]">Akcje</TableHead> {/* Adjusted min-width for 2 buttons */}
            </TableRow>
          </TableHeader>
          <TableBody>
            {isLoading ? (
              <TableRow>
                <TableCell colSpan={4} className="text-center py-8">
                  <Loader2 className="h-8 w-8 animate-spin mx-auto text-primary" />
                  <span className="mt-2 block">Ładowanie...</span>
                </TableCell>
              </TableRow>
            ) : summaries.length === 0 ? (
              <TableRow>
                <TableCell colSpan={4} className="text-center py-8 text-muted-foreground">
                  Brak podsumowań do wyświetlenia.
                </TableCell>
              </TableRow>
            ) : (
              summaries.map((summary) => (
                <TableRow key={summary.id}>
                  <TableCell className="font-medium max-w-[200px] truncate">
                    {summary.title || summary.file_name || "Bez nazwy"}
                  </TableCell>{" "}
                  {/* Display title or file_name, truncate long names */}
                  <TableCell>{formatDate(summary.created_at)}</TableCell>
                  <TableCell>{formatDate(summary.updated_at)}</TableCell>
                  <TableCell className="text-right flex gap-2 justify-end">
                    {" "}
                    {/* Use flex gap for buttons */}
                    <Button variant="outline" size="sm" onClick={() => handleEditClick(summary.id)}>
                      <Edit className="h-4 w-4" />
                      {/* Visually hide text on small screens for icon-only button */}
                      <span className="sr-only sm:not-sr-only">Edytuj</span>
                    </Button>
                    {/* Delete button - add confirmation */}
                    <Button
                      variant="destructive"
                      size="sm"
                      onClick={() => handleDeleteClick(summary.id, summary.title || summary.file_name || "")}
                    >
                      <Trash2 className="h-4 w-4" />
                      {/* Visually hide text on small screens for icon-only button */}
                      <span className="sr-only sm:not-sr-only">Usuń</span>
                    </Button>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>
    </div>
  );
};

export default SummaryList;



================================================
File: src/db/database.types.ts
================================================
export type Json = string | number | boolean | null | { [key: string]: Json | undefined } | Json[];

export interface Database {
  graphql_public: {
    Tables: Record<never, never>;
    Views: Record<never, never>;
    Functions: {
      graphql: {
        Args: {
          operationName?: string;
          query?: string;
          variables?: Json;
          extensions?: Json;
        };
        Returns: Json;
      };
    };
    Enums: Record<never, never>;
    CompositeTypes: Record<never, never>;
  };
  public: {
    Tables: {
      meeting_summaries: {
        Row: {
          created_at: string;
          file_name: string | null;
          id: string;
          llm_generated: boolean;
          modified_at: string;
          notes: string | null;
          summary: string;
          title: string;
          transcription: string;
          user_id: string;
        };
        Insert: {
          created_at?: string;
          file_name?: string | null;
          id?: string;
          llm_generated?: boolean;
          modified_at?: string;
          notes?: string | null;
          summary: string;
          title: string;
          transcription: string;
          user_id: string;
        };
        Update: {
          created_at?: string;
          file_name?: string | null;
          id?: string;
          llm_generated?: boolean;
          modified_at?: string;
          notes?: string | null;
          summary?: string;
          title?: string;
          transcription?: string;
          user_id?: string;
        };
        Relationships: [
          {
            foreignKeyName: "meeting_summaries_user_id_fkey";
            columns: ["user_id"];
            isOneToOne: false;
            referencedRelation: "users";
            referencedColumns: ["id"];
          },
        ];
      };
      users: {
        Row: {
          created_at: string | null;
          email: string;
          id: string;
        };
        Insert: {
          created_at?: string | null;
          email: string;
          id: string;
        };
        Update: {
          created_at?: string | null;
          email?: string;
          id?: string;
        };
        Relationships: [];
      };
    };
    Views: Record<never, never>;
    Functions: Record<never, never>;
    Enums: Record<never, never>;
    CompositeTypes: Record<never, never>;
  };
}

type DefaultSchema = Database[Extract<keyof Database, "public">];

export type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database;
  }
    ? keyof (Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
        Database[DefaultSchemaTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? (Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
      Database[DefaultSchemaTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R;
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
    ? (DefaultSchema["Tables"] & DefaultSchema["Views"])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R;
      }
      ? R
      : never
    : never;

export type TablesInsert<
  DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"] | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database;
  }
    ? keyof Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I;
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I;
      }
      ? I
      : never
    : never;

export type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"] | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database;
  }
    ? keyof Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U;
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U;
      }
      ? U
      : never
    : never;

export type Enums<
  DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"] | { schema: keyof Database },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof Database;
  }
    ? keyof Database[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"]
    ? DefaultSchema["Enums"][DefaultSchemaEnumNameOrOptions]
    : never;

export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends keyof DefaultSchema["CompositeTypes"] | { schema: keyof Database },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof Database;
  }
    ? keyof Database[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
    : never = never,
> = PublicCompositeTypeNameOrOptions extends { schema: keyof Database }
  ? Database[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema["CompositeTypes"]
    ? DefaultSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
    : never;

export const Constants = {
  graphql_public: {
    Enums: {},
  },
  public: {
    Enums: {},
  },
} as const;



================================================
File: src/db/supabase.client.ts
================================================
// src/db/supabase.client.ts
// Import the base SupabaseClient type and createServerClient from the library
// FIX: Use @supabase/ssr for the SSR client factory and type alias base as intended for middleware/server routes
import { type SupabaseClient as SupabaseClientBase } from "@supabase/ssr";
import { createServerClient } from "@supabase/ssr"; // Import the SSR factory

// Import your local Database type
import type { Database } from "./database.types"; // Adjust path as needed

// --- Static User ID for MVP (TEMPORARY INSECURE WORKAROUND) ---
// IMPORTANT: This ID is used in API handlers instead of authenticated user ID
// as per specific MVP rule "Don't use any auth at the moment - use the user defined in the supabase.client.ts".
// This OVERRIDES standard Supabase RLS behavior for API endpoints and is INSECURE for production.
// Replace with the actual UUID of the user you want to use for testing MVP DB interactions.
// This user should exist in your Supabase auth.users and public.users tables.
export const DEFAULT_USER_ID = "9575a8e6-4160-45f5-93bd-0ff215ae4c83"; // !!! REPLACE WITH YOUR DEFAULT USER ID !!!

// Export the SupabaseClient type alias, parameterized with your Database type
// This is the type to use for type hinting the Supabase client instance (both server and browser).
// FIX: This type alias is now the authoritative source for SupabaseClient type in the project
export type SupabaseClient = SupabaseClientBase<Database>;

// Export createServerClient for use in Astro middleware and server code.
// The browser client instance is now exported from src/auth.ts.
export { createServerClient };

// Remove the direct export of `supabaseClient` instance from here, as it's now in `src/auth.ts`
// export const supabaseClient = ... ; // REMOVE THIS



================================================
File: src/layouts/Layout.astro
================================================
---
// src/layouts/Layout.astro
// Optional: A base layout that might include global things like fonts, head tags, etc.
// This could wrap MainLayout and the login page if needed.
// If MainLayout is the top-level layout, this file might be redundant.
// Keeping it for completeness based on description, but it's not strictly necessary
// if MainLayout or individual pages handle <Toaster /> and base styles.
// Let's assume MainLayout handles Toaster and base styles for simplicity as shown there.
// This file is effectively not used in the current structure if MainLayout is the wrapper.
// The code below is just a placeholder if a higher-level layout was desired.
---

<!doctype html>
<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="generator" content={Astro.generator} />
    <title>Meeting Summarizer App</title>
    <meta name="description" content="Meeting summarizer application" />
    <!-- Link to your global stylesheet -->
    <link rel="stylesheet" href="/styles/globals.css" />
  </head>
  <body class="min-h-screen bg-background font-sans antialiased">
    <slot />
    {/* If Toaster is placed here, remove it from MainLayout and login page */}
    {/* <Toaster /> */}
  </body>
</html>



================================================
File: src/layouts/MainLayout.astro
================================================
---
// src/layouts/MainLayout.astro
import { getSession } from "auth"; // Assume auth.ts handles Supabase session check

// Middleware/Layout check: Redirect if not authenticated
// This runs on the server side for Astro pages
const session = await getSession(Astro.request);
if (!session) {
  // Use a Response redirect for SSR
  return new Response(null, {
    status: 302,
    headers: {
      Location: "/login",
    },
  });
}

// Assume Toaster (Sonner) is globally configured in a parent Layout
// or directly in index.astro if no parent layout exists.
// If MainLayout is the top-level layout for authenticated pages,
// the <Toaster /> component should be placed here.
// For consistency, let's place it here, assuming this is the main auth wrapper.

import Topbar from "@/components/layout/Topbar";
import { Toaster } from "@/components/ui/sonner"; // Assuming Sonner is used for Toast
import "../styles/globals.css"; // Ensure Tailwind base styles are included

// Basic props for the layout
interface Props {
  title?: string; // Optional title for the page
}

const { title = "Meeting Summarizer" } = Astro.props; // Default title
---

<!doctype html>
<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="generator" content={Astro.generator} />
    <title>{title}</title>
  </head>
  <body class="flex flex-col min-h-screen">
    {/* Render the Topbar component, needs to be client-side interactive */}
    <Topbar client:load />

    <main class="flex-grow container mx-auto px-4 py-8">
      {/* This is where the content of the specific page using this layout will be injected */}
      <slot />
    </main>

    {/* Render the Toaster component */}
    <Toaster />
  </body>
</html>



================================================
File: src/lib/apiService.ts
================================================
// src/lib/apiService.ts
// import { supabase } from "@/auth"; // No longer needed directly for API calls needing auth token
import type {
  // Import types for DTOs
  ListSummariesCommand,
  MeetingSummaryListEntryDto,
  MeetingSummaryDetailsDto,
  CreateSummaryRequestDTO,
  CreateSummaryResponseDTO,
  UpdateSummaryRequestDTO,
  GenerateSummaryCommand,
  GenerateSummaryResponseDto,
} from "@/types";

// Helper function for generic fetch calls
// IMPORTANT: This MVP version does NOT include the Authorization header.
// This is INSECURE for production API endpoints and violates the general API plan.
// This is done only to adhere to the specific MVP rule "Don't use any auth at the moment".
const fetchWithoutAuth = async (url: string, options: RequestInit = {}): Promise<Response> => {
  console.warn(`apiService: Making insecure API call to ${url} without Authorization header (MVP ONLY).`);
  const headers = {
    "Content-Type": "application/json",
    ...options.headers,
  };
  const response = await fetch(url, { ...options, headers });

  if (!response.ok) {
    let errorDetail = `API Error: ${response.status}`;
    try {
      // Attempt to parse error body for more details
      const errorBody = await response.json();
      errorDetail = errorBody.message || errorBody.error || JSON.stringify(errorBody);
    } catch (e) {
      // If JSON parsing fails, just use status text
      errorDetail = `${response.status} ${response.statusText}`;
    }
    const error = new Error(`Request failed: ${errorDetail}`);
    // Attach status code for potential specific handling if needed
    (error as any).status = response.status;
    throw error;
  }

  return response;
};

export const apiService = {
  // GET /api/summaries
  async fetchSummaries(params: ListSummariesCommand): Promise<MeetingSummaryListEntryDto[]> {
    const queryParams = new URLSearchParams();
    if (params.from_dt) queryParams.append("from_dt", params.from_dt);
    if (params.to_dt) queryParams.append("to_dt", params.to_dt);
    queryParams.append("sort_by", params.sort_by);
    queryParams.append("sort_order", params.sort_order);

    const url = `/api/summaries?${queryParams.toString()}`;

    // Use fetchWithoutAuth as auth is skipped in backend handler for this MVP
    const response = await fetchWithoutAuth(url, { method: "GET" });
    return response.json() as Promise<MeetingSummaryListEntryDto[]>;
  },

  // GET /api/summaries/{id}
  async getSummaryDetails(id: string): Promise<MeetingSummaryDetailsDto> {
    const url = `/api/summaries/${id}`;
    // Use fetchWithoutAuth as auth is skipped in backend handler for this MVP
    const response = await fetchWithoutAuth(url, { method: "GET" });
    if (response.status === 404) {
      // Explicitly handle 404 from API
      throw new Error(`Summary with ID ${id} not found.`);
    }
    return response.json() as Promise<MeetingSummaryDetailsDto>;
  },

  // POST /api/summaries
  async createSummary(data: CreateSummaryRequestDTO): Promise<CreateSummaryResponseDTO> {
    const url = "/api/summaries";
    // Use fetchWithoutAuth as auth is skipped in backend handler for this MVP
    const response = await fetchWithoutAuth(url, {
      method: "POST",
      body: JSON.stringify(data),
    });
    // API returns 201 Created with the new resource body
    return response.json() as Promise<CreateSummaryResponseDTO>;
  },

  // PUT /api/summaries/{id}
  async updateSummary(id: string, data: UpdateSummaryRequestDTO): Promise<MeetingSummaryDetailsDto> {
    const url = `/api/summaries/${id}`;
    // Use fetchWithoutAuth as auth is skipped in backend handler for this MVP
    const response = await fetchWithoutAuth(url, {
      method: "PUT",
      body: JSON.stringify(data),
    });
    if (response.status === 404) {
      throw new Error(`Summary with ID ${id} not found for update.`);
    }
    // API returns 200 OK with the updated resource body
    return response.json() as Promise<MeetingSummaryDetailsDto>;
  },

  // DELETE /api/summaries/{id}
  async deleteSummary(id: string): Promise<void> {
    const url = `/api/summaries/${id}`;
    // Use fetchWithoutAuth as auth is skipped in backend handler for this MVP
    const response = await fetchWithoutAuth(url, {
      method: "DELETE",
    });
    if (response.status === 204) {
      return; // Success (No Content)
    }
    if (response.status === 404) {
      throw new Error(`Summary with ID ${id} not found for deletion.`);
    }
    // If response is OK but not 204/404, maybe there's a body? Handle as error.
    let errorDetail = `API Error: ${response.status}`;
    try {
      const errorBody = await response.json();
      errorDetail = errorBody.message || errorBody.error || errorDetail;
    } catch (e) {
      /* ignore */
    }
    throw new Error(`Delete failed unexpectedly: ${errorDetail}`);
  },

  // POST /api/generate-summary
  async generateSummary(data: GenerateSummaryCommand): Promise<GenerateSummaryResponseDto> {
    const url = "/api/generate-summary";
    // Use fetchWithoutAuth as auth is skipped in backend handler for this MVP
    const response = await fetchWithoutAuth(url, {
      method: "POST",
      body: JSON.stringify(data),
    });
    if (response.status === 500) {
      // Backend LLM errors are returned as 500 with a generic message
      throw new Error(`Failed to generate summary. Please try again.`); // Use a user-friendly message
    }
    return response.json() as Promise<GenerateSummaryResponseDto>;
  },
};



================================================
File: src/lib/utils.ts
================================================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}



================================================
File: src/middleware/index.ts
================================================
// src/middleware/index.ts
import { defineMiddleware } from "astro:middleware";
import type { APIContext } from "astro"; // Import APIContext type

// Import the createServerClient function and Database type from your local files
import { createServerClient } from "../db/supabase.client.ts"; // Use your local imports
import type { Database } from "../db/database.types.ts"; // Adjust path if necessary

export const onRequest = defineMiddleware(async (context: APIContext, next) => {
  // Ensure environment variables are available server-side
  const supabaseUrl = context.locals.runtime.env.SUPABASE_URL;
  const supabaseKey = context.locals.runtime.env.SUPABASE_KEY;

  if (!supabaseUrl || !supabaseKey) {
    console.error("SUPABASE_URL or SUPABASE_KEY not found in server environment variables.");
    // In production, you might want to halt or return a specific error page.
    // For development, let's just log and proceed, although Supabase calls will likely fail.
    // return new Response("Internal Server Error: Supabase environment variables not set.", { status: 500 });
  }

  // Create a Supabase client instance specifically for this server-side request
  // This client will automatically read/write cookies based on the request/response
  // and is essential for server-side authentication checks and RLS to work correctly with auth.uid().
  const supabase = createServerClient<Database>(supabaseUrl, supabaseKey, {
    cookies: {
      get: context.cookies.get,
      set: context.cookies.set,
      remove: context.cookies.delete,
    },
  });

  // Attach the server-side Supabase client to context.locals
  context.locals.supabase = supabase;

  // Call the next middleware or the page/API handler
  return next();
});



================================================
File: src/pages/create.astro
================================================
---
import MainLayout from "@/layouts/MainLayout.astro";
import SummaryForm from "@/components/views/SummaryForm";

// The auth check is handled by MainLayout
---

<!-- src/pages/create.astro -->
<MainLayout title="Nowe podsumowanie">
  {/* Render the React component in create mode */}
  <SummaryForm mode="create" client:load />
</MainLayout>



================================================
File: src/pages/index.astro
================================================
---
import Welcome from "../components/Welcome.astro";
import Layout from "../layouts/Layout.astro";
---

<Layout>
  <Welcome />
</Layout>



================================================
File: src/pages/login.astro
================================================
---
// src/pages/login.astro
// This page does NOT use MainLayout and is publicly accessible.
import LoginForm from "@/components/views/LoginForm";
// Include Toaster here as this page doesn't use MainLayout which includes it.
import { Toaster } from "@/components/ui/sonner";

// Optional: Check if already logged in and redirect.
// This check should preferably be handled by middleware or the layout itself
// for all protected pages, but can also be here for immediate redirect if login page is accessed while logged in.
import { getSession } from "auth";
const session = await getSession(Astro.request);
if (session) {
  // Use Response redirect for SSR
  return new Response(null, {
    status: 302,
    headers: {
      Location: "/summaries",
    },
  });
}
---

<!doctype html>
<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="generator" content={Astro.generator} />
    <title>Logowanie - Meeting Summarizer</title>
    {/* Include global styles here as MainLayout is not used */}
    <link rel="stylesheet" href="/styles/globals.css" />
  </head>
  <body class="flex items-center justify-center min-h-screen bg-gray-100">
    {/* Render React component with client-side hydration */}
    <LoginForm client:load />
    {/* Toaster component */}
    <Toaster />
  </body>
</html>



================================================
File: src/pages/summaries.astro
================================================
---
import MainLayout from "@/layouts/MainLayout.astro";
import SummaryList from "@/components/views/SummaryList";

// The auth check is handled by MainLayout
---

<!-- src/pages/summaries.astro -->
<MainLayout title="Moje podsumowania">
  {/* Render the React component for the list view */}
  <SummaryList client:load />
</MainLayout>



================================================
File: src/pages/api/generate-summary.ts
================================================
/* eslint-disable no-console */
// src/pages/api/generate-summary.ts -- Handler for /api/generate-summary (POST)

import type { APIRoute, APIContext } from "astro";
import { z } from "zod"; // Import the Zod library

// Import types for request and response DTOs
import type { GenerateSummaryCommand, GenerateSummaryResponseDto } from "../../types"; // Adjust the path if necessary

// Import SupabaseClient type (client is available in context.locals but auth check is skipped per MVP rule)
import type { SupabaseClient } from "../../db/supabase.client"; // Adjust the path if necessary

// --- Zod Schema for Generate Summary Request Body ---
const generateSummaryRequestSchema: z.ZodSchema<GenerateSummaryCommand> = z.object({
  transcription: z.string().min(1, { message: "Transcription cannot be empty." }), // Required non-empty string
});

// Define the inferred type from the schema for validated data
type ValidatedGenerateSummaryRequest = z.infer<typeof generateSummaryRequestSchema>;

// --- LLM Service Placeholder ---
// This function is a placeholder for calling a real LLM API
// Replace this mock logic with actual API call implementation
async function callLLMService(transcription: string): Promise<string> {
  console.log(
    "Calling placeholder LLM service with transcription (first 100 chars):",
    transcription.substring(0, 100) + "..."
  );

  // --- Replace with actual LLM API call (e.g., fetch to OpenAI, OpenRouter, Ollama) ---
  // Example using fetch (replace with your actual LLM provider details and API key)
  /*
  // Note: OPENROUTER_API_KEY is server-side only, accessed via import.meta.env in Astro API routes
  const apiKey = import.meta.env.OPENROUTER_API_KEY;

  try {
    const response = await fetch("https://api.openrouter.ai/api/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json",
        // Recommended headers for OpenRouter to identify your app
        "HTTP-Referer": 'YOUR_APP_URL_OR_IDENTIFIER', // Replace with your app's URL or a unique identifier
        "X-Title": "Meeting Summarizer MVP",
      },
      body: JSON.stringify({
        model: "openai/gpt-3.5-turbo", // Or another suitable model
        messages: [
          { role: "system", content: "JesteĹ› pomocnym asystentem podsumowujÄ…cym spotkania. StwĂłrz zwiÄ™zĹ‚e podsumowanie (do 500 znakĂłw) na podstawie transkrypcji w jÄ™zyku polskim." },
          { role: "user", content: transcription },
        ],
        max_tokens: 200, // Adjust token limit as needed to stay within 500 chars
      }),
    });

    if (!response.ok) {
      const errorBody = await response.json();
      console.error("LLM API Error:", response.status, errorBody);
      throw new Error(`LLM API returned status ${response.status}: ${errorBody.message || 'Unknown error'}`);
    }

    const data = await response.json();
    const generatedText = data.choices[0]?.message?.content || "";

    // Simple truncation just in case LLM exceeds expected length
    const maxSummaryLength = 500;
    const finalSummary = generatedText.substring(0, maxSummaryLength);

    console.log("LLM service returned summary:", finalSummary.substring(0, 100) + "...");
    return finalSummary;

  } catch (error) {
    console.error("Error communicating with LLM API:", error);
    // Log the full error details on the server
    throw new Error("Failed to communicate with summary generation service.");
  }
  */

  // --- Current Mock Logic (Remove for production) ---
  await new Promise((resolve) => setTimeout(resolve, 1500)); // Simulate delay
  if (Math.random() < 0.15) {
    // Simulate occasional error (15% chance)
    console.error("Simulating LLM error");
    throw new Error("Simulated LLM failure.");
  }
  const mockSummary = transcription.split("\n")[0]?.substring(0, 500) || "Mock summary.";
  console.log("Mock LLM returning summary:", mockSummary.substring(0, 100) + "...");
  return mockSummary;
  // --- End Mock Logic ---
}

// --- Handler endpoint POST /api/generate-summary ---
// Implements the Generate Summary endpoint.
// Authentication check is SKIPPED as per specific MVP rule.
export const POST: APIRoute = async (context) => {
  // Supabase client is available, but auth check is skipped per specific MVP rule.
  const supabase: SupabaseClient = context.locals.supabase;

  if (!supabase) {
    console.error("POST /api/generate-summary: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  // const { data: { user }, error: authError } = await supabase.auth.getUser();
  // if (authError || !user) { ... return 401 ... }
  console.log("POST /api/generate-summary: Authentication check SKIPPED as per specific MVP rule.");
  // No user ID is needed for the LLM call itself.

  let requestBody: unknown; // Use unknown for initial request body type

  try {
    // --- Parse Request Body ---
    requestBody = await context.request.json();
  } catch (error) {
    // 400 Error Handling: Invalid JSON format
    console.error("POST /api/generate-summary: Failed to parse request body as JSON:", error);
    return new Response(
      JSON.stringify({
        error: "Invalid JSON body",
      }),
      {
        status: 400,
        headers: {
          "Content-Type": "application/json",
        },
      }
    );
  }

  // Use a try...catch for errors *after* JSON parsing
  try {
    // --- Input Validation (zod) ---
    const validationResult = generateSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      // 400 Error Handling: Input validation failed (zod)
      console.error("POST /api/generate-summary: Input validation failed:", validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors, // Zod errors array
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    const validatedData: ValidatedGenerateSummaryRequest = validationResult.data;
    console.log("POST /api/generate-summary: Validation successful.");

    // --- Call LLM Service (or mock) ---
    // Authentication token is NOT passed to the LLM service call as per specific MVP rule.
    const generatedSummary = await callLLMService(validatedData.transcription);

    // --- Handle Service Response and Return 200 OK ---
    const responseData: GenerateSummaryResponseDto = {
      summary: generatedSummary,
    };

    return new Response(JSON.stringify(responseData), {
      status: 200, // 200 OK for successful generation
      headers: { "Content-Type": "application/json" },
    });
  } catch (error) {
    // --- Server Error Handling (500) ---
    // This catches errors from validation subsequent logic (like the LLM call)
    console.error("POST /api/generate-summary: Caught unexpected error after validation:", error);
    // Return a generic 500 error response
    return new Response(
      JSON.stringify({
        error: "An internal server error occurred during summary generation.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }
};

// Note: Only POST is implemented for this endpoint as per plan.
export const prerender = false; // Needed for server routes



================================================
File: src/pages/api/summaries.ts
================================================
/* eslint-disable no-console */
/* eslint-disable @typescript-eslint/no-unused-vars */ // Disabled as per previous discussion
// src/pages/api/summaries.ts -- Handlers for /api/summaries (GET, POST, PUT, DELETE)

import type { APIRoute, APIContext } from "astro";
import { z } from "zod"; // Import the Zod library

// Import your local SupabaseClient type alias AND the default user ID
// IMPORTANT: Using DEFAULT_USER_ID instead of auth.uid() for DB operations in this MVP!
import type { SupabaseClient } from "../../db/supabase.client";
import { DEFAULT_USER_ID } from "../../db/supabase.client"; // Import the default user ID

// Import Supabase specific types for better error handling and results
// FIX: Import PostgrestError for specific error checking
import type { PostgrestSingleResponse, PostgrestResponse, PostgrestError } from "@supabase/supabase-js";

// Import shared DTOs and DB internal types from central types file
import type {
  MeetingSummaryListEntryDto,
  CreateSummaryRequestDTO,
  CreateSummaryResponseDTO,
  UpdateSummaryRequestDTO,
  MeetingSummaryInsertData,
  MeetingSummaryFullRow,
  MeetingSummarySelectedColumns,
  ListSummariesServiceParams,
  MeetingSummaryDetailsDto, // Ensure this is imported if used in service method return types or mapping
} from "../../types"; // Adjust the path if necessary

// Import date-fns parseISO for robust date parsing and date helpers
import { parseISO, startOfDay, endOfDay } from "date-fns";

// FIX: Define a custom error type that includes status
interface ApiErrorWithStatus extends Error {
  status?: number;
}

// --- Zod Schema for List Summaries Query Parameters (for GET /api/summaries) ---
const listSummariesParamsSchema = z.object({
  sort_by: z.enum(["created_at", "updated_at"]).optional().default("created_at"),
  sort_order: z.enum(["asc", "desc"]).optional().default("desc"),
  // Accept date strings (YYYY-MM-DD from input type="date") or full ISO 8601
  from_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'from_dt'.",
    }),
  to_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'to_dt'.",
    }),
});

// --- Zod Schema for Create Summary Request Body (for POST /api/summaries) ---
const createSummaryRequestSchema = z.object({
  file_name: z.string().nullable().optional(), // nullable() allows null, optional() allows undefined
  transcription: z.string().min(1, { message: "Transcription cannot be empty." }),
  summary: z
    .string()
    .min(1, { message: "Summary cannot be empty." })
    .max(500, { message: "Summary cannot exceed 500 characters." }),
  llm_generated: z.boolean({ required_error: "Field 'llm_generated' is required and must be a boolean." }),
  notes: z
    .string()
    .nullable()
    .optional()
    .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
});

// --- Zod Schema for Update Summary Request Body (for PUT /api/summaries/{id}) ---
// Allows partial updates
const updateSummaryRequestSchema = z
  .object({
    file_name: z.string().nullable().optional(),
    transcription: z.string().min(1, { message: "Transcription cannot be empty." }).optional(),
    summary: z
      .string()
      .min(1, { message: "Summary cannot be empty." })
      .max(500, { message: "Summary cannot exceed 500 characters." })
      .optional(),
    llm_generated: z.boolean().optional(),
    notes: z
      .string()
      .nullable()
      .optional()
      .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
  })
  .partial(); // Make all fields optional at the top level

// --- SummaryService Class (Central logic for DB interaction) ---
// IMPORTANT: In this MVP version, this service uses DEFAULT_USER_ID for DB operations
// instead of relying on auth.uid() via RLS. This is INSECURE and for MVP ONLY.
class SummaryService {
  constructor(private supabase: SupabaseClient) {}

  // Method to list summaries for the DEFAULT_USER_ID
  async listDefaultUserSummaries(params: ListSummariesServiceParams): Promise<MeetingSummaryListEntryDto[]> {
    // userId parameter is included for type compatibility but ignored in this MVP implementation
    // as we are hardcoding DEFAULT_USER_ID.
    const { dateRange, sortParams } = params;
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID (MVP ONLY).`
    );

    try {
      // Select specific columns for the list view
      let query = this.supabase.from("meeting_summaries").select("id, title, file_name, created_at, modified_at");

      // Explicitly filter by DEFAULT_USER_ID, overriding standard RLS based on auth.uid()
      query = query.eq("user_id", DEFAULT_USER_ID);

      if (dateRange.from) {
        // Use >= for 'from' date (start of the day)
        query = query.gte("created_at", startOfDay(dateRange.from).toISOString());
      }
      if (dateRange.to) {
        // Use <= for 'to' date (end of the day)
        query = query.lte("created_at", endOfDay(dateRange.to).toISOString());
      }

      // Map API sort_by terms to DB column names
      // FIX: Correct the comparison from "updated_at" to "modified_at" as used in state/params type
      const dbSortBy = sortParams.by === "updated_at" ? "modified_at" : "created_at";

      // Apply sorting
      query = query.order(dbSortBy, { ascending: sortParams.order === "asc" });

      // Execute the query
      const result: PostgrestResponse<MeetingSummarySelectedColumns> = await query;
      const { data, error } = result;

      if (error) {
        console.error("Database error fetching summaries for DEFAULT user", DEFAULT_USER_ID, ":", error);
        // Even with DEFAULT_USER_ID, RLS might still be active on the table!
        // If RLS is active and configured to check auth.uid(), this query might fail with 42501
        // because auth.uid() will be null or different from DEFAULT_USER_ID.
        // For this MVP phase using DEFAULT_USER_ID, you might need RLS on meeting_summaries
        // temporarily disabled during local testing, or modified to allow SELECT if user_id = DEFAULT_USER_ID
        // or auth.uid() is null/different. This is a conflict in MVP rules.
        // Assuming for this MVP, RLS is permissive enough for DEFAULT_USER_ID queries *or* temporarily disabled.
        // FIX: Use type guard for error code
        if ((error as unknown as PostgrestError).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          // Re-throw as 500, hiding specific RLS error
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summaries from database.");
      }

      if (!data) {
        console.warn("GET /api/summaries (DEFAULT_USER): Select query returned no data and no error.");
        return []; // Return empty array if no data
      }

      // Map DB rows to frontend DTOs
      const summariesDto: MeetingSummaryListEntryDto[] = data.map((row) => ({
        id: row.id,
        title: row.title,
        file_name: row.file_name,
        created_at: row.created_at,
        updated_at: row.modified_at, // Map DB modified_at to API updated_at
      }));

      return summariesDto;
    } catch (error: unknown) {
      // FIX: Changed type to unknown
      console.error("Error in SummaryService.listDefaultUserSummaries:", error);
      // Pass status code if available, otherwise default to 500
      // FIX: Use type guard for status and message
      const message = error instanceof Error ? error.message : String(error);
      const status =
        error && typeof error === "object" && "status" in error && typeof error.status === "number"
          ? error.status
          : 500;
      const throwError = new Error(message);
      (throwError as ApiErrorWithStatus).status = status;
      throw throwError;
    }
  }

  // Method to get details of a single summary for the DEFAULT_USER_ID
  // FIX: Correct return type to MeetingSummaryFullRow | null as returned by DB query
  async getDefaultUserSummaryDetails(id: string): Promise<MeetingSummaryFullRow | null> {
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID for details (MVP ONLY).`
    );
    try {
      // Select ALL columns (including user_id needed for mapping to FullRow)
      // FIX: select("*") or list all columns for FullRow type
      const query = this.supabase
        .from("meeting_summaries")
        .select("*") // Select all columns to match MeetingSummaryFullRow
        .eq("id", id)
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Use single() for one expected row

      const { data, error } = await query;

      if (error && error.code === "PGRST116") {
        // Supabase specific error code for "no rows found"
        console.warn(`Summary not found for ID ${id} or not owned by DEFAULT user ${DEFAULT_USER_ID}.`);
        return null; // Return null for 404 case
      } else if (error) {
        console.error(
          `Database error fetching summary details for ID ${id} and DEFAULT user ${DEFAULT_USER_ID}:`,
          error
        );
        // FIX: Use type guard for error code
        if ((error as unknown as PostgrestError).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summary details from database.");
      }

      // Data will be of type MeetingSummaryFullRow | null
      return data; // Return the raw data
    } catch (error: unknown) {
      // FIX: Changed type to unknown
      console.error(`Error in SummaryService.getDefaultUserDetails for ID ${id}:`, error);
      // Pass status code if available, otherwise default to 500
      // FIX: Use type guard for status and message
      const message = error instanceof Error ? error.message : String(error);
      const status =
        error && typeof error === "object" && "status" in error && typeof error.status === "number"
          ? error.status
          : 500;
      const throwError = new Error(message);
      (throwError as ApiErrorWithStatus).status = status;
      throw throwError; // Re-throw to be caught by API handler
    }
  }

  // Method to create a new summary for the DEFAULT_USER_ID
  async createDefaultUserSummary(data: CreateSummaryRequestDTO): Promise<MeetingSummaryFullRow> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for creation (MVP ONLY).`);
    // Prepare data for insertion, explicitly setting user_id to DEFAULT_USER_ID
    const dataToInsert: MeetingSummaryInsertData = {
      user_id: DEFAULT_USER_ID, // Assign to DEFAULT user
      file_name: data.file_name,
      transcription: data.transcription,
      summary: data.summary,
      llm_generated: data.llm_generated,
      notes: data.notes, // notes can be string or null from validation
      title:
        data.file_name && data.file_name.trim().length > 0
          ? data.file_name.trim()
          : data.transcription.trim().substring(0, 50) + (data.transcription.trim().length > 50 ? "..." : ""), // Generate title
    };

    console.log("Attempting to insert data into DB for DEFAULT user:", dataToInsert);
    try {
      // Execute the insert query
      // If RLS insert policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .insert([dataToInsert]) // Insert the prepared data
        .select() // Select the inserted row
        .single(); // Expect a single row

      if (result.error) {
        console.error("Database insertion failed for DEFAULT user:", result.error);
        // FIX: Use type guard for error code
        if ((result.error as unknown as PostgrestError).code === "42501") {
          console.error("Potential RLS conflict: Insert for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows insert for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to save summary to database.");
      }

      if (!result.data) {
        console.error("SummaryService.createDefaultUserSummary: Insert returned no error but no data.");
        throw new Error("Database insertion failed unexpectedly.");
      }

      console.log("Database insertion successful for DEFAULT user. New summary ID:", result.data.id);
      return result.data;
    } catch (error: unknown) {
      // FIX: Changed type to unknown
      console.error("Error in SummaryService.createDefaultUserSummary:", error);
      // Pass status code if available, otherwise default to 500
      // FIX: Use type guard for status and message
      const message = error instanceof Error ? error.message : String(error);
      const status =
        error && typeof error === "object" && "status" in error && typeof error.status === "number"
          ? error.status
          : 500;
      const throwError = new Error(message);
      (throwError as ApiErrorWithStatus).status = status;
      throw throwError;
    }
  }

  // Method to update an existing summary for the DEFAULT_USER_ID
  // FIX: Correct return type to MeetingSummaryFullRow as returned by DB query
  async updateDefaultUserSummary(id: string, data: UpdateSummaryRequestDTO): Promise<MeetingSummaryFullRow | null> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for update (MVP ONLY).`);
    console.log(`Attempting to update summary ${id} for DEFAULT user with data:`, data);
    try {
      // Execute the update query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS update policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .update(data) // Update with the provided data
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .select() // Select the updated row
        .single(); // Expect a single row

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows updated"
        console.warn(`Update attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        // Return null or throw specific error for handler to return 404
        // FIX: Use a proper error type with status
        const notFoundError: ApiErrorWithStatus = new Error(`Summary with ID ${id} not found or access denied.`);
        notFoundError.status = 404; // Tag error for handler
        throw notFoundError; // Throw the error for the handler to catch and return 404
      } else if (result.error) {
        console.error(`Database update failed for ID ${id} and DEFAULT user:`, result.error);
        // FIX: Use type guard for error code
        if ((result.error as unknown as PostgrestError).code === "42501") {
          console.error("Potential RLS conflict: Update for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows update for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to update summary in database.");
      }

      // Data will be of type MeetingSummaryFullRow | null. If no error, data should exist due to single().
      if (!result.data) {
        console.error(`SummaryService.updateDefaultUserSummary: Update returned no error but no data for ID ${id}.`);
        throw new Error("Database update failed unexpectedly.");
      }

      console.log(`Database update successful for ID ${id} and DEFAULT user.`);
      return result.data; // Return the updated data
    } catch (error: unknown) {
      // FIX: Changed type to unknown
      console.error(`Error in SummaryService.updateDefaultUserSummary for ID ${id}:`, error);
      // Pass status code if available, otherwise default to 500
      // FIX: Use type guard for status and message
      const message = error instanceof Error ? error.message : String(error);
      const status =
        error && typeof error === "object" && "status" in error && typeof error.status === "number"
          ? error.status
          : 500;
      const throwError = new Error(message);
      (throwError as ApiErrorWithStatus).status = status; // Preserve status if available
      throw throwError; // Re-throw to be caught by API handler
    }
  }

  // Method to delete an existing summary for the DEFAULT_USER_ID
  async deleteDefaultUserSummary(id: string): Promise<void> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for delete (MVP ONLY).`);
    console.log(`Attempting to delete summary ${id} for DEFAULT user ${DEFAULT_USER_ID}`);
    try {
      // Execute the delete query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS delete policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<null> = await this.supabase
        .from("meeting_summaries")
        .delete() // Perform deletion
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Expect a single row deleted or none (returns null on success)

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows found" for delete
        console.warn(`Delete attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        // FIX: Use a proper error type with status
        const notFoundError: ApiErrorWithStatus = new Error(`Summary with ID ${id} not found or access denied.`);
        notFoundError.status = 404; // Tag error for handler
        throw notFoundError; // Throw the error for the handler to catch and return 404
      } else if (result.error) {
        console.error(`Database delete failed for ID ${id} and DEFAULT user:`, result.error);
        // FIX: Use type guard for error code
        if ((result.error as unknown as PostgrestError).code === "42501") {
          console.error("Potential RLS conflict: Delete for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows delete for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to delete summary from database.");
      }

      // Success! result.data will be null for delete single().
      console.log(`Database delete successful for ID ${id} and DEFAULT user.`);
      return; // Return void on success
    } catch (error: unknown) {
      // FIX: Changed type to unknown
      console.error(`Error in SummaryService.deleteDefaultUserSummary for ID ${id}:`, error);
      // Pass status code if available, otherwise default to 500
      // FIX: Use type guard for status and message
      const message = error instanceof Error ? error.message : String(error);
      const status =
        error && typeof error === "object" && "status" in error && typeof error.status === "number"
          ? error.status
          : 500;
      const throwError = new Error(message);
      (throwError as ApiErrorWithStatus).status = status; // Preserve status if available
      throw throwError; // Re-throw to be caught by API handler
    }
  }
}

// --- Handler endpoint GET /api/summaries ---
// Implements the List Summaries endpoint.
// Authentication check is SKIPPED. Data filtered by DEFAULT_USER_ID.
export const GET: APIRoute = async ({ url, locals }) => {
  const supabase = locals.supabase as SupabaseClient;

  // --- Get Supabase client from context.locals ---
  if (!supabase) {
    console.error("GET /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "GET /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data filtered by DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used

  // --- Use Zod for parameter validation (GET) ---
  const queryParams = Object.fromEntries(url.searchParams.entries());
  const validationResult = listSummariesParamsSchema.safeParse(queryParams);

  if (!validationResult.success) {
    console.error("GET /api/summaries: Query parameter validation failed:", validationResult.error);
    return new Response(
      JSON.stringify({
        message: "Invalid query parameters",
        errors: validationResult.error.format(),
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  const validatedParams = validationResult.data;

  // --- Determine Date Range ---
  let fromDate: Date | undefined;
  let toDate: Date | undefined;

  if (validatedParams.from_dt === undefined && validatedParams.to_dt === undefined) {
    // Default to last 7 days
    const now = new Date();
    toDate = endOfDay(now); // End of today
    fromDate = startOfDay(new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)); // Start of 7 days ago
    console.log(`DEBUG: Using default 7-day filter: from ${fromDate.toISOString()} to ${toDate.toISOString()}`);
  } else {
    if (validatedParams.from_dt !== undefined) {
      // Parse the date string provided
      fromDate = parseISO(validatedParams.from_dt);
      if (isNaN(fromDate.getTime())) fromDate = undefined; // Handle potential parse failure after refine
    }
    if (validatedParams.to_dt !== undefined) {
      // Parse the date string provided
      toDate = parseISO(validatedParams.to_dt);
      if (isNaN(toDate.getTime())) toDate = undefined; // Handle potential parse failure after refine
    }
    console.log(
      `DEBUG: Using provided date filters: from ${fromDate?.toISOString() || "none"} to ${toDate?.toISOString() || "none"}`
    );
  }

  // Map API sort_by terms to DB column names for the Service layer
  const dbSortBy: ListSummariesServiceParams["sortParams"]["by"] =
    validatedParams.sort_by === "updated_at" ? "modified_at" : "created_at";
  const sortOrder: ListSummariesServiceParams["sortParams"]["order"] = validatedParams.sort_order;

  try {
    const summaryService = new SummaryService(supabase);

    const serviceParams: ListSummariesServiceParams = {
      userId: DEFAULT_USER_ID, // Pass DEFAULT user ID to service
      dateRange: { from: fromDate, to: toDate },
      sortParams: { by: dbSortBy, order: sortOrder },
    };

    // Use the specific service method for the default user
    const summariesDto: MeetingSummaryListEntryDto[] = await summaryService.listDefaultUserSummaries(serviceParams);

    return new Response(JSON.stringify(summariesDto), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });
  } catch (error: unknown) {
    // FIX: Changed type to unknown
    // FIX: Use type guards for status and message
    const message = error instanceof Error ? error.message : String(error);
    const status =
      error && typeof error === "object" && "status" in error && typeof error.status === "number" ? error.status : 500;

    console.error("Caught error in GET /api/summaries handler (DEFAULT_USER):", error);

    if (status === 404 || status === 403) {
      return new Response(JSON.stringify({ message: message || "Access Denied/Not Found" }), {
        status: status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ message: "An internal server error occurred" }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint POST /api/summaries ---
// Implements the Create New Summary endpoint.
// Authentication check is SKIPPED. Data assigned to DEFAULT_USER_ID.
export const POST: APIRoute = async ({ request, locals }) => {
  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("POST /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "POST /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data assigned to DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;

  try {
    requestBody = await request.json();
  } catch (error) {
    console.error("POST /api/summaries: Failed to parse request body as JSON:", error);
    return new Response(
      JSON.stringify({
        error: "Invalid JSON body",
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  try {
    const validationResult = createSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error("POST /api/summaries: Input validation failed:", validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        {
          status: 400,
          headers: { "Content-Type": "application/json" },
        }
      );
    }

    const validatedData = validationResult.data;

    // --- Call Service to insert data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass validated data to service. Service will use DEFAULT_USER_ID internally.
    const newSummaryRecord: MeetingSummaryFullRow = await summaryService.createDefaultUserSummary(validatedData);

    console.log(
      "POST /api/summaries: Successfully created new summary record with ID:",
      newSummaryRecord.id,
      "for DEFAULT user."
    );

    // Map DB row to frontend DTO
    const responseData: CreateSummaryResponseDTO = {
      id: newSummaryRecord.id,
      user_id: newSummaryRecord.user_id,
      file_name: newSummaryRecord.file_name,
      created_at: newSummaryRecord.created_at,
      updated_at: newSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: newSummaryRecord.transcription,
      summary: newSummaryRecord.summary,
      llm_generated: newSummaryRecord.llm_generated,
      notes: newSummaryRecord.notes,
      title: newSummaryRecord.title,
    };

    return new Response(JSON.stringify(responseData), {
      status: 201, // 201 Created
      headers: {
        "Content-Type": "application/json",
        Location: `/api/summaries/${responseData.id}`, // HATEOAS principle
      },
    });
  } catch (error: unknown) {
    // FIX: Changed type to unknown
    // FIX: Use type guards for status and message
    const message = error instanceof Error ? error.message : String(error);
    const status =
      error && typeof error === "object" && "status" in error && typeof error.status === "number" ? error.status : 500;

    console.error("Caught error in POST /api/summaries handler (DEFAULT_USER):", error);

    if (status === 404 || status === 403) {
      return new Response(JSON.stringify({ message: message || "Access Denied/Not Found" }), {
        status: status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ error: "An internal server error occurred while saving the summary." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint PUT /api/summaries/{id} ---
// Implements the Update Existing Summary endpoint.
// Authentication check is SKIPPED. Updates summary for DEFAULT_USER_ID.
export const PUT: APIRoute = async ({ params, request, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("PUT /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("PUT /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `PUT /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Updates summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;
  try {
    // --- Parse Request Body ---
    requestBody = await request.json();
  } catch (error) {
    console.error(`PUT /api/summaries/${summaryId}: Failed to parse request body as JSON:`, error);
    return new Response(JSON.stringify({ error: "Invalid JSON body" }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  try {
    // --- Input Validation (zod) ---
    const validationResult = updateSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error(`PUT /api/summaries/${summaryId}: Input validation failed:`, validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }

    const validatedData: UpdateSummaryRequestDTO = validationResult.data;

    // Ensure there's at least one field being updated
    if (Object.keys(validatedData).length === 0) {
      console.warn(`PUT /api/summaries/${summaryId}: Request body is empty, no fields to update.`);
      return new Response(JSON.stringify({ error: "Request body must contain fields to update." }), {
        status: 400,
        headers: { "Content-Type": "application/json" },
      });
    }

    // --- Call Service to update data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass updated data and summaryId to service. Service will use DEFAULT_USER_ID internally.
    // FIX: Expect MeetingSummaryFullRow or null return type from service
    const updatedSummaryRecord: MeetingSummaryFullRow | null = await summaryService.updateDefaultUserSummary(
      summaryId,
      validatedData
    );

    // FIX: Handle null return (404 Not Found)
    if (!updatedSummaryRecord) {
      console.warn(`PUT /api/summaries/${summaryId}: Service returned null, likely 404 Not Found.`);
      return new Response(JSON.stringify({ message: `Summary with ID ${summaryId} not found or access denied.` }), {
        status: 404,
        headers: { "Content-Type": "application/json" },
      });
    }

    console.log(`PUT /api/summaries/${summaryId}: Successfully updated summary record for DEFAULT user.`);

    // Map DB row to frontend DTO (MeetingSummaryDetailsDto for consistency with GET details)
    const responseData: MeetingSummaryDetailsDto = {
      id: updatedSummaryRecord.id,
      title: updatedSummaryRecord.title, // Include title as it's in the DB row
      file_name: updatedSummaryRecord.file_name,
      created_at: updatedSummaryRecord.created_at,
      updated_at: updatedSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: updatedSummaryRecord.transcription,
      summary: updatedSummaryRecord.summary,
      llm_generated: updatedSummaryRecord.llm_generated,
      notes: updatedSummaryRecord.notes,
      // user_id is omitted from this DTO
    };

    return new Response(JSON.stringify(responseData), {
      status: 200, // 200 OK
      headers: { "Content-Type": "application/json" },
    });
  } catch (error: unknown) {
    // FIX: Changed type to unknown
    // FIX: Use type guards for status and message
    const message = error instanceof Error ? error.message : String(error);
    const status =
      error && typeof error === "object" && "status" in error && typeof error.status === "number" ? error.status : 500;

    console.error(`PUT /api/summaries/${summaryId}: Caught error after validation (DEFAULT_USER):`, error);
    // Check if it's a known error type from service
    if (status === 404) {
      // Service indicates Not Found/Not Owned - redundant if null check above works
      return new Response(
        JSON.stringify({
          message: message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    // FIX: Use type guard for error code
    if (
      (error &&
        typeof error === "object" &&
        "code" in error &&
        typeof error.code === "string" &&
        error.code === "42501") ||
      status === 403
    ) {
      // Service indicates Permission Denied
      return new Response(
        JSON.stringify({
          message:
            message || `Permission denied for summary ID ${summaryId}. Ensure RLS allows access for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while updating summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

// --- Handler endpoint DELETE /api/summaries/{id} ---
// Implements the Delete Summary endpoint.
// Authentication check is SKIPPED. Deletes summary for DEFAULT_USER_ID.
export const DELETE: APIRoute = async ({ params, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("DELETE /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("DELETE /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `DELETE /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Deletes summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  try {
    // --- Call Service to delete data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass summaryId to service. Service will use DEFAULT_USER_ID internally.
    await summaryService.deleteDefaultUserSummary(summaryId);

    console.log(`DELETE /api/summaries/${summaryId}: Successfully deleted summary record for DEFAULT user.`);

    return new Response(null, {
      // 204 No Content
      status: 204,
      // No body for 204 response
    });
  } catch (error: unknown) {
    // FIX: Changed type to unknown
    // FIX: Use type guards for status and message
    const message = error instanceof Error ? error.message : String(error);
    const status =
      error && typeof error === "object" && "status" in error && typeof error.status === "number" ? error.status : 500;

    console.error(`DELETE /api/summaries/${summaryId}: Caught error (DEFAULT_USER):`, error);

    if (status === 404) {
      return new Response(
        JSON.stringify({
          message: message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    // FIX: Use type guard for error code
    if (
      (error &&
        typeof error === "object" &&
        "code" in error &&
        typeof error.code === "string" &&
        error.code === "42501") ||
      status === 403
    ) {
      // This might happen if RLS is still partially active
      return new Response(
        JSON.stringify({
          message:
            message || `Permission denied for summary ID ${summaryId}. Ensure RLS allows delete for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while deleting summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

export const prerender = false; // Needed for server routes



================================================
File: src/pages/edit/[id].astro
================================================
---
import MainLayout from "@/layouts/MainLayout.astro";
import SummaryForm from "@/components/views/SummaryForm";

const { id } = Astro.params;

if (!id) {
  // Handle case where ID is missing from the URL (shouldn't happen with [id].astro route but good practice)
  // Or if ID needs format validation.
  // For simplicity, redirect to summaries list or show a 404.
  return new Response(null, {
    status: 302,
    headers: {
      Location: "/summaries", // Redirect to list
    },
  });
  // Or return new Response('Not Found', { status: 404 });
}

// The auth check is handled by MainLayout
---

<!-- src/pages/edit/[id].astro -->
<MainLayout title={`Edytuj podsumowanie ${id}`}>
  {/* Pass the mode and the extracted ID to the React component */}
  <SummaryForm mode="edit" summaryId={id} client:load />
</MainLayout>



================================================
File: src/styles/global.css
================================================
@tailwind base;
@tailwind components;
@tailwind utilities;

/*
  This CSS file is generated by shadcn/ui.
  It contains CSS variables for themes and basic base styles.
  Ensure it's imported in your main layout or app entry.
*/

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 240 10% 3.9%;

    --card: 0 0% 100%;
    --card-foreground: 240 10% 3.9%;

    --popover: 0 0% 100%;
    --popover-foreground: 240 10% 3.9%;

    --primary: 240 5.9% 10%; /* Changed from 240 5.9% 10% to reflect 'neutral' base */
    --primary-foreground: 0 0% 98%; /* Changed from 0 0% 98% */

    --secondary: 240 4.8% 95.9%;
    --secondary-foreground: 240 5.9% 10%;

    --muted: 240 4.8% 95.9%;
    --muted-foreground: 240 3.8% 46.1%;

    --accent: 240 4.8% 95.9%;
    --accent-foreground: 240 5.9% 10%;

    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;

    --border: 240 5% 89.8%;
    --input: 240 5% 89.8%;
    --ring: 240 5.9% 10%;

    --radius: 0.5rem;
  }

  .dark {
    --background: 240 10% 3.9%;
    --foreground: 0 0% 98%;

    --card: 240 10% 3.9%;
    --card-foreground: 0 0% 98%;

    --popover: 240 10% 3.9%;
    --popover-foreground: 0 0% 98%;

    --primary: 0 0% 98%; /* Changed */
    --primary-foreground: 240 5.9% 10%; /* Changed */

    --secondary: 240 3.7% 15.9%;
    --secondary-foreground: 0 0% 98%;

    --muted: 240 3.7% 15.9%;
    --muted-foreground: 240 5% 64.9%;

    --accent: 240 3.7% 15.9%;
    --accent-foreground: 0 0% 98%;

    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;

    --border: 240 3.7% 15.9%;
    --input: 240 3.7% 15.9%;
    --ring: 0 0% 98%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
    min-height: 100vh; /* Ensure body takes at least full viewport height */
    display: flex;
    flex-direction: column; /* Allow body to be flex container for footer */
  }
}

/* Optional: Basic styling for main content to take available space */
main {
    flex-grow: 1;
}

/* Optional: Styling for the custom file input label to look like a button when disabled */
label[data-disabled="true"] {
    opacity: 0.5;
    pointer-events: none;
    cursor: not-allowed;
}


================================================
File: supabase/config.toml
================================================
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "meeting-summary"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 15

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

# [db.vault]
# secret_key = "env(SECRET_VALUE)"

[db.migrations]
# Specifies an ordered list of schema files that describe your database.
# Supports glob patterns relative to supabase directory: "./schemas/*.sql"
schema_paths = []

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

[auth.rate_limit]
# Number of emails that can be sent per hour. Requires auth.email.smtp to be enabled.
email_sent = 2
# Number of SMS messages that can be sent per hour. Requires auth.sms to be enabled.
sms_sent = 30
# Number of anonymous sign-ins that can be made per hour per IP address. Requires enable_anonymous_sign_ins = true.
anonymous_users = 30
# Number of sessions that can be refreshed in a 5 minute interval per IP address.
token_refresh = 150
# Number of sign up and sign-in requests that can be made in a 5 minute interval per IP address (excludes anonymous users).
sign_in_sign_ups = 30
# Number of OTP / Magic link verifications that can be made in a 5 minute interval per IP address.
token_verifications = 30

# Configure one of the supported captcha providers: `hcaptcha`, `turnstile`.
# [auth.captcha]
# enabled = true
# provider = "hcaptcha"
# secret = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

# Use Clerk as a third-party provider alongside Supabase Auth.
[auth.third_party.clerk]
enabled = false
# Obtain from https://clerk.com/setup/supabase
# domain = "example.clerk.accounts.dev"

[edge_runtime]
enabled = true
# Configure one of the supported request policies: `oneshot`, `per_worker`.
# Use `oneshot` for hot reload, or `per_worker` for load testing.
policy = "oneshot"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083
# The Deno major version to use.
deno_version = 1

# [edge_runtime.secrets]
# secret_key = "env(SECRET_VALUE)"

[analytics]
enabled = false
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"



================================================
File: supabase/.gitignore
================================================
# Supabase
.branches
.temp

# dotenvx
.env.keys
.env.local
.env.*.local



================================================
File: supabase/migrations/20250417183316_create_users.sql
================================================
-- Create the 'users' table
create table users (
    id uuid primary key references auth.users(id) on delete cascade,  -- Link to auth.users table!
    email varchar(255) unique not null,
    created_at timestamp with time zone default now()
);

comment on table users is 'table containing user information';
comment on column users.id is 'user id from supabase auth';
comment on column users.email is 'user email address';
comment on column users.created_at is 'timestamp of user creation';

-- Enable RLS on the 'users' table
alter table users enable row level security;

-- Poprawione polityki RLS (usuniÄ™to nadmiarowe 'on users')
-- SELECT policy
create policy "users_select_policy" on users
for select
using (auth.uid() = id);

comment on policy "users_select_policy" on users is 'Enable read access to users based on their own user id (authenticated users only)';

-- INSERT policy
CREATE POLICY "users_insert_policy" ON users
FOR INSERT
WITH CHECK (auth.uid() = id AND email = auth.jwt() ->> 'email');

comment on policy "users_insert_policy" on users is 'Allow users to insert their own user record on signup.';

-- UPDATE policy
CREATE POLICY "users_update_policy" ON users
FOR UPDATE
USING (auth.uid() = id)
WITH CHECK (auth.uid() = id AND email = auth.jwt() ->> 'email');

comment on policy "users_update_policy" on users is 'Allow users to update their own user record.';

-- DELETE policy
CREATE POLICY "users_delete_policy" ON users
FOR DELETE
USING (auth.uid() = id);

comment on policy "users_delete_policy" on users is 'Allow users to delete their own user record.';



================================================
File: supabase/migrations/20250417183903_create_meeting_summaries.sql
================================================
-- Header comment:
-- Purpose: Creates the 'meeting_summaries' table to store meeting transcripts, summaries and metadata.
-- Affected tables/columns:
--   - meeting_summaries (id, user_id, file_name, data_utworzenia, data_modyfikacji, transcription, summary, llm_generated, notes)
-- Special considerations:
--   - RLS policies are configured to ensure users can only access their own data.

-- Create the 'meeting_summaries' table
create table meeting_summaries (
    id uuid primary key default gen_random_uuid(),
    user_id uuid references users(id) on delete cascade not null,  -- Poprawne odwoĹ‚anie do tabeli users
    file_name varchar(255),
    created_at timestamp with time zone default now() not null,
    modified_at timestamp with time zone default now() not null,
    transcription text not null,
    summary text not null, -- Zmieniono varchar(500) na text, aby uniknÄ…Ä‡ ograniczeĹ„ dĹ‚ugoĹ›ci
    llm_generated boolean default true not null,
    notes text not null
);

comment on table meeting_summaries is 'tabela zawierajÄ…ca podsumowania spotkaĹ„';
comment on column meeting_summaries.id is 'unikalny id podsumowania spotkania';
comment on column meeting_summaries.user_id is 'id uĹĽytkownika, klucz obcy z tabeli users';
comment on column meeting_summaries.file_name is 'nazwa oryginalnego pliku transkrypcji';
comment on column meeting_summaries.created_at is 'znacznik czasu utworzenia podsumowania';
comment on column meeting_summaries.modified_at is 'znacznik czasu ostatniej modyfikacji podsumowania';
comment on column meeting_summaries.transcription is 'oryginalna transkrypcja spotkania';
comment on column meeting_summaries.summary is 'podsumowanie spotkania wygenerowane przez llm';
comment on column meeting_summaries.llm_generated is 'boolean wskazujÄ…cy, czy podsumowanie zostaĹ‚o wygenerowane przez llm';
comment on column meeting_summaries.notes is 'notatki uĹĽytkownika dla danego podsumowania';

-- Enable RLS on the 'meeting_summaries' table
alter table meeting_summaries enable row level security;

-- Create RLS policy for 'meeting_summaries' table - SELECT access for authenticated users
create policy "meeting_summaries_select_policy" on meeting_summaries
for select
to authenticated
using (auth.uid() = user_id);

comment on policy "meeting_summaries_select_policy" on meeting_summaries is 'wĹ‚Ä…cz dostÄ™p do odczytu dla uĹĽytkownikĂłw na podstawie ich wĹ‚asnego id';

-- Create RLS policy for 'meeting_summaries' table - INSERT access for authenticated users
create policy "meeting_summaries_insert_policy" on meeting_summaries
for insert
to authenticated
with check (auth.uid() = user_id);

comment on policy "meeting_summaries_insert_policy" on meeting_summaries is 'wĹ‚Ä…cz dostÄ™p do wstawiania dla uĹĽytkownikĂłw na podstawie ich wĹ‚asnego id';

-- Create RLS policy for 'meeting_summaries' table - UPDATE access for authenticated users
create policy "meeting_summaries_update_policy" on meeting_summaries
for update
to authenticated
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

comment on policy "meeting_summaries_update_policy" on meeting_summaries is 'wĹ‚Ä…cz dostÄ™p do aktualizacji dla uĹĽytkownikĂłw na podstawie ich wĹ‚asnego id';

-- Create RLS policy for 'meeting_summaries' table - DELETE access for authenticated users
create policy "meeting_summaries_delete_policy" on meeting_summaries
for delete
to authenticated
using (auth.uid() = user_id);

comment on policy "meeting_summaries_delete_policy" on meeting_summaries is 'wĹ‚Ä…cz dostÄ™p do usuwania dla uĹĽytkownikĂłw na podstawie ich wĹ‚asnego id';

-- Create indexes to optimize query performance
create index idx_meeting_summaries_user_id on meeting_summaries(user_id);
comment on index idx_meeting_summaries_user_id is 'indeks dla id uĹĽytkownika, uĹĽywany do szybkiego pobierania danych';

create index idx_meeting_summaries_created_at on meeting_summaries(created_at);
comment on index idx_meeting_summaries_created_at is 'indeks dla daty utworzenia podsumowania spotkania, uĹĽywany do szybkiego pobierania danych';

create index idx_meeting_summaries_llm_generated on meeting_summaries(llm_generated);
comment on index idx_meeting_summaries_llm_generated is 'indeks dla flagi generowania llm, uĹĽywany do szybkiego pobierania danych';

-- Triggers to automatically update 'modified_at'
CREATE OR REPLACE FUNCTION update_modified_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.modified_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_meeting_summaries_modified_at
BEFORE UPDATE ON meeting_summaries
FOR EACH ROW
EXECUTE FUNCTION update_modified_at();

comment on trigger update_meeting_summaries_modified_at on meeting_summaries is 'trigger to update modified_at timestamp on update';


================================================
File: supabase/migrations/20250417184502_fix_update_modified_at_search_path.sql
================================================
CREATE OR REPLACE FUNCTION update_modified_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.modified_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SET search_path = '';



================================================
File: supabase/migrations/20250419065725_add_meeting_summaries_indexes.sql
================================================

-- Indeks dla szybkiego wyszukiwania podsumowaĹ„ danego uĹĽytkownika
CREATE INDEX IF NOT EXISTS idx_meeting_summaries_user_id 
ON meeting_summaries(user_id);

-- Indeks dla szybkiego sortowania po dacie utworzenia (domyĹ›lne sortowanie w API)
CREATE INDEX IF NOT EXISTS idx_meeting_summaries_created_at 
ON meeting_summaries(created_at DESC);

-- Indeks dla szybkiego sortowania po dacie modyfikacji
CREATE INDEX IF NOT EXISTS idx_meeting_summaries_updated_at 
ON meeting_summaries(modified_at DESC);

-- Indeks kompozytowy dla typowego scenariusza: lista podsumowaĹ„ uĹĽytkownika posortowana po dacie
CREATE INDEX IF NOT EXISTS idx_meeting_summaries_user_id_created_at 
ON meeting_summaries(user_id, created_at DESC);



================================================
File: supabase/migrations/20250420151200_remove_notes_not_null.sql
================================================
-- Header comment:
-- Purpose: Alters the 'meeting_summaries' table to allow NULL values for the 'notes' column.
-- Affected tables/columns:
--   - meeting_summaries (notes)
-- Special considerations:
--   - This change allows the 'notes' field to be optional when inserting or updating records.
--   - Does not affect existing rows unless they contain NULLs (which should not be the case due to prior NOT NULL constraint).

-- Alter the 'meeting_summaries' table to drop the NOT NULL constraint on the 'notes' column
ALTER TABLE public.meeting_summaries ALTER COLUMN notes DROP NOT NULL;

comment on column public.meeting_summaries.notes is 'Notatki uĹĽytkownika dla danego podsumowania (opcjonalne)';

-- Note: No RLS policies need to be changed for this modification as RLS is based on user access, not column constraints.
-- Note: Indexes are already defined for other columns and are not affected by this change.
-- Note: Triggers (like update_modified_at) are not affected by this change.


================================================
File: supabase/migrations/20250420184550_title_column_added.sql
================================================
-- Header comment:
-- Purpose: Adds the 'title' column to the 'meeting_summaries' table.
-- Affected tables/columns:
--   - meeting_summaries (title)
-- Special considerations:
--   - The title is derived from the file_name initially, but can be edited.
--   - We add it as nullable first, populate from file_name, then set NOT NULL.

-- Add the 'title' column as nullable TEXT
ALTER TABLE public.meeting_summaries
ADD COLUMN title TEXT NULL;

comment on column public.meeting_summaries.title is 'User-editable title for the meeting summary, defaults from file name.';

-- Populate the new 'title' column for existing rows
-- Extract base name from file_name (removing path and extension)
-- Use COALESCE to handle null file_name, defaulting to a placeholder or empty string
UPDATE public.meeting_summaries
SET title = COALESCE(
    -- Use regexp_replace to remove path and extension
    regexp_replace(file_name, '^(.*/)?([^/.]+)(\..*)?$', '\2'),
    -- Fallback if file_name is NULL
    'Meeting Summary' -- Default title if file_name is NULL
);

-- Ensure the title is not null after populating existing rows
ALTER TABLE public.meeting_summaries
ALTER COLUMN title SET NOT NULL;

-- (Optional but recommended) Add an index if sorting/filtering by title is expected frequently
-- CREATE INDEX IF NOT EXISTS idx_meeting_summaries_title ON meeting_summaries(title);

-- Note: No RLS policies need to be changed for this modification as RLS is based on user access, not column constraints.
-- Note: Other indexes and triggers (like update_modified_at) are not affected by this change.


================================================
File: supabase/.branches/_current_branch
================================================
main


================================================
File: .ai/additional-rules.md
================================================
- Use supabase from context. locals in Astro routes instead of importing supabaseClient
directly
- Use SupabaseClient type from `src/db/supabase.client.ts', not from `@supabase/
supabase-js
- Don't use any auth at the moment - use the user defined in the supabase.client.ts - DEFAULT_USER_ID


================================================
File: .ai/api-plan.md
================================================
# REST API Plan

## 1. Resources

*   **`meeting_summaries`**: Represents a single meeting transcription and its associated summary, notes, and metadata. Corresponds to the `meeting_summaries` table in the database.
*   **`users`**: Represents a user account. Managed by Supabase Auth. API interactions for user management (signup, login, etc.) are handled directly by the Supabase client library or SDK and are not included in this custom API plan. Access to `meeting_summaries` resources requires user authentication.

## 2. Endpoints

### 2.1. `meeting_summaries` Resource

#### List Summaries

*   **HTTP Method:** `GET`
*   **URL Path:** `/api/summaries`
*   **Description:** Retrieves a list of meeting summaries belonging to the authenticated user, with optional filtering by creation date and sorting. By default, if no date parameters are provided, it retrieves summaries from the last 7 days.
*   **Query Parameters:**
    *   `sort_by`: string (default: `created_at`) - The column to sort by (`created_at` or `updated_at`).
    *   `sort_order`: string (default: `desc`) - The sort direction (`asc` or `desc`). Defaults satisfy the PRD requirement for sorting by creation date (newest first).
    *   `from_dt`: string (optional) - Filter summaries created on or after this timestamp. Expected format compatible with `TIMESTAMP WITH TIME ZONE` (e.g., ISO 8601).
    *   `to_dt`: string (optional) - Filter summaries created on or before this timestamp. Expected format compatible with `TIMESTAMP WITH TIME ZONE` (e.g., ISO 8601).
    *   **Note:** If *neither* `from_dt` nor `to_dt` is provided, the API will default to filtering for records where `created_at` is within the last 7 days from the current server time (`created_at >= NOW() - INTERVAL '7 days' AND created_at <= NOW()`). If only one is provided, it will filter based on that one. If both are provided, it will filter based on the provided range.
*   **Request Payload:** None
*   **Response Payload:**
    ```json
    [
      {
        "id": "uuid",
        "file_name": "string | null",
        "created_at": "timestamp with time zone",
        "updated_at": "timestamp with time zone"
        // Summary content is NOT included in the list view response for brevity and performance, as per list table requirements in PRD
      },
      // ... more summary objects
    ]
    ```
*   **Success Responses:**
    *   `200 OK`: Successfully retrieved the list of summaries.
*   **Error Responses:**
    *   `400 Bad Request`: Invalid query parameters (e.g., invalid date format).
    *   `401 Unauthorized`: Authentication required.
    *   `500 Internal Server Error`: An error occurred on the server.

#### Get Summary Details

*   **HTTP Method:** `GET`
*   **URL Path:** `/api/summaries/{id}`
*   **Description:** Retrieves the full details of a specific meeting summary by its ID. Access is restricted to the owner of the summary via RLS. This endpoint includes the full transcription and summary to support the edit functionality required by the PRD.
*   **Query Parameters:** None
*   **Request Payload:** None
*   **Response Payload:**
    ```json
    {
      "id": "uuid",
      "file_name": "string | null",
      "created_at": "timestamp with time zone",
      "updated_at": "timestamp with time zone",
      "transcription": "string",
      "summary": "string",
      "llm_generated": "boolean",
      "notes": "string"
      // user_id is excluded from the response as RLS ensures the user owns the data.
    }
    ```
*   **Success Responses:**
    *   `200 OK`: Successfully retrieved summary details.
*   **Error Responses:**
    *   `401 Unauthorized`: Authentication required.
    *   `403 Forbidden`: User is not the owner of the summary (enforced by RLS).
    *   `404 Not Found`: Summary with the provided ID does not exist for this user.
    *   `500 Internal Server Error`: An error occurred on the server.

#### Create New Summary

*   **HTTP Method:** `POST`
*   **URL Path:** `/api/summaries`
*   **Description:** Creates a new meeting summary record in the database for the authenticated user.
*   **Query Parameters:** None
*   **Request Payload:**
    ```json
    {
      "file_name": "string | null", // Optional, name of the uploaded file
      "transcription": "string",     // Required
      "summary": "string",           // Required, max 500 characters
      "llm_generated": "boolean",    // Required - indicates if the submitted summary came from LLM generation (true) or manual input (false)
      "notes": "string"              // Optional, can be empty string
      // API sets user_id based on authenticated user, created_at, updated_at
    }
    ```
*   **Response Payload:**
    ```json
    {
      "id": "uuid", // ID of the newly created summary
      "user_id": "uuid", // Included for context upon creation
      "file_name": "string | null",
      "created_at": "timestamp with time zone",
      "updated_at": "timestamp with time zone",
      "transcription": "string",
      "summary": "string",
      "llm_generated": "boolean",
      "notes": "string"
    }
    ```
*   **Success Responses:**
    *   `201 Created`: Summary successfully created.
*   **Error Responses:**
    *   `400 Bad Request`: Invalid input data (e.g., missing required fields, summary exceeds 500 characters).
    *   `401 Unauthorized`: Authentication required.
    *   `500 Internal Server Error`: An error occurred on the server.

#### Update Existing Summary

*   **HTTP Method:** `PUT`
*   **URL Path:** `/api/summaries/{id}`
*   **Description:** Updates an existing meeting summary record. Access is restricted to the owner of the summary via RLS.
*   **Query Parameters:** None
*   **Request Payload:**
    ```json
    {
      "file_name": "string | null", // Can update file name
      "transcription": "string",     // Can update transcription
      "summary": "string",           // Can update summary, max 500 characters
      "llm_generated": "boolean",    // Required - indicates if the submitted summary is currently LLM generated (true) or manually edited (false)
      "notes": "string"              // Can update notes
      // API updates updated_at. user_id and created_at are immutable.
    }
    ```
*   **Response Payload:**
    ```json
    {
      "id": "uuid", // ID of the updated summary
      "user_id": "uuid", // Included for context
      "file_name": "string | null",
      "created_at": "timestamp with time zone",
      "updated_at": "timestamp with time zone",
      "transcription": "string",
      "summary": "string",
      "llm_generated": "boolean",
      "notes": "string"
    }
    ```
*   **Success Responses:**
    *   `200 OK`: Summary successfully updated.
*   **Error Responses:**
    *   `400 Bad Request`: Invalid input data (e.g., missing required fields, summary exceeds 500 characters).
    *   `401 Unauthorized`: Authentication required.
    *   `403 Forbidden`: User is not the owner of the summary (enforced by RLS).
    *   `404 Not Found`: Summary with the provided ID does not exist for this user.
    *   `500 Internal Server Error`: An error occurred on the server.

#### Delete Summary

*   **HTTP Method:** `DELETE`
*   **URL Path:** `/api/summaries/{id}`
*   **Description:** Deletes an existing meeting summary record. Access is restricted to the owner of the summary via RLS.
*   **Query Parameters:** None
*   **Request Payload:** None
*   **Response Payload:** None
*   **Success Responses:**
    *   `204 No Content`: Summary successfully deleted.
*   **Error Responses:**
    *   `401 Unauthorized`: Authentication required.
    *   `403 Forbidden`: User is not the owner of the summary (enforced by RLS).
    *   `404 Not Found`: Summary with the provided ID does not exist for this user.
    *   `500 Internal Server Error`: An error occurred on the server.

### 2.2. LLM Generation Action

#### Generate Summary

*   **HTTP Method:** `POST`
*   **URL Path:** `/api/generate-summary`
*   **Description:** Triggers the LLM to generate a summary based on the provided transcription text. This endpoint does *not* save data to the database; it returns the generated summary to the client for review and potential editing before saving. Authentication is required.
*   **Query Parameters:** None
*   **Request Payload:**
    ```json
    {
      "transcription": "string" // The transcription text to summarize
    }
    ```
*   **Response Payload:**
    ```json
    {
      "summary": "string" // The summary text generated by the LLM (guaranteed to be <= 500 characters after processing)
    }
    ```
*   **Success Responses:**
    *   `200 OK`: Successfully generated a summary.
*   **Error Responses:**
    *   `400 Bad Request`: Missing or empty transcription in the request.
    *   `401 Unauthorized`: Authentication required.
    *   `500 Internal Server Error`: An error occurred during LLM communication or processing. The error message should be generic as per PRD, with details logged server-side.

## 3. Authentication and Authorization

*   **Authentication Mechanism:** Supabase Auth (JWT-based). Users authenticate via the Supabase client SDK, obtaining a JWT. This token is sent in the `Authorization: Bearer <token>` header for all API requests to protected endpoints (`/api/*`).
*   **Authorization Mechanism:** PostgreSQL Row Level Security (RLS), managed via Supabase. The RLS policies defined in the database schema (e.g., `user_id = auth.uid()` for SELECT, INSERT, UPDATE, DELETE on `meeting_summaries`) ensure that users can only access and modify their own records. Supabase automatically sets the `auth.uid()` function result based on the authenticated user's JWT.

## 4. Validation and Business Logic

*   **Input Validation (on `POST /api/summaries` and `PUT /api/summaries/{id}`):**
    *   `transcription`: Required, must be a non-empty string.
    *   `summary`: Required, must be a non-empty string and not exceed 500 characters.
    *   `llm_generated`: Required, must be a boolean.
    *   `notes`: Optional, must be a string (can be empty).
    *   `file_name`: Optional, must be a string or null.
*   **Input Validation (on `POST /api/generate-summary`):**
    *   `transcription`: Required, must be a non-empty string.
*   **Input Validation (on `GET /api/summaries` query parameters):**
    *   `from_dt`, `to_dt`: If provided, must be valid timestamp strings parsable by the backend/database. `sort_by` and `sort_order` must be valid values.
*   **Business Logic Implementation:**
    *   **User Assignment:** The API layer (or RLS on INSERT) automatically sets the `user_id` for new `meeting_summaries` records based on the authenticated user's ID (`auth.uid()`).
    *   **Timestamping:** The database (using default `NOW()` or triggered by the API) sets `created_at` on creation (`POST`) and updates `updated_at` on both creation (`POST`) and update (`PUT`).
    *   **LLM Integration:** The `POST /api/generate-summary` endpoint orchestrates the call to the external LLM API, formats the prompt, sends the transcription, processes the response, and ensures the returned summary adheres to the <= 500 character limit (e.g., via prompt engineering or truncation).
    *   **Data Isolation:** RLS policies effectively filter all queries (`SELECT`, `UPDATE`, `DELETE`) to ensure only records matching the authenticated user's `user_id` are affected. The `INSERT` policy (`WITH CHECK`) ensures new records are correctly tagged with the user's ID.
    *   **List Sorting & Filtering:** The `GET /api/summaries` endpoint implements sorting and filtering logic. If `from_dt` and `to_dt` are *not* provided, it defaults the filtering range to `created_at BETWEEN NOW() - INTERVAL '7 days' AND NOW()`. If one or both are provided, it uses the provided range. Sorting is applied based on `sort_by` and `sort_order`, defaulting to `created_at DESC`.
    *   **Error Handling:** The API catches errors (database errors, LLM errors, validation errors) and returns appropriate HTTP status codes (400, 401, 403, 404, 500) with generic error messages to the client. Detailed error information is logged server-side as required by the PRD.

## 5. Security Considerations

*   **Authentication & Authorization (RLS):** As described above, Supabase Auth and RLS are the primary security mechanisms preventing unauthorized access and ensuring data isolation between users.
*   **Rate Limiting:** Implementing rate limiting on the `POST /api/generate-summary` endpoint is crucial to manage costs associated with LLM API calls and protect against abuse. This would typically be configured at the API gateway or serverless function level.
*   **Input Sanitization:** While not explicitly detailed in the plan, all user-provided text inputs (`transcription`, `summary`, `notes`, `file_name`) must be properly sanitized on the backend to prevent injection attacks (e.g., SQL injection, although RLS helps mitigate database risks, sanitization is good practice).
*   **`file_name` Uniqueness:** The current schema/API does not enforce `file_name` uniqueness *per user*. While not a security vulnerability, it's a potential usability issue (users might get confused saving multiple summaries with the same generated file name). A unique constraint per user (`UNIQUE (user_id, file_name)`) could be added to the database schema, which the API would then need to handle on `POST`/`PUT` requests (returning a `409 Conflict` if violated). This is considered a future enhancement beyond the strict MVP described.



================================================
File: .ai/create-new-summary-endpoint-curl-tests.md
================================================
# Testy Curl dla endpointa POST /api/summaries

Ten dokument zawiera zestaw komend `curl` do przetestowania endpointa API sĹ‚uĹĽÄ…cego do tworzenia nowych podsumowaÄąâ€ž spotkaÄąâ€ž.

## Warunki wstÄ™pne do uruchomienia testĂłw:

*   **Lokalne Supabase jest uruchomione:** Upewnij siÄ™, ĹĽe Twoje lokalne usĹ‚ugi Supabase dziaĹ‚ajÄ… (np. po uruchomieniu `supabase start` lub `supabase develop`). DomyĹ›lny port dla API to `54321`, a dla bazy danych `54322`.
*   **Serwer deweloperski Astro jest uruchomiony:** Uruchom serwer aplikacji komendÄ… `npm run dev` (lub `yarn dev`). DomyĹ›lny port to `3003` (zgodnie z `astro.config.mjs`). Komendy `curl` bÄ™dÄ… kierowane na ten adres (`http://localhost:3003`).
*   **Migracje zostaĹ‚y zastosowane:** Upewnij siÄ™, ĹĽe wszystkie potrzebne migracje, w tym dodajÄ…ce kolumnÄ™ `title` i usuwajÄ…ce `NOT NULL` z `notes`, zostaĹ‚y pomyĹ›lnie zastosowane na lokalnej bazie (`supabase migrate dev`).
*   **DomyĹ›lny uĹĽytkownik istnieje:** Upewnij siÄ™, ĹĽe uĹĽytkownik z ID zdefiniowanym w `src/db/supabase.client.ts` (`DEFAULT_USER_ID`) istnieje w tabelach `auth.users` i `public.users`. Endpoint w trybie MVP omija standardowÄ… autentykacjÄ™ i uĹĽywa tego staĹ‚ego ID.
*   **Posiadasz zainstalowane `jq` (opcjonalnie, ale zalecane):** `jq` sĹ‚uĹĽy do formatowania wyjĹ›cia JSON. JeĹ›li go nie masz, usuÄąâ€ž `| jq .` z koÄąâ€žca komend.

## Opis endpointa:

*   **Metoda HTTP:** `POST`
*   **URL Path:** `/api/summaries`
*   **Request Body (JSON):**
    ```json
    {
      "file_name": "string | null", // Optional
      "transcription": "string",     // Required
      "summary": "string",           // Required, max 500 characters
      "llm_generated": "boolean",    // Required
      "notes": "string"              // Optional
    }
    ```
*   **Success Response (201 Created):** JSON object of the created summary.
*   **Error Responses:** `400 Bad Request`, `401 Unauthorized` (choÄ‡ pomijamy autentykacjÄ™ w MVP, teoretycznie), `500 Internal Server Error`.

## Testy Curl:

UĹĽywamy `curl -s` do wyciszenia paska postÄ™pu i `| jq .` do formatowania odpowiedzi JSON. NagĹ‚Ăłwki HTTP nie bÄ™dÄ… widoczne w standardowym wyjĹ›ciu.

---

### Test 1: PomyĹ›lne utworzenie podsumowania - Wszystkie wymagane pola + opcjonalne (`file_name`, `notes`) (201 Created)

**Opis:** WysĹ‚anie poprawnego ciaĹ‚a ĹĽÄ…dania POST z kompletnymi danymi, w tym polami opcjonalnymi.

**Komenda:**

```bash
curl -s -X POST \
  http://localhost:3003/api/summaries \
  -H "Content-Type: application/json" \
  -d '{
    "file_name": "Spotkanie Projektowe Q3.txt",
    "transcription": "PeĹ‚na transkrypcja ze spotkania zespoĹ‚u...",
    "summary": "OmĂłwiono postÄ™py w projekcie Q3. Zidentyfikowano kluczowe zadania na nastÄ™pny tydzieÄąâ€ž. PodjÄ™to decyzjÄ™ o wdroĹĽeniu nowego moduĹ‚u do koÄąâ€žca miesiÄ…ca.",
    "llm_generated": true,
    "notes": "WaĹĽne punkty do zapamiÄ™tania: decyzja o module, zadania dla zespoĹ‚u."
  }' | jq .
```

```bash
curl -s -X POST http://localhost:3003/api/summaries -H "Content-Type: application/json" -d '{"file_name":"Spotkanie Projektowe Q3.txt","transcription":"PeĹ‚na transkrypcja ze spotkania zespoĹ‚u...","summary":"OmĂłwiono postÄ™py w projekcie Q3. Zidentyfikowano kluczowe zadania na nastÄ™pny tydzieĹ„. PodjÄ™to decyzjÄ™ o wdroĹĽeniu nowego moduĹ‚u do koĹ„ca miesiÄ…ca.","llm_generated":true,"notes":"WaĹĽne punkty do zapamiÄ™tania: decyzja o module, zadania dla zespoĹ‚u."}' | jq .
```

**Oczekiwany wynik:**

*   Status HTTP: `201 Created`
*   CiaĹ‚o odpowiedzi JSON: Obiekt JSON (`CreateSummaryResponseDTO`) zawierajÄ…cy wszystkie pola z ĹĽÄ…dania POST plus pola nadane przez bazÄ™ danych (`id`, `user_id` - powinno byÄ‡ `DEFAULT_USER_ID`, `created_at`, `updated_at`, `title` - wygenerowany automatycznie).

---

### Test 2: PomyĹ›lne utworzenie podsumowania - Tylko wymagane pola (201 Created)

**Opis:** WysĹ‚anie poprawnych danych zawierajÄ…cych tylko minimalny zestaw wymaganych pĂłl. Pola opcjonalne (`file_name`, `notes`) sÄ… pominiÄ™te.

**Komenda:**

```bash
curl -s -X POST \
  http://localhost:3003/api/summaries \
  -H "Content-Type: application/json" \
  -d '{
    "transcription": "KrĂłtka transkrypcja testowa.",
    "summary": "KrĂłtkie podsumowanie testowe.",
    "llm_generated": false
  }' | jq .
```

```bash
curl -s -X POST http://localhost:3003/api/summaries -H "Content-Type: application/json" -d '{"transcription":"KrĂłtka transkrypcja testowa.","summary":"KrĂłtkie podsumowanie testowe.","llm_generated":false}' | jq .

```

**Oczekiwany wynik:**

*   Status HTTP: `201 Created`
*   CiaĹ‚o odpowiedzi JSON: Obiekt JSON (`CreateSummaryResponseDTO`) zawierajÄ…cy wymagane pola z ĹĽÄ…dania oraz pola nadane przez bazÄ™ danych. Pola `file_name` i `notes` powinny byÄ‡ `null` lub puste stringi (zgodnie z domyĹ›lnÄ… wartoĹ›ciÄ… w Zod schema i mapowaniem do DB Insert). Pole `title` powinno byÄ‡ wygenerowane automatycznie na podstawie daty.

---

### Test 3: Brakuje wymaganego pola (`transcription`) (400 Bad Request)

**Opis:** Sprawdzenie walidacji Zod dla brakujÄ…cego wymaganego pola.

**Komenda:**

```bash
curl -s -X POST \
  http://localhost:3003/api/summaries \
  -H "Content-Type: application/json" \
  -d '{
    "summary": "Podsumowanie bez transkrypcji.",
    "llm_generated": true
  }' | jq .
```

```bash
curl -s -X POST http://localhost:3003/api/summaries -H "Content-Type: application/json" -d '{"summary":"Podsumowanie bez transkrypcji.","llm_generated":true}' | jq .

```

**Oczekiwany wynik:**

*   Status HTTP: `400 Bad Request`
*   CiaĹ‚o odpowiedzi JSON: Obiekt JSON z komunikatem bĹ‚Ä™du walidacji i szczegĂłĹ‚ami (`details`) wskazujÄ…cymi na bĹ‚Ä…d pola `transcription`.

---

### Test 4: Brakuje wymaganego pola (`summary`) (400 Bad Request)

**Opis:** Sprawdzenie walidacji Zod dla brakujÄ…cego wymaganego pola.

**Komenda:**

```bash
curl -s -X POST \
  http://localhost:3003/api/summaries \
  -H "Content-Type: application/json" \
  -d '{
    "transcription": "Transkrypcja bez podsumowania.",
    "llm_generated": false
  }' | jq .
```

```bash
curl -s -X POST http://localhost:3003/api/summaries -H "Content-Type: application/json" -d '{"transcription":"Transkrypcja bez podsumowania.","llm_generated":false}' | jq .

```

**Oczekiwany wynik:**

*   Status HTTP: `400 Bad Request`
*   CiaĹ‚o odpowiedzi JSON: Obiekt JSON z komunikatem bĹ‚Ä™du walidacji i szczegĂłĹ‚ami (`details`) wskazujÄ…cymi na bĹ‚Ä…d pola `summary`.

---

### Test 5: Brakuje wymaganego pola (`llm_generated`) (400 Bad Request)

**Opis:** Sprawdzenie walidacji Zod dla brakujÄ…cego wymaganego pola.

**Komenda:**

```bash
curl -s -X POST \
  http://localhost:3003/api/summaries \
  -H "Content-Type: application/json" \
  -d '{
    "transcription": "Transkrypcja.",
    "summary": "Podsumowanie."
  }' | jq .
```

```bash
curl -s -X POST http://localhost:3003/api/summaries -H "Content-Type: application/json" -d '{"transcription":"Transkrypcja.","summary":"Podsumowanie."}' | jq .

```

**Oczekiwany wynik:**

*   Status HTTP: `400 Bad Request`
*   CiaĹ‚o odpowiedzi JSON: Obiekt JSON z komunikatem bĹ‚Ä™du walidacji i szczegĂłĹ‚ami (`details`) wskazujÄ…cymi na bĹ‚Ä…d pola `llm_generated`.

---

### Test 6: NieprawidĹ‚owy typ danych (`llm_generated` nie jest booleanem) (400 Bad Request)

**Opis:** Sprawdzenie walidacji Zod dla nieprawidĹ‚owego typu danych.

**Komenda:**

```bash
curl -s -X POST \
  http://localhost:3003/api/summaries \
  -H "Content-Type: application/json" \
  -d '{
    "transcription": "Transkrypcja.",
    "summary": "Podsumowanie.",
    "llm_generated": "prawda"
  }' | jq .
```

```bash
curl -s -X POST http://localhost:3003/api/summaries -H "Content-Type: application/json" -d '{"transcription":"Transkrypcja.","summary":"Podsumowanie.","llm_generated":prawda}' | jq .

```

**Oczekiwany wynik:**

*   Status HTTP: `400 Bad Request`
*   CiaĹ‚o odpowiedzi JSON: Obiekt JSON z komunikatem bĹ‚Ä™du walidacji i szczegĂłĹ‚ami (`details`) wskazujÄ…cymi na bĹ‚Ä…d pola `llm_generated`.

---

### Test 7: Pole `summary` przekracza 500 znakĂłw (400 Bad Request)

**Opis:** Sprawdzenie walidacji Zod dla maksymalnej dĹ‚ugoĹ›ci pola `summary`.

**Komenda:**

```bash
# Generowanie ciÄ…gu 501 znakĂłw 'A' za pomocÄ… Pythona
curl -s -X POST \
  http://localhost:3003/api/summaries \
  -H "Content-Type: application/json" \
  -d '{
    "transcription": "Transkrypcja.",
    "summary": "'$(python -c 'print("A"*501)')'",
    "llm_generated": true
  }' | jq .
```
*(Uwaga: polecenie `$(python -c 'print("A"*501)')` wymaga zainstalowanego Pythona. JeĹ›li nie masz Pythona, musisz rÄ™cznie utworzyÄ‡ JSON z podsumowaniem dĹ‚uĹĽszym niĹĽ 500 znakĂłw).*

**Oczekiwany wynik:**

*   Status HTTP: `400 Bad Request`
*   CiaĹ‚o odpowiedzi JSON: Obiekt JSON z komunikatem bĹ‚Ä™du walidacji i szczegĂłĹ‚ami (`details`) wskazujÄ…cymi na bĹ‚Ä…d pola `summary` (zwiÄ…zany z `max` length).

---

### Test 8: CiaĹ‚o ĹĽÄ…dania nie jest poprawnym JSONem (400 Bad Request)

**Opis:** Sprawdzenie obsĹ‚ugi bĹ‚Ä™du parsowania JSON przed walidacjÄ… Zod.

**Komenda:**

```bash
curl -s -X POST \
  http://localhost:3003/api/summaries \
  -H "Content-Type: application/json" \
  -d '{
    "transcription": "...",
    "summary": "...",
    "llm_generated": true # Brak zamykajÄ…cego nawiasu klamrowego }
  ' | jq .
```

**Oczekiwany wynik:**

*   Status HTTP: `400 Bad Request`
*   CiaĹ‚o odpowiedzi JSON: Obiekt JSON z ogĂłlnym komunikatem bĹ‚Ä™du wskazujÄ…cym na problem z formatem JSON (`"Invalid JSON body"`).

---

### Test 9: Opcjonalne pole `file_name` ma nieprawidĹ‚owy typ (liczba) (400 Bad Request)

**Opis:** Sprawdzenie walidacji Zod dla nieprawidĹ‚owego typu danych w polu opcjonalnym.

**Komenda:**

```bash
curl -s -X POST \
  http://localhost:3003/api/summaries \
  -H "Content-Type: application/json" \
  -d '{
    "transcription": "...",
    "summary": "KrĂłtkie podsumowanie.",
    "llm_generated": true,
    "file_name": 123
  }' | jq .
```

**Oczekiwany wynik:**

*   Status HTTP: `400 Bad Request`
*   CiaĹ‚o odpowiedzi JSON: Obiekt JSON z komunikatem bĹ‚Ä™du walidacji i szczegĂłĹ‚ami (`details`) wskazujÄ…cymi na bĹ‚Ä…d pola `file_name` (zwiÄ…zany z typem).

---

### Test 10: Pole `notes` ma nieprawidĹ‚owy typ (liczba) (400 Bad Request)

**Opis:** Sprawdzenie walidacji Zod dla nieprawidĹ‚owego typu danych w polu opcjonalnym.

**Komenda:**

```bash
curl -s -X POST \
  http://localhost:3003/api/summaries \
  -H "Content-Type: application/json" \
  -d '{
    "transcription": "...",
    "summary": "KrĂłtkie podsumowanie.",
    "llm_generated": true,
    "notes": 456
  }' | jq .
```

**Oczekiwany wynik:**

*   Status HTTP: `400 Bad Request`
*   CiaĹ‚o odpowiedzi JSON: Obiekt JSON z komunikatem bĹ‚Ä™du walidacji i szczegĂłĹ‚ami (`details`) wskazujÄ…cymi na bĹ‚Ä…d pola `notes` (zwiÄ…zany z typem).

---

### Test 11: BĹ‚Ä…d wewnÄ™trzny serwera (np. konflikt RLS / bĹ‚Ä…d DB) (500 Internal Server Error)

**Opis:** Testuje, jak handler API reaguje na bĹ‚Ä™dy zgĹ‚oszone przez warstwÄ™ bazy danych (np. Supabase/PostgreSQL). W trybie MVP, gdzie uĹĽywamy `DEFAULT_USER_ID` zamiast `auth.uid()`, jeĹ›li RLS jest aktywne i skonfigurowane do sprawdzania `user_id = auth.uid()`, prĂłba wstawienia rekordu z jawnie podanym `DEFAULT_USER_ID` spowoduje bĹ‚Ä…d RLS na poziomie bazy danych, ktĂłry powinien zostaÄ‡ przechwycony i zwrĂłcony jako 500.

**Komenda:** UĹĽyj poprawnego ciaĹ‚a ĹĽÄ…dania, ktĂłre przeszĹ‚o walidacjÄ™ (np. z Testu 1 lub Testu 2). BĹ‚Ä…d 500 wystÄ…pi, jeĹ›li baza danych odrzuci zapytanie INSERT.

```bash
# UĹĽyj poprawnego ciaĹ‚a ĹĽÄ…dania, ktĂłre przeszĹ‚o walidacjÄ™
curl -s -X POST \
  http://localhost:3003/api/summaries \
  -H "Content-Type: application/json" \
  -d '{
    "transcription": "Test transkrypcji dla bĹ‚Ä™du DB.",
    "summary": "Testowe podsumowanie dla bĹ‚Ä™du DB.",
    "llm_generated": true
  }' | jq .
```

**Oczekiwany wynik:**

*   Status HTTP: `500 Internal Server Error`
*   CiaĹ‚o odpowiedzi JSON: Obiekt JSON z ogĂłlnym komunikatem bĹ‚Ä™du serwera (`"Internal server error occurred while saving the summary."`). SzczegĂłĹ‚y bĹ‚Ä™du DB/RLS *nie powinny* byÄ‡ ujawniane w odpowiedzi.

---



================================================
File: .ai/create-new-summary-endpoint.md
================================================
# API Endpoint Implementation Plan: Create New Summary (`POST /api/summaries`)

## 1. PrzeglÄ…d punktu koĹ„cowego
Punkt koĹ„cowy `POST /api/summaries` sĹ‚uĹĽy do tworzenia nowego rekordu podsumowania spotkania w bazie danych. Zgodnie z aktualnymi wytycznymi, rekord zostanie powiÄ…zany ze zdefiniowanym domyĹ›lnym uĹĽytkownikiem (`DEFAULT_USER_ID`) z pliku `src/db/supabase.client.ts`, a nie z aktualnie uwierzytelnionym uĹĽytkownikiem. Przyjmuje dane transkrypcji, podsumowania i inne metadane, waliduje je i wstawia nowy rekord do tabeli `meeting_summaries`.

## 2. SzczegĂłĹ‚y ĹĽÄ…dania
- **Metoda HTTP:** `POST`
- **Struktura URL:** `/api/summaries`
- **Parametry Query:** Brak
- **Request Body:** JSON object
  - **Wymagane pola:**
    - `transcription` (string): PeĹ‚na transkrypcja spotkania.
    - `summary` (string): Podsumowanie transkrypcji (max 500 znakĂłw).
    - `llm_generated` (boolean): Flaga wskazujÄ…ca, czy podsumowanie zostaĹ‚o wygenerowane przez LLM.
  - **Opcjonalne pola:**
    - `file_name` (string | null): Nazwa oryginalnego pliku, z ktĂłrego pochodzi transkrypcja.
    - `notes` (string): Dodatkowe notatki uĹĽytkownika.

## 3. Wykorzystywane typy
- `@types/summary` (lub podobna referencja do definicji typĂłw w projekcie):
  - `CreateSummaryRequestDTO`: Typ dla ciaĹ‚a ĹĽÄ…dania (`file_name`, `transcription`, `summary`, `llm_generated`, `notes`).
  - `MeetingSummaryDB`: Typ odpowiadajÄ…cy strukturze tabeli `meeting_summaries` w bazie danych (zawiera dodatkowo `id`, `user_id`, `created_at`, `modified_at`).
  - `CreateSummaryResponseDTO`: Typ dla ciaĹ‚a odpowiedzi sukcesu (201), zgodny ze specyfikacjÄ… API (zawiera `id`, `user_id`, `file_name`, `created_at`, `updated_at`, `transcription`, `summary`, `llm_generated`, `notes`). `updated_at` w odpowiedzi mapuje na `modified_at` z bazy danych.
- `SupabaseClient` z `src/db/supabase.client.ts`.

## 4. SzczegĂłĹ‚y odpowiedzi
- **Sukces (201 Created):**
  - CiaĹ‚o odpowiedzi: JSON object (`CreateSummaryResponseDTO`) zawierajÄ…cy peĹ‚ne dane nowo utworzonego rekordu, w tym ID nadane przez bazÄ™ danych, ID uĹĽytkownika (`DEFAULT_USER_ID`) oraz daty utworzenia i modyfikacji.
- **BĹ‚Ä™dy:**
  - `400 Bad Request`: NieprawidĹ‚owe dane wejĹ›ciowe (np. brak wymaganego pola, nieprawidĹ‚owy typ danych, pole `summary` przekracza 500 znakĂłw). CiaĹ‚o odpowiedzi powinno zawieraÄ‡ informacje o bĹ‚Ä™dzie walidacji.
  - `401 Unauthorized`: Wymagane uwierzytelnienie. ChociaĹĽ endpoint uĹĽywa `DEFAULT_USER_ID`, status 401 moĹĽe byÄ‡ zwrĂłcony, jeĹ›li wymagana jest *jakakolwiek* forma uwierzytelnienia na poziomie route (np. middleware), ktĂłra nie jest speĹ‚niona. *NaleĹĽy jednak zauwaĹĽyÄ‡ potencjalny konflikt z zaĹ‚oĹĽeniem uĹĽywania `DEFAULT_USER_ID` zamiast autentykacji.*
  - `500 Internal Server Error`: WystÄ…piĹ‚ nieoczekiwany bĹ‚Ä…d po stronie serwera (np. bĹ‚Ä…d bazy danych, w tym bĹ‚Ä™dy zwiÄ…zane z politykami RLS).

## 5. PrzepĹ‚yw danych
1.  Ĺ»Ä…danie `POST /api/summaries` trafia do backendu (Astro route handler).
2.  Handler prĂłbuje pobraÄ‡ obiekt `supabase` z `context.locals`. JeĹ›li `supabase` nie jest dostÄ™pne, zwraca `500 Internal Server Error`.
3.  Handler odczytuje ciaĹ‚o ĹĽÄ…dania JSON.
4.  Handler waliduje dane wejĹ›ciowe z ciaĹ‚a ĹĽÄ…dania:
    *   Sprawdza obecnoĹ›Ä‡ i typy wymaganych pĂłl (`transcription`, `summary`, `llm_generated`).
    *   Sprawdza typy opcjonalnych pĂłl (`file_name`, `notes`).
    *   Sprawdza, czy pole `summary` nie przekracza 500 znakĂłw.
    *   JeĹ›li walidacja zakoĹ„czy siÄ™ niepowodzeniem, zwraca `400 Bad Request` z informacjÄ… o bĹ‚Ä™dzie.
5.  Handler pobiera domyĹ›lny identyfikator uĹĽytkownika z `DEFAULT_USER_ID` z pliku `src/db/supabase.client.ts`. **(Uwaga: Pomijany jest krok pobierania ID uwierzytelnionego uĹĽytkownika z Supabase Auth).**
6.  Przygotowuje obiekt danych do wstawienia do bazy danych, mapujÄ…c pola z request body i dodajÄ…c `user_id` rĂłwne `DEFAULT_USER_ID`. Pola `created_at` i `modified_at` w DB bÄ™dÄ… automatycznie ustawione przez bazÄ™ danych (`DEFAULT NOW()`).
7.  WywoĹ‚uje funkcjÄ™ repository (np. `summariesRepository.createSummary`), przekazujÄ…c przygotowane dane. Ta funkcja uĹĽywa klienta `supabase` do wykonania zapytania `INSERT` do tabeli `meeting_summaries`. Zapytanie jawnie uĹĽyje `DEFAULT_USER_ID` dla kolumny `user_id`.
8.  Supabase i PostgreSQL wykonujÄ… INSERT. **(Uwaga: Istnieje wysokie ryzyko, ĹĽe polityki RLS na poziomie bazy danych, takie jak `insert_meeting_summaries ON meeting_summaries FOR INSERT WITH CHECK (user_id = auth.uid());`, spowodujÄ… bĹ‚Ä…d, poniewaĹĽ `user_id` w wierszu do wstawienia (`DEFAULT_USER_ID`) prawdopodobnie nie bÄ™dzie zgodny z `auth.uid()` w kontekĹ›cie ĹĽÄ…dania bazy danych, chyba ĹĽe RLS jest wyĹ‚Ä…czone lub zmodyfikowane).**
9.  Po udanym wstawieniu, Supabase zwraca wstawiony rekord (wĹ‚Ä…czajÄ…c w to `id`, `created_at`, `modified_at`).
10. Funkcja repository zwraca utworzony rekord do handlera.
11. Handler mapuje dane z rekordu bazy danych (`MeetingSummaryDB`) na format odpowiedzi API (`CreateSummaryResponseDTO`), zamieniajÄ…c `modified_at` na `updated_at`.
12. Handler zwraca `201 Created` wraz z utworzonym obiektem w ciele odpowiedzi.
13. JeĹ›li w trakcie interakcji z bazÄ… danych wystÄ…pi bĹ‚Ä…d (np. bĹ‚Ä…d RLS, bĹ‚Ä…d poĹ‚Ä…czenia), handler przechwytuje wyjÄ…tek i zwraca `500 Internal Server Error`, logujÄ…c szczegĂłĹ‚y bĹ‚Ä™du po stronie serwera.

## 6. WzglÄ™dy bezpieczeĹ„stwa
- **Uwierzytelnienie/Autoryzacja:** Zgodnie z wytycznymi, ten endpoint *nie* wykorzystuje standardowego przepĹ‚ywu autentykacji Supabase dla identyfikacji uĹĽytkownika. Wszelkie dane wstawione przez ten endpoint zostanÄ… przypisane do `DEFAULT_USER_ID`. **Jest to znaczÄ…ce odstÄ™pstwo od specyfikacji API ("for the authenticated user") i modelu bezpieczeĹ„stwa opartego na RLS powiÄ…zanym z `auth.uid()`.**
- **Konflikt z RLS:** JeĹ›li polityki RLS na tabeli `meeting_summaries` sÄ… aktywne (jak sugeruje schemat bazy danych), prĂłba wstawienia rekordu z jawnie podanym `DEFAULT_USER_ID` (ktĂłry nie jest powiÄ…zany z `auth.uid()` kontekstu bazy danych) najprawdopodobniej zakoĹ„czy siÄ™ bĹ‚Ä™dem uprawnieĹ„ na poziomie bazy danych. Aby ten endpoint dziaĹ‚aĹ‚ z `DEFAULT_USER_ID`, polityki RLS dla operacji INSERT na tabeli `meeting_summaries` mogÄ… wymagaÄ‡ tymczasowego wyĹ‚Ä…czenia lub zmiany, co **stanowczo odradza siÄ™ w Ĺ›rodowisku produkcyjnym dla danych uĹĽytkownikĂłw** z uwagi na potencjalne luki w bezpieczeĹ„stwie.
- **Walidacja Danych:** Walidacja danych wejĹ›ciowych w handlerze API pozostaje waĹĽna, aby zapobiegaÄ‡ wstawianiu niepoprawnych danych.
- **Ochrona przed SQL Injection:** UĹĽycie klienta Supabase i parametryzowanych zapytaĹ„ chroni przed SQL injection.

## 7. ObsĹ‚uga bĹ‚Ä™dĂłw
- Wczesna walidacja danych wejĹ›ciowych powinna wychwyciÄ‡ bĹ‚Ä™dy `400 Bad Request`. OdpowiedĹş powinna zawieraÄ‡ wystarczajÄ…cÄ… informacjÄ™ dla klienta o przyczynie bĹ‚Ä™du (np. lista nieprawidĹ‚owych pĂłl).
- **BĹ‚Ä™dy bazy danych (w tym RLS):** BĹ‚Ä™dy wynikajÄ…ce z prĂłby wstawienia danych z `DEFAULT_USER_ID` w sytuacji, gdy polityki RLS oparte na `auth.uid()` sÄ… aktywne, objawiÄ… siÄ™ jako bĹ‚Ä™dy na poziomie bazy danych. Powinny one zostaÄ‡ przechwycone przez blok `try...catch` w handlerze API i zwrĂłcone jako `500 Internal Server Error`. NaleĹĽy logowaÄ‡ szczegĂłĹ‚y tych bĹ‚Ä™dĂłw po stronie serwera, aby uĹ‚atwiÄ‡ diagnozÄ™ problemĂłw z konfiguracjÄ… RLS lub uĹĽyciem `DEFAULT_USER_ID`.
- Inne nieoczekiwane bĹ‚Ä™dy serwera rĂłwnieĹĽ powinny skutkowaÄ‡ odpowiedziÄ… `500 Internal Server Error`.

## 8. Etapy wdroĹĽenia
1.  Utworzenie lub modyfikacja pliku route handler dla endpointa (np. `src/pages/api/summaries.ts`).
2.  Zdefiniowanie lub weryfikacja typĂłw danych dla ĹĽÄ…dania, odpowiedzi i modelu DB (`CreateSummaryRequestDTO`, `CreateSummaryResponseDTO`, `MeetingSummaryDB`) w odpowiednim miejscu (np. `src/types/summary.ts`).
3.  Implementacja walidacji danych wejĹ›ciowych w handlerze API (sprawdzenie pĂłl wymaganych, typĂłw, max dĹ‚ugoĹ›ci `summary`). ZwrĂłcenie `400 Bad Request` w przypadku bĹ‚Ä™du walidacji.
4.  Pobranie klienta Supabase z `context.locals.supabase`. NaleĹĽy uĹĽyÄ‡ typu `SupabaseClient` z `src/db/supabase.client.ts`.
5.  Pobranie `DEFAULT_USER_ID` z pliku `src/db/supabase.client.ts`. **(Krok pomijajÄ…cy weryfikacjÄ™ autentykacji uĹĽytkownika).**
6.  Implementacja funkcji repository do wstawiania danych do tabeli `meeting_summaries` (np. w `src/db/summariesRepository.ts`), korzystajÄ…cej z klienta Supabase i jawnie przekazujÄ…cej `DEFAULT_USER_ID` jako wartoĹ›Ä‡ kolumny `user_id` w zapytaniu INSERT.
7.  WywoĹ‚anie funkcji repository z handlera, przekazujÄ…c zwalidowane dane i `DEFAULT_USER_ID`.
8.  ObsĹ‚uga odpowiedzi z repository: mapowanie na `CreateSummaryResponseDTO` i zwrĂłcenie `201 Created` w przypadku sukcesu.
9.  Implementacja bloku `try...catch` w handlerze do przechwytywania potencjalnych bĹ‚Ä™dĂłw (szczegĂłlnie zwiÄ…zanych z RLS lub DB), logowanie ich i zwracanie `500 Internal Server Error`.
10. Przetestowanie endpointa przy uĹĽyciu narzÄ™dzi takich jak Postman lub cURL, weryfikujÄ…c scenariusze sukcesu i bĹ‚Ä™dĂłw walidacji/serwera. **SzczegĂłlnÄ… uwagÄ™ naleĹĽy zwrĂłciÄ‡ na bĹ‚Ä™dy 500, ktĂłre mogÄ… wynikaÄ‡ z konfliktĂłw z politykami RLS opartymi na `auth.uid()` przy uĹĽyciu `DEFAULT_USER_ID`.**
11. W razie wystÄ…pienia bĹ‚Ä™dĂłw RLS, skonsultowaÄ‡ z zespoĹ‚em ds. bazy danych/Supabase w celu podjÄ™cia decyzji o konfiguracji RLS lub powrocie do modelu opartego na autentykacji.
12. Utworzenie i przeglÄ…d kodu (Code Review), zwracajÄ…c szczegĂłlnÄ… uwagÄ™ na implikacje uĹĽycia `DEFAULT_USER_ID` dla bezpieczeĹ„stwa.
13. WdroĹĽenie na Ĺ›rodowisko testowe/produkcyjne, majÄ…c peĹ‚nÄ… Ĺ›wiadomoĹ›Ä‡ ograniczeĹ„ i ryzyk zwiÄ…zanych z uĹĽyciem `DEFAULT_USER_ID`.


================================================
File: .ai/db-plan.md
================================================
## Schemat Bazy Danych PostgreSQL dla Aplikacji Meeting Summarizer

Niniejszy dokument opisuje schemat bazy danych PostgreSQL dla aplikacji Meeting Summarizer, uwzglÄ™dniajÄ…c wymagania z dokumentu PRD, notatek z sesji planowania oraz wybranego stacku technologicznego (Supabase).

### 1. Tabele

#### 1.1. Tabela `users`

*   **Opis:** Przechowuje informacje o uĹĽytkownikach aplikacji. Klucz gĹ‚Ăłwny pochodzi z Supabase Auth.
*   **Kolumny:**
    *   `id` UUID PRIMARY KEY (pochodzÄ…cy z Supabase Auth)
    *   `email` VARCHAR(255) UNIQUE NOT NULL
    *   `created_at` TIMESTAMP WITH TIME ZONE DEFAULT NOW()

#### 1.2. Tabela `meeting_summaries`

*   **Opis:** Przechowuje transkrypcje spotkaĹ„, podsumowania generowane przez LLM, notatki uĹĽytkownikĂłw oraz metadane.
*   **Kolumny:**
    *   `id` UUID PRIMARY KEY DEFAULT gen_random_uuid()
    *   `user_id` UUID REFERENCES users(id) ON DELETE CASCADE NOT NULL
    *   `file_name` VARCHAR(255)
    *   `created_at` TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL
    *   `modified_at` TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL
    *   `transcription` TEXT NOT NULL
    *   `summary` VARCHAR(500) NOT NULL
    *   `llm_generated` BOOLEAN DEFAULT TRUE NOT NULL
    *   `notes` TEXT NOT NULL

### 2. Relacje

*   **users 1:N meeting_summaries:** Jeden uĹĽytkownik moĹĽe mieÄ‡ wiele transkrypcji i podsumowaĹ„.  Relacja ta jest zdefiniowana przez klucz obcy `user_id` w tabeli `meeting_summaries`, ktĂłry odwoĹ‚uje siÄ™ do `id` w tabeli `users`.  `ON DELETE CASCADE` zapewnia, ĹĽe usuniÄ™cie uĹĽytkownika spowoduje usuniÄ™cie wszystkich jego powiÄ…zanych transkrypcji i podsumowaĹ„.

### 3. Indeksy

*   `idx_meeting_summaries_user_id` ON `meeting_summaries(user_id)`: Przyspiesza wyszukiwanie podsumowaĹ„ danego uĹĽytkownika.
*   `idx_meeting_summaries_data_utworzenia` ON `meeting_summaries(data_utworzenia)`: Przyspiesza sortowanie podsumowaĹ„ po dacie utworzenia.
*   `idx_meeting_summaries_llm_generated` ON `meeting_summaries(llm_generated)`:  UmoĹĽliwia szybkie wyszukiwanie podsumowaĹ„ wygenerowanych przez LLM lub zmodyfikowanych przez uĹĽytkownika.

### 4. Zasady PostgreSQL (Row Level Security - RLS)

PoniĹĽsze przykĹ‚ady zasad RLS zapewniajÄ…, ĹĽe uĹĽytkownicy mogÄ… manipulowaÄ‡ tylko swoimi wĹ‚asnymi danymi. Te zasady sÄ… przykĹ‚adowe i mogÄ… wymagaÄ‡ dostosowania do konkretnych potrzeb aplikacji. ZakĹ‚adajÄ… uĹĽycie funkcji `auth.uid()` z Supabase Auth, ktĂłra zwraca identyfikator zalogowanego uĹĽytkownika.

*   **RLS na tabeli `meeting_summaries`:**

    *   `CREATE POLICY select_meeting_summaries ON meeting_summaries FOR SELECT USING (user_id = auth.uid());`
    *   `CREATE POLICY insert_meeting_summaries ON meeting_summaries FOR INSERT WITH CHECK (user_id = auth.uid());`
    *   `CREATE POLICY update_meeting_summaries ON meeting_summaries FOR UPDATE USING (user_id = auth.uid()) WITH CHECK (user_id = auth.uid());`
    *   `CREATE POLICY delete_meeting_summaries ON meeting_summaries FOR DELETE USING (user_id = auth.uid());`

### 5. Dodatkowe Uwagi

*   **Supabase Auth:**  Kluczowe jest prawidĹ‚owe skonfigurowanie Supabase Auth i zintegrowanie go z aplikacjÄ…, aby zapewniÄ‡ bezpieczne uwierzytelnianie i autoryzacjÄ™ uĹĽytkownikĂłw.
*   **Typy danych:** WybĂłr typĂłw danych zostaĹ‚ dokonany w oparciu o wymagania MVP. W przyszĹ‚oĹ›ci, w zaleĹĽnoĹ›ci od potrzeb, moĹĽna rozwaĹĽyÄ‡ ich zmianÄ™ (np. uĹĽycie `TEXT` zamiast `VARCHAR(500)` dla podsumowaĹ„, jeĹ›li okaĹĽe siÄ™, ĹĽe 500 znakĂłw to za maĹ‚o).
*   **Nazewnictwo:**  UĹĽyto konwencji snake_case dla nazw tabel i kolumn.
*   **Normalizacja:** Schemat zostaĹ‚ znormalizowany do poziomu 3NF, aby uniknÄ…Ä‡ redundancji danych i zapewniÄ‡ integralnoĹ›Ä‡.
*   **BezpieczeĹ„stwo:**  RLS jest kluczowym elementem bezpieczeĹ„stwa, zapewniajÄ…cym, ĹĽe uĹĽytkownicy majÄ… dostÄ™p tylko do swoich danych. NaleĹĽy dokĹ‚adnie przetestowaÄ‡ i zweryfikowaÄ‡ zasady RLS, aby upewniÄ‡ siÄ™, ĹĽe dziaĹ‚ajÄ… poprawnie.
*   **SkalowalnoĹ›Ä‡:**  Indeksy zostaĹ‚y dodane w celu poprawy wydajnoĹ›ci zapytaĹ„. W przyszĹ‚oĹ›ci, w przypadku bardzo duĹĽych zbiorĂłw danych, moĹĽna rozwaĹĽyÄ‡ partycjonowanie tabeli `meeting_summaries`.

Ten schemat bazy danych stanowi solidnÄ… podstawÄ™ dla MVP aplikacji Meeting Summarizer. W miarÄ™ rozwoju projektu i wdraĹĽania nowych funkcjonalnoĹ›ci, schemat moĹĽe wymagaÄ‡ modyfikacji i rozbudowy.



================================================
File: .ai/db.sql
================================================
-- Header comment:
-- Purpose: Initializes the database schema for the Meeting Summarizer application.
--          This migration creates the 'users' and 'meeting_summaries' tables,
--          sets up relationships between them, adds indexes for performance,
--          and configures Row Level Security (RLS) for data protection.
--
-- Affected tables/columns:
--          - users (id, email, created_at)
--          - meeting_summaries (id, user_id, file_name, data_utworzenia, data_modyfikacji,
--                                transcription, summary, llm_generated, notes)
--
-- Special considerations:
--          - The 'id' column in the 'users' table is assumed to be managed by Supabase Auth.
--          - RLS policies are configured to ensure that users can only access their own data.

-- Create the 'users' table
create table users (
    id uuid primary key,
    email varchar(255) unique not null,
    created_at timestamp with time zone default now()
);

comment on table users is 'table containing user information';
comment on column users.id is 'user id from supabase auth';
comment on column users.email is 'user email address';
comment on column users.created_at is 'timestamp of user creation';

-- Enable RLS on the 'users' table
alter table users enable row level security;

-- Create RLS policy for 'users' table - SELECT access for authenticated users
create policy "users_select_policy" on users for select to authenticated
using (auth.uid() = id);
comment on policy "users_select_policy" on users is 'enable read access to all users based on user id';

-- Create the 'meeting_summaries' table
create table meeting_summaries (
    id uuid primary key default gen_random_uuid(),
    user_id uuid references users(id) on delete cascade not null,
    file_name varchar(255),
    data_utworzenia timestamp with time zone default now() not null,
    data_modyfikacji timestamp with time zone default now() not null,
    transcription text not null,
    summary varchar(500) not null,
    llm_generated boolean default true not null,
    notes text not null
);

comment on table meeting_summaries is 'table containing meeting summaries';
comment on column meeting_summaries.id is 'unique id for meeting summary';
comment on column meeting_summaries.user_id is 'user id, foreign key from users table';
comment on column meeting_summaries.file_name is 'name of the original transcription file';
comment on column meeting_summaries.data_utworzenia is 'timestamp of summary creation';
comment on column meeting_summaries.data_modyfikacji is 'timestamp of last summary modification';
comment on column meeting_summaries.transcription is 'original meeting transcript';
comment on column meeting_summaries.summary is 'llm generated meeting summary';
comment on column meeting_summaries.llm_generated is 'boolean indicating whether the summary was generated by llm';
comment on column meeting_summaries.notes is 'user notes for the given summary';

-- Enable RLS on the 'meeting_summaries' table
alter table meeting_summaries enable row level security;

-- Create RLS policy for 'meeting_summaries' table - SELECT access for authenticated users
create policy "meeting_summaries_select_policy" on meeting_summaries for select to authenticated
using (auth.uid() = user_id);
comment on policy "meeting_summaries_select_policy" on meeting_summaries is 'enable read access to all users based on user id';

-- Create RLS policy for 'meeting_summaries' table - INSERT access for authenticated users
create policy "meeting_summaries_insert_policy" on meeting_summaries for insert to authenticated
with check (auth.uid() = user_id);
comment on policy "meeting_summaries_insert_policy" on meeting_summaries is 'enable insert access to all users based on user id';

-- Create RLS policy for 'meeting_summaries' table - UPDATE access for authenticated users
create policy "meeting_summaries_update_policy" on meeting_summaries for update to authenticated
using (auth.uid() = user_id)
with check (auth.uid() = user_id);
comment on policy "meeting_summaries_update_policy" on meeting_summaries is 'enable update access to all users based on user id';

-- Create RLS policy for 'meeting_summaries' table - DELETE access for authenticated users
create policy "meeting_summaries_delete_policy" on meeting_summaries for delete to authenticated
using (auth.uid() = user_id);
comment on policy "meeting_summaries_delete_policy" on meeting_summaries is 'enable delete access to all users based on user id';

-- Create indexes to optimize query performance
create index idx_meeting_summaries_user_id on meeting_summaries(user_id);
comment on index idx_meeting_summaries_user_id is 'index for user id, used for fast data retrieval';

create index idx_meeting_summaries_data_utworzenia on meeting_summaries(data_utworzenia);
comment on index idx_meeting_summaries_data_utworzenia is 'index for meeting summary creation date, used for fast data retrieval';

create index idx_meeting_summaries_llm_generated on meeting_summaries(llm_generated);
comment on index idx_meeting_summaries_llm_generated is 'index for llm generation flag, used for fast data retrieval';


================================================
File: .ai/generate-summary-endpoint-curl-tests.md
================================================
# Testy Curl dla endpointa POST /api/generate-summary (Bez Autentykacji MVP - One-liner)

Ten dokument zawiera zestaw komend `curl` do przetestowania endpointa API sĹ‚uĹĽÄ…cego do generowania podsumowaĹ„ za pomocÄ… mocka LLM. Zgodnie z aktualnymi wytycznymi, ten endpoint **nie wymaga** uwierzytelnienia. KaĹĽda komenda jest w jednej linii.

## Warunki wstÄ™pne do uruchomienia testĂłw:

*   **Serwer deweloperski Astro jest uruchomiony:** Upewnij siÄ™, ĹĽe Twoje lokalne usĹ‚ugi Supabase i serwer Astro dziaĹ‚ajÄ… (np. po uruchomieniu `supabase start` lub `supabase develop`). DomyĹ›lny port serwera Astro to `3003`. Komendy `curl` bÄ™dÄ… kierowane na ten adres (`http://localhost:3003`).
*   **Posiadasz zainstalowane `jq` (opcjonalnie, ale zalecane):** `jq` sĹ‚uĹĽy do formatowania wyjĹ›cia JSON. JeĹ›li go nie masz, usuĹ„ `| jq .` z koĹ„ca komend.
*   Supabase Auth moĹĽe byÄ‡ skonfigurowane w projekcie dla innych endpointĂłw, ale **dla tego endpointa autentykacja jest pomijana.**

## Opis endpointa:

*   **Metoda HTTP:** `POST`
*   **URL Path:** `/api/generate-summary`
*   **Request Body (JSON):**
    ```json
    {
      "transcription": "string" // Required, non-empty
    }
    ```
*   **Success Response (200 OK):** JSON object `{ "summary": "string" }` (max 500 chars).
*   **Error Responses:** `400 Bad Request`, `500 Internal Server Error`. (Status `401 Unauthorized` nie powinien byÄ‡ zwracany w tej wersji implementacji).

## Testy Curl (One-liners):

UĹĽywamy `curl -s` do wyciszenia paska postÄ™pu i `| jq .` do formatowania odpowiedzi JSON.

---

### Test 1: PomyĹ›lne wygenerowanie podsumowania (200 OK)

**Opis:** WysyĹ‚a poprawne ĹĽÄ…danie z transkrypcjÄ…. Autentykacja nie jest wymagana.

**Komenda:**
```bash
curl -s -X POST http://localhost:3003/api/generate-summary -H "Content-Type: application/json" -d '{"transcription": "To jest pierwsza linia transkrypcji z polskimi znakami: Ä…Ä™Ĺ‚ĂłĹşĹĽÄ‡Ĺ„Ĺ›.\nDruga linia.\nTrzecia linia z jakimiĹ› szczegĂłĹ‚ami..."}' | jq .
```

**Oczekiwany wynik:** Status `200 OK` i JSON z mockowym podsumowaniem.

---

### Test 2: Brak pola `transcription` (400 Bad Request)

**Opis:** Brakuje wymaganego pola `transcription` w ciele ĹĽÄ…dania.

**Komenda:**
```bash
curl -s -X POST http://localhost:3003/api/generate-summary -H "Content-Type: application/json" -d '{"otherField": "jakaĹ› wartoĹ›Ä‡"}' | jq .
```

**Oczekiwany wynik:** Status `400 Bad Request` i JSON z bĹ‚Ä™dem walidacji.

---

### Test 3: Pole `transcription` jest pustym stringiem (400 Bad Request)

**Opis:** Pole `transcription` jest obecne, ale jest pustym stringiem.

**Komenda:**
```bash
curl -s -X POST http://localhost:3003/api/generate-summary -H "Content-Type: application/json" -d '{"transcription": ""}' | jq .
```

**Oczekiwany wynik:** Status `400 Bad Request` i JSON z bĹ‚Ä™dem walidacji.

---

### Test 4: Pole `transcription` ma nieprawidĹ‚owy typ (np. liczba) (400 Bad Request)

**Opis:** Pole `transcription` jest obecne, ale nie jest typu string.

**Komenda:**
```bash
curl -s -X POST http://localhost:3003/api/generate-summary -H "Content-Type: application/json" -d '{"transcription": 12345}' | jq .
```

**Oczekiwany wynik:** Status `400 Bad Request` i JSON z bĹ‚Ä™dem walidacji.

---

### Test 5: CiaĹ‚o ĹĽÄ…dania nie jest poprawnym JSONem (400 Bad Request)

**Opis:** CiaĹ‚o ĹĽÄ…dania nie jest poprawnym formatem JSON.

**Komenda:**
```bash
curl -s -X POST http://localhost:3003/api/generate-summary -H "Content-Type: application/json" -d '{"transcription": "..."' | jq .
```

**Oczekiwany wynik:** Status `400 Bad Request` i JSON z ogĂłlnym bĹ‚Ä™dem parsowania JSON.

---

### Test 6: WysyĹ‚anie ĹĽÄ…dania bez autentykacji (Oczekiwany Sukces 200 OK)

**Opis:** Testuje scenariusz, ktĂłry wczeĹ›niej zwracaĹ‚ 401. Teraz, z powodu braku wymaganej autentykacji, ĹĽÄ…danie powinno siÄ™ udaÄ‡, jeĹ›li ciaĹ‚o jest poprawne.

**Komenda:**
```bash
curl -s -X POST http://localhost:3003/api/generate-summary -H "Content-Type: application/json" -d '{"transcription": "To jest transkrypcja, ktĂłra powinna dziaĹ‚aÄ‡ bez autentykacji."}' | jq .
```

**Oczekiwany wynik:** Status `200 OK` i JSON z mockowym podsumowaniem.

---

### Test 7: WysyĹ‚anie ĹĽÄ…dania z nieprawidĹ‚owym/pustym nagĹ‚Ăłwkiem Authorization (Oczekiwany Sukces 200 OK)

**Opis:** Testuje scenariusz, ktĂłry wczeĹ›niej zwracaĹ‚ 401 z powodu nieprawidĹ‚owego/pustego nagĹ‚Ăłwka. Teraz powinno siÄ™ udaÄ‡, jeĹ›li ciaĹ‚o jest poprawne.

**Komenda:**
```bash
curl -s -X POST http://localhost:3003/api/generate-summary -H "Content-Type: application/json" -H "Authorization: Bearer invalid.token.string" -d '{"transcription": "Inna transkrypcja, ktĂłra powinna dziaĹ‚aÄ‡ mimo \'faĹ‚szywej\' autentykacji."}' | jq .
```

**Oczekiwany wynik:** Status `200 OK` i JSON z mockowym podsumowaniem.

---

### Test 8: BĹ‚Ä…d wewnÄ™trzny serwera (np. w mocku LLM) (500 Internal Server Error)

**Opis:** Symulacja bĹ‚Ä™du w logice mocka LLM (jeĹ›li wstawiono tam celowe rzucanie bĹ‚Ä™du na potrzeby testĂłw 500). Autentykacja nie wpĹ‚ywa na ten scenariusz.

**Komenda:**
```bash
curl -s -X POST http://localhost:3003/api/generate-summary -H "Content-Type: application/json" -d '{"transcription": "To jest transkrypcja, ktora ma wywolac blad w mocku."}' | jq .
```

**Oczekiwany wynik:** Status `500 Internal Server Error` i JSON z ogĂłlnym bĹ‚Ä™dem serwera.

---



================================================
File: .ai/generate-summary-endpoint.md
================================================
# API Endpoint Implementation Plan: Generate Summary (`POST /api/generate-summary`)

## 1. PrzeglÄ…d punktu koĹ„cowego
Punkt koĹ„cowy `POST /api/generate-summary` sĹ‚uĹĽy do wywoĹ‚ania modelu duĹĽego jÄ™zyka (LLM) w celu stworzenia podsumowania dostarczonego tekstu transkrypcji. Endpoint ten **nie zapisuje ĹĽadnych danych w bazie danych**; jego jedynym zadaniem jest przetworzenie tekstu transkrypcji przez LLM i zwrĂłcenie wygenerowanego podsumowania do klienta. Endpoint wymaga uwierzytelnienia.

## 2. SzczegĂłĹ‚y ĹĽÄ…dania
- **Metoda HTTP:** `POST`
- **Struktura URL:** `/api/generate-summary`
- **Parametry Query:** Brak
- **Request Body:** JSON object
  - **Wymagane pola:**
    - `transcription` (string): Tekst transkrypcji do podsumowania. Musi byÄ‡ niepustym stringiem.
  - **Opcjonalne pola:** Brak.

## 3. Wykorzystywane typy
- `../../types`:
    - `GenerateSummaryCommand`: Typ dla ciaĹ‚a ĹĽÄ…dania (request body), zawierajÄ…cy pole `transcription`.
    - `GenerateSummaryResponseDto`: Typ dla ciaĹ‚a odpowiedzi sukcesu (200 OK), zawierajÄ…cy pole `summary`.
- `zod`: Biblioteka do walidacji danych wejĹ›ciowych. Zdefiniowany zostanie schemat Zod odpowiadajÄ…cy `GenerateSummaryCommand`.
- `SupabaseClient` z `src/db/supabase.client.ts`: Do weryfikacji uwierzytelnienia uĹĽytkownika.

## 4. SzczegĂłĹ‚y odpowiedzi
- **Sukces (200 OK):**
  - CiaĹ‚o odpowiedzi: JSON object (`GenerateSummaryResponseDto`) zawierajÄ…cy wygenerowane podsumowanie w polu `summary`. Tekst podsumowania bÄ™dzie ograniczony do maksymalnie 500 znakĂłw.
- **BĹ‚Ä™dy:**
  - `400 Bad Request`: NieprawidĹ‚owe dane wejĹ›ciowe (np. brak pola `transcription`, `transcription` jest puste lub nie jest stringiem). CiaĹ‚o odpowiedzi powinno zawieraÄ‡ informacje o bĹ‚Ä™dzie walidacji.
  - `401 Unauthorized`: Wymagane uwierzytelnienie. UĹĽytkownik nie jest zalogowany lub token autentykacji jest nieprawidĹ‚owy.
  - `500 Internal Server Error`: WystÄ…piĹ‚ nieoczekiwany bĹ‚Ä…d po stronie serwera (np. bĹ‚Ä…d komunikacji z API LLM, bĹ‚Ä…d podczas przetwarzania odpowiedzi LLM). CiaĹ‚o odpowiedzi powinno zawieraÄ‡ generyczny komunikat o bĹ‚Ä™dzie serwera.

## 5. PrzepĹ‚yw danych
1.  Ĺ»Ä…danie `POST /api/generate-summary` trafia do backendu (Astro route handler).
2.  Handler prĂłbuje pobraÄ‡ obiekt `supabase` z `context.locals`. JeĹ›li `supabase` nie jest dostÄ™pne, zwraca `500 Internal Server Error`.
3.  Handler weryfikuje, czy uĹĽytkownik jest uwierzytelniony przy uĹĽyciu `supabase.auth.getUser()`. JeĹ›li nie, zwraca `401 Unauthorized`.
4.  Handler odczytuje ciaĹ‚o ĹĽÄ…dania JSON.
5.  Handler waliduje ciaĹ‚o ĹĽÄ…dania przy uĹĽyciu schematu Zod (`createGenerateSummaryRequestSchema`), upewniajÄ…c siÄ™, ĹĽe `transcription` jest niepustym stringiem. JeĹ›li walidacja zakoĹ„czy siÄ™ niepowodzeniem, zwraca `400 Bad Request` z informacjÄ… o bĹ‚Ä™dzie walidacji.
6.  Z zwalidowanych danych wejĹ›ciowych wyodrÄ™bnia tekst transkrypcji.
7.  WywoĹ‚uje funkcjÄ™ w warstwie serwisowej (np. `SummaryService.generateSummary`) przekazujÄ…c transkrypcjÄ™. Zgodnie z reguĹ‚ami implementacji, ta funkcja uĹĽyje mockowej implementacji LLM.
8.  Funkcja serwisowa (lub dedykowana mockowa funkcja LLM) przetwarza transkrypcjÄ™ (np. zwraca pierwszÄ… liniÄ™) i zapewnia, ĹĽe wynikowe podsumowanie ma maksymalnie 500 znakĂłw (obcinajÄ…c, jeĹ›li to konieczne).
9.  Funkcja serwisowa zwraca wygenerowane (mockowe) podsumowanie jako string.
10. Handler API odbiera podsumowanie od serwisu.
11. Mapuje podsumowanie na format odpowiedzi API (`GenerateSummaryResponseDto`).
12. Zwraca `200 OK` wraz z obiektem odpowiedzi w ciele.
13. W przypadku bĹ‚Ä™du podczas parsowania JSON, walidacji, weryfikacji autentykacji lub podczas wywoĹ‚ania/przetwarzania odpowiedzi serwisu (LLM mock/API), handler przechwytuje wyjÄ…tek/bĹ‚Ä…d, loguje szczegĂłĹ‚y po stronie serwera i zwraca odpowiedni status bĹ‚Ä™du (`400`, `401`, `500`) z generycznym komunikatem.

## 6. WzglÄ™dy bezpieczeĹ„stwa
-   **Uwierzytelnienie:** Endpoint wymaga, aby ĹĽÄ…danie pochodziĹ‚o od uwierzytelnionego uĹĽytkownika. Implementacja musi uĹĽyÄ‡ `supabase.auth.getUser()` w handlerze i zwrĂłciÄ‡ `401 Unauthorized` jeĹ›li uĹĽytkownik nie jest zalogowany. ReguĹ‚a dotyczÄ…ca `DEFAULT_USER_ID` nie ma tu zastosowania, poniewaĹĽ endpoint nie wchodzi w interakcjÄ™ z danymi uĹĽytkownika w bazie danych.
-   **Walidacja Danych:** Walidacja danych wejĹ›ciowych przy uĹĽyciu Zod jest kluczowa, aby zapobiec przetwarzaniu niepoprawnych lub zĹ‚oĹ›liwych danych.
-   **Rate Limiting:** ChociaĹĽ w tej chwili uĹĽywany jest mock LLM, w przyszĹ‚oĹ›ci po integracji z prawdziwym API LLM, **krytyczne jest wdroĹĽenie rate limiting** na poziomie serwera/API Gateway dla tego endpointa, aby chroniÄ‡ przed naduĹĽyciem i wysokimi kosztami. NaleĹĽy o tym pamiÄ™taÄ‡ przy planowaniu infrastruktury produkcyjnej.

## 7. ObsĹ‚uga bĹ‚Ä™dĂłw
-   **NieprawidĹ‚owe Dane WejĹ›ciowe (400):** Parsowanie JSON i walidacja Zod powinny wychwyciÄ‡ bĹ‚Ä™dy formatu i treĹ›ci ĹĽÄ…dania (`transcription` brakujÄ…ce, puste, zĹ‚y typ). OdpowiedĹş `400 Bad Request` z informacjÄ… o bĹ‚Ä™dach walidacji.
-   **Brak Uwierzytelnienia (401):** Sprawdzenie `supabase.auth.getUser()` obsĹ‚uĹĽy scenariusz nieautoryzowanego dostÄ™pu.
-   **BĹ‚Ä™dy Serwera / LLM (500):** Wszelkie bĹ‚Ä™dy powstaĹ‚e podczas wywoĹ‚ywania logiki serwisowej (mocka LLM) powinny byÄ‡ przechwycone. NaleĹĽy logowaÄ‡ szczegĂłĹ‚y tych bĹ‚Ä™dĂłw po stronie serwera i zwracaÄ‡ `500 Internal Server Error` z ogĂłlnym komunikatem dla klienta ("An internal server error occurred").

## 8. Etapy wdroĹĽenia
1.  Utworzenie pliku route handler dla endpointa (np. `src/pages/api/generate-summary.ts`).
2.  Zdefiniowanie lub weryfikacja typĂłw `GenerateSummaryCommand` i `GenerateSummaryResponseDto` w centralnym pliku typĂłw (np. `../../types`).
3.  Implementacja walidacji danych wejĹ›ciowych w handlerze API przy uĹĽyciu Zod (`createGenerateSummaryRequestSchema`). ZwrĂłcenie `400 Bad Request` w przypadku bĹ‚Ä™du walidacji.
4.  Pobranie klienta Supabase z `context.locals.supabase` i sprawdzenie jego dostÄ™pnoĹ›ci (zwrot 500 Internal Server Error jeĹ›li brak).
5.  Weryfikacja uwierzytelnienia uĹĽytkownika przy uĹĽyciu `supabase.auth.getUser()` w handlerze. ZwrĂłcenie `401 Unauthorized` jeĹ›li uĹĽytkownik nie jest zalogowany.
6.  Utworzenie/aktualizacja `SummaryService` lub dedykowanej klasy/funkcji dla logiki LLM. Dodanie metody (np. `generateSummary`) przyjmujÄ…cej transkrypcjÄ™.
7.  Implementacja **mockowej logiki LLM** w metodzie `generateSummary` serwisu:
    *   Funkcja powinna przyjÄ…Ä‡ `transcription` (string).
    *   Powinna wyodrÄ™bniÄ‡ pierwszÄ… liniÄ™ transkrypcji.
    *   Powinna obciÄ…Ä‡ wynik do maksymalnie 500 znakĂłw, aby speĹ‚niÄ‡ specyfikacjÄ™ API.
    *   Powinna zwrĂłciÄ‡ obciÄ™ty string.
8.  WywoĹ‚anie metody serwisowej `generateSummary` z handlera API, przekazujÄ…c zwalidowanÄ… transkrypcjÄ™.
9.  ObsĹ‚uga odpowiedzi z serwisu: zmapowanie zwrĂłconego podsumowania na `GenerateSummaryResponseDto` i zwrĂłcenie `200 OK`.
10. Implementacja bloku `try...catch` w handlerze API i metodzie serwisowej do przechwytywania bĹ‚Ä™dĂłw (walidacji, autentykacji, nieoczekiwanych). Logowanie szczegĂłĹ‚Ăłw bĹ‚Ä™dĂłw po stronie serwera. Zwracanie odpowiednich statusĂłw (`400`, `401`, `500`) z generycznymi komunikatami.
11. Przetestowanie endpointa przy uĹĽyciu narzÄ™dzi takich jak Postman lub cURL, weryfikujÄ…c wszystkie scenariusze (sukces, bĹ‚Ä™dy walidacji, brak autoryzacji, bĹ‚Ä™dy serwera/mocka).
12. Utworzenie i przeglÄ…d kodu (Code Review).
13. WdroĹĽenie na Ĺ›rodowisko testowe/produkcyjne.



================================================
File: .ai/prd.md
================================================
# Dokument wymagaĹ„ produktu (PRD) - Meeting Summarizer

## 1. PrzeglÄ…d produktu

Aplikacja "Meeting Summarizer" ma na celu automatyzacjÄ™ procesu tworzenia podsumowaĹ„ spotkaĹ„ na podstawie transkrypcji w jÄ™zyku polskim. Docelowym uĹĽytkownikiem jest osoba techniczna, taka jak programista, odpowiedzialna za dokumentowanie spotkaĹ„. Aplikacja umoĹĽliwia wczytanie pliku tekstowego z transkrypcjÄ…, edycjÄ™ transkrypcji, generowanie podsumowania za pomocÄ… LLM (Large Language Model), edycjÄ™ podsumowania oraz zapisanie transkrypcji i podsumowania w bazie danych. UĹĽytkownik ma rĂłwnieĹĽ moĹĽliwoĹ›Ä‡ przeglÄ…dania i edycji wczeĹ›niej zapisanych podsumowaĹ„. MVP (Minimum Viable Product) koncentruje siÄ™ na podstawowych funkcjonalnoĹ›ciach, zapewniajÄ…c szybkie i sprawne generowanie podsumowaĹ„.

## 2. Problem uĹĽytkownika

Osoby odpowiedzialne za prowadzenie dokumentacji spotkaĹ„ i tworzenie podsumowaĹ„ w jÄ™zyku polskim na podstawie transkrypcji w plikach tekstowych tracÄ… czas na rÄ™czne tworzenie tych podsumowaĹ„. Obecne metody sÄ… czasochĹ‚onne, monotonne i podatne na bĹ‚Ä™dy interpretacyjne. Tworzenie podsumowaĹ„ jest czasochĹ‚onne i odciÄ…ga od innych, bardziej strategicznych zadaĹ„.

## 3. Wymagania funkcjonalne

*   **Wczytywanie pliku tekstowego:** UmoĹĽliwienie wczytania pliku tekstowego (.txt) z dysku lokalnego. ObsĹ‚uga plikĂłw o rozmiarze do 1 MB.
*   **Prezentacja pliku z edycjÄ…:** WyĹ›wietlenie wczytanego tekstu transkrypcji w polu tekstowym z moĹĽliwoĹ›ciÄ… edycji (np. korekta literĂłwek, usuniÄ™cie nieistotnych fragmentĂłw). Prosta edycja tekstu (dodawanie, usuwanie, zmiana).
*   **Generowanie podsumowania (przycisk "Podsumuj"):** WywoĹ‚anie LLM (np. GPT-3.5 przez API lub lokalnej instancji ollama) po naciĹ›niÄ™ciu przycisku "Podsumuj". Prompt ma za zadanie wygenerowaÄ‡ krĂłtkie (do 500 znakĂłw) podsumowanie gĹ‚Ăłwnych tematĂłw poruszonych na spotkaniu. WyĹ›wietlanie standardowego spinnera podczas generowania podsumowania.
*   **WyĹ›wietlanie i edycja podsumowania:** WyĹ›wietlenie wygenerowanego podsumowania w polu tekstowym z moĹĽliwoĹ›ciÄ… edycji i poprawiania (uĹĽytkownik moĹĽe poprawiÄ‡ podsumowanie wygenerowane przez LLM).
*   **Zapisywanie podsumowania:** Zapisanie oryginalnej transkrypcji i wygenerowanego/zmodyfikowanego podsumowania do bazy danych (np. Supabase). Zapisanie daty utworzenia i ostatniej modyfikacji (z dokĹ‚adnoĹ›ciÄ… do minuty). Zapisanie w tekstowym pliku logĂłw: timestamp, bĹ‚Ä…d, stack (jeĹ›li dostÄ™pny) w przypadku wystÄ…pienia bĹ‚Ä™dĂłw. Zmiany w transkrypcji i podsumowaniu zapisywane po naciĹ›niÄ™ciu przycisku "Zapisz".
*   **WyĹ›wietlanie listy podsumowaĹ„:** WyĹ›wietlenie listy zapisanych podsumowaĹ„ w formie tabeli z nastÄ™pujÄ…cymi kolumnami: "Nazwa pliku", "Data utworzenia", "Data modyfikacji", "Akcje" (przycisk "Edytuj"). Lista podsumowaĹ„ sortowana po dacie utworzenia (od najnowszych). Nazwa pliku wyĹ›wietlana w caĹ‚oĹ›ci.
*   **WyĹ›wietlanie i edycja podsumowania:** Po klikniÄ™ciu "Edytuj" wyĹ›wietlenie oryginalnej transkrypcji i podsumowania w trybie do edycji (jak w "Nowe podsumowanie"). WyĹ›wietlanie ogĂłlnego komunikatu o bĹ‚Ä™dzie w okienku dialogowym w przypadku problemĂłw z LLM lub wczytywaniem pliku. Komunikat o bĹ‚Ä™dzie w okienku dialogowym z moĹĽliwoĹ›ciÄ… skopiowania do schowka.

## 4. Granice produktu

*   Brak eksportowania podsumowania do formatu Markdown.
*   Brak moĹĽliwoĹ›ci dodawania tagĂłw do podsumowaĹ„.
*   Brak wyciÄ…gania zadaĹ„ do wykonania, decyzji, otwartych kwestii. MVP skupia siÄ™ tylko na ogĂłlnym podsumowaniu tematycznym.
*   Aplikacja wymaga rÄ™cznie przygotowanej transkrypcji.
*   Brak zaawansowanego formatowania tekstu. Ograniczone do podstawowej edycji tekstu.
*   Brak wyszukiwania podsumowaĹ„ po nazwie pliku lub treĹ›ci.
*   Brak licznika znakĂłw w interfejsie edycji.
*   Aplikacja nie mierzy czasu generowania podsumowania w MVP.

## 5. Historyjki uĹĽytkownikĂłw

- US-001
- Wczytanie transkrypcji
- Jako uĹĽytkownik chcÄ™ mĂłc wczytaÄ‡ transkrypcjÄ™ spotkania z pliku TXT, aby mĂłc jÄ… przetworzyÄ‡.
- Kryteria akceptacji:
   - UĹĽytkownik moĹĽe wybraÄ‡ plik TXT z dysku lokalnego.
   - Aplikacja poprawnie wczytuje plik TXT o rozmiarze do 1 MB.
   - Wczytany tekst transkrypcji jest wyĹ›wietlany w polu tekstowym.
   - W przypadku bĹ‚Ä™du wczytywania (np. plik nie istnieje, brak uprawnieĹ„, nie jest TXT) wyĹ›wietlany jest ogĂłlny komunikat o bĹ‚Ä™dzie w okienku dialogowym, a szczegĂłĹ‚y bĹ‚Ä™du zapisywane sÄ… w logach.

- US-002
- Edycja transkrypcji
- Jako uĹĽytkownik chcÄ™ mĂłc edytowaÄ‡ transkrypcjÄ™ przed wygenerowaniem podsumowania, aby poprawiÄ‡ ewentualne bĹ‚Ä™dy i usunÄ…Ä‡ nieistotne fragmenty.
- Kryteria akceptacji:
   - UĹĽytkownik moĹĽe edytowaÄ‡ tekst w polu tekstowym zawierajÄ…cym transkrypcjÄ™.
   - UĹĽytkownik moĹĽe dodawaÄ‡, usuwaÄ‡ i zmieniaÄ‡ tekst.
   - Aplikacja obsĹ‚uguje kodowanie UTF-8.

- US-003
- Generowanie podsumowania
- Jako uĹĽytkownik chcÄ™ mĂłc wygenerowaÄ‡ podsumowanie transkrypcji za pomocÄ… LLM, aby szybko uzyskaÄ‡ streszczenie najwaĹĽniejszych tematĂłw poruszonych na spotkaniu.
- Kryteria akceptacji:
   - UĹĽytkownik moĹĽe uruchomiÄ‡ proces generowania podsumowania poprzez naciĹ›niÄ™cie przycisku "Podsumuj".
   - Podczas generowania podsumowania wyĹ›wietlany jest standardowy spinner.
   - Po zakoĹ„czeniu generowania podsumowania, wygenerowany tekst jest wyĹ›wietlany w polu tekstowym.
   - W przypadku bĹ‚Ä™du generowania podsumowania (np. problem z LLM) wyĹ›wietlany jest ogĂłlny komunikat o bĹ‚Ä™dzie w okienku dialogowym, a szczegĂłĹ‚y bĹ‚Ä™du zapisywane sÄ… w logach.

- US-004
- Edycja podsumowania
- Jako uĹĽytkownik chcÄ™ mĂłc edytowaÄ‡ podsumowanie wygenerowane przez LLM, aby doprecyzowaÄ‡ jego treĹ›Ä‡ i poprawiÄ‡ ewentualne niedoskonaĹ‚oĹ›ci.
- Kryteria akceptacji:
   - UĹĽytkownik moĹĽe edytowaÄ‡ tekst w polu tekstowym zawierajÄ…cym podsumowanie.
   - UĹĽytkownik moĹĽe dodawaÄ‡, usuwaÄ‡ i zmieniaÄ‡ tekst.

- US-005
- Zapisywanie podsumowania
- Jako uĹĽytkownik chcÄ™ mĂłc zapisaÄ‡ transkrypcjÄ™ i podsumowanie w bazie danych, aby mĂłc do nich wrĂłciÄ‡ w przyszĹ‚oĹ›ci.
- Kryteria akceptacji:
   - UĹĽytkownik moĹĽe zapisaÄ‡ transkrypcjÄ™ i podsumowanie poprzez naciĹ›niÄ™cie przycisku "Zapisz".
   - Po zapisaniu wyĹ›wietlana jest informacja o pomyĹ›lnym zapisaniu.
   - Data utworzenia i ostatniej modyfikacji (z dokĹ‚adnoĹ›ciÄ… do minuty) sÄ… zapisywane w bazie danych.
   - W przypadku bĹ‚Ä™du zapisu wyĹ›wietlany jest ogĂłlny komunikat o bĹ‚Ä™dzie w okienku dialogowym, a szczegĂłĹ‚y bĹ‚Ä™du zapisywane sÄ… w logach.

- US-006
- PrzeglÄ…danie listy podsumowaĹ„
- Jako uĹĽytkownik chcÄ™ mĂłc przeglÄ…daÄ‡ listÄ™ zapisanych podsumowaĹ„, posortowanÄ… po dacie utworzenia (od najnowszych), aby mĂłc Ĺ‚atwo znaleĹşÄ‡ potrzebne mi podsumowanie.
- Kryteria akceptacji:
   - Lista podsumowaĹ„ jest wyĹ›wietlana w formie tabeli.
   - Tabela zawiera kolumny: "Nazwa pliku", "Data utworzenia", "Data modyfikacji", "Akcje" (przycisk "Edytuj").
   - Lista jest sortowana po dacie utworzenia (od najnowszych).
   - Nazwa pliku jest wyĹ›wietlana w caĹ‚oĹ›ci.

- US-007
- Edycja istniejÄ…cego podsumowania
- Jako uĹĽytkownik chcÄ™ mĂłc edytowaÄ‡ istniejÄ…ce podsumowanie, aby wprowadziÄ‡ zmiany lub poprawki.
- Kryteria akceptacji:
   - UĹĽytkownik moĹĽe przejĹ›Ä‡ do trybu edycji podsumowania poprzez klikniÄ™cie przycisku "Edytuj" na liĹ›cie podsumowaĹ„.
   - W trybie edycji wyĹ›wietlana jest oryginalna transkrypcja i podsumowanie.
   - UĹĽytkownik moĹĽe edytowaÄ‡ transkrypcjÄ™ i podsumowanie.
   - UĹĽytkownik moĹĽe zapisaÄ‡ zmiany.

- US-008
- Bezpieczny dostÄ™p
- Jako uĹĽytkownik chcÄ™ ĹĽeby nikt niepowoĹ‚any nie miaĹ‚ dostÄ™pu do moich podsumowaĹ„.
- Kryteria akceptacji:
   - Aplikacja wymaga podstawowego uwierzytelniania.
   - Tylko zalogowany uĹĽytkownik ma moĹĽliwoĹ›Ä‡ wglÄ…du do podsumowaĹ„.

## 6. Metryki sukcesu

*   **Poprawne generowanie podsumowania:** Dla co najmniej 90% wczytanych plikĂłw aplikacja generuje podsumowanie, ktĂłre jest spĂłjne i adekwatne do treĹ›ci transkrypcji (ocena subiektywna). Oznacza to, ĹĽe podsumowanie odzwierciedla gĹ‚Ăłwne tematy poruszane w transkrypcji.
*   **Brak bĹ‚Ä™dĂłw krytycznych:** Aplikacja jest stabilna i nie generuje bĹ‚Ä™dĂłw uniemoĹĽliwiajÄ…cych jej uĹĽywanie (np. bĹ‚Ä…d zapisu do bazy danych, zawieszanie siÄ™ aplikacji). Brak zgĹ‚oszeĹ„ o krytycznych bĹ‚Ä™dach od uĹĽytkownikĂłw.
*   **Zapisywanie i odczytywanie podsumowaĹ„:** Aplikacja poprawnie zapisuje i odczytuje podsumowania z bazy danych, zachowujÄ…c integralnoĹ›Ä‡ danych.




================================================
File: .ai/summaries-curl-tests.md
================================================
# Testy Curl dla endpointa POST /api/summaries (One-liner)

Ten dokument zawiera zestaw komend `curl` do przetestowania endpointa API sĹ‚uĹĽÄ…cego do tworzenia nowych podsumowaĹ„ spotkaĹ„ w bazie danych. Endpoint przypisuje rekordy do `DEFAULT_USER_ID` i **nie wymaga** autentykacji w tej wersji MVP. KaĹĽda komenda jest w jednej linii.

## Warunki wstÄ™pne do uruchomienia testĂłw:

*   **Serwer deweloperski Astro jest uruchomiony:** Uruchom serwer aplikacji komendÄ… `npm run dev` (lub `yarn dev`). DomyĹ›lny port serwera Astro to `3003`. Komendy `curl` bÄ™dÄ… kierowane na ten adres (`http://localhost:3003`).
*   **Migracje zostaĹ‚y zastosowane:** Upewnij siÄ™, ĹĽe migracje dodajÄ…ce kolumnÄ™ `title` i usuwajÄ…ce `NOT NULL` z `notes` zostaĹ‚y pomyĹ›lnie zastosowane na lokalnej bazie (`supabase migrate dev`).
*   **DomyĹ›lny uĹĽytkownik istnieje:** Upewnij siÄ™, ĹĽe uĹĽytkownik z ID zdefiniowanym w `src/db/supabase.client.ts` (`DEFAULT_USER_ID`) istnieje w tabelach `auth.users` i `public.users`. Endpoint w trybie MVP uĹĽywa tego staĹ‚ego ID.
*   **Posiadasz zainstalowane `jq` (opcjonalnie, ale zalecane):** `jq` sĹ‚uĹĽy do formatowania wyjĹ›cia JSON. JeĹ›li go nie masz, usuĹ„ `| jq .` z koĹ„ca komend.

## Opis endpointa:

*   **Metoda HTTP:** `POST`
*   **URL Path:** `/api/summaries`
*   **Request Body (JSON):**
    ```json
    {
      "file_name": "string | null", // Optional
      "transcription": "string",     // Required
      "summary": "string",           // Required, max 500 characters
      "llm_generated": "boolean",    // Required
      "notes": "string"              // Optional
    }
    ```
*   **Success Response (201 Created):** JSON object of the created summary.
*   **Error Responses:** `400 Bad Request`, `500 Internal Server Error`. (Status `401 Unauthorized` nie powinien byÄ‡ zwracany w tej wersji implementacji).

## Testy Curl (One-liners):

UĹĽywamy `curl -s` do wyciszenia paska postÄ™pu i `| jq .` do formatowania odpowiedzi JSON.

---

### Test 1: PomyĹ›lne utworzenie podsumowania - Wszystkie wymagane pola + opcjonalne (`file_name`, `notes`) (201 Created)

**Opis:** WysyĹ‚a poprawne ciaĹ‚o ĹĽÄ…dania POST z kompletnymi danymi, w tym polami opcjonalnymi.

**Komenda:**
```bash
curl -s -X POST http://localhost:3003/api/summaries -H "Content-Type: application/json" -d '{"file_name":"Spotkanie Projektowe Q3.txt","transcription":"PeĹ‚na transkrypcja ze spotkania zespoĹ‚u z polskimi znakami: Ä…Ä™Ĺ‚ĂłĹşĹĽÄ‡Ĺ„Ĺ›.","summary":"OmĂłwiono postÄ™py w projekcie Q3. Zidentyfikowano kluczowe zadania na nastÄ™pny tydzieĹ„. PodjÄ™to decyzjÄ™ o wdroĹĽeniu nowego moduĹ‚u do koĹ„ca miesiÄ…ca.","llm_generated":true,"notes":"WaĹĽne punkty do zapamiÄ™tania: decyzja o module, zadania dla zespoĹ‚u."}' | jq .
```

**Oczekiwany wynik:** Status `201 Created` i JSON z danymi utworzonego rekordu.

---

### Test 2: PomyĹ›lne utworzenie podsumowania - Tylko wymagane pola (201 Created)

**Opis:** WysyĹ‚a poprawnych danych zawierajÄ…cych tylko minimalny zestaw wymaganych pĂłl. Pola opcjonalne (`file_name`, `notes`) sÄ… pominiÄ™te.

**Komenda:**
```bash
curl -s -X POST http://localhost:3003/api/summaries -H "Content-Type: application/json" -d '{"transcription":"KrĂłtka transkrypcja testowa z polskimi znakami.","summary":"KrĂłtkie podsumowanie testowe.","llm_generated":false}' | jq .
```

**Oczekiwany wynik:** Status `201 Created` i JSON z danymi utworzonego rekordu (file_name i notes bÄ™dÄ… null/pusty).

---

### Test 3: Brakuje wymaganego pola (`transcription`) (400 Bad Request)

**Opis:** Sprawdzenie walidacji Zod dla brakujÄ…cego wymaganego pola.

**Komenda:**
```bash
curl -s -X POST http://localhost:3003/api/summaries -H "Content-Type: application/json" -d '{"summary":"Podsumowanie bez transkrypcji.","llm_generated":true}' | jq .
```

**Oczekiwany wynik:** Status `400 Bad Request` i JSON z bĹ‚Ä™dem walidacji Zod.

---

### Test 4: Brakuje wymaganego pola (`summary`) (400 Bad Request)

**Opis:** Sprawdzenie walidacji Zod dla brakujÄ…cego wymaganego pola.

**Komenda:**
```bash
curl -s -X POST http://localhost:3003/api/summaries -H "Content-Type: application/json" -d '{"transcription":"Transkrypcja bez podsumowania.","llm_generated":false}' | jq .
```

**Oczekiwany wynik:** Status `400 Bad Request` i JSON z bĹ‚Ä™dem walidacji Zod.

---

### Test 5: Brakuje wymaganego pola (`llm_generated`) (400 Bad Request)

**Opis:** Sprawdzenie walidacji Zod dla brakujÄ…cego wymaganego pola.

**Komenda:**
```bash
curl -s -X POST http://localhost:3003/api/summaries -H "Content-Type: application/json" -d '{"transcription":"Transkrypcja.","summary":"Podsumowanie."}' | jq .
```

**Oczekiwany wynik:** Status `400 Bad Request` i JSON z bĹ‚Ä™dem walidacji Zod.

---

### Test 6: NieprawidĹ‚owy typ danych (`llm_generated` nie jest booleanem) (400 Bad Request)

**Opis:** Sprawdzenie walidacji Zod dla nieprawidĹ‚owego typu danych.

**Komenda:**
```bash
curl -s -X POST http://localhost:3003/api/summaries -H "Content-Type: application/json" -d '{"transcription":"Transkrypcja.","summary":"Podsumowanie.","llm_generated":"prawda"}' | jq .
```

**Oczekiwany wynik:** Status `400 Bad Request` i JSON z bĹ‚Ä™dem walidacji Zod.

---

### Test 7: Pole `summary` przekracza 500 znakĂłw (400 Bad Request)

**Opis:** Sprawdzenie walidacji Zod dla maksymalnej dĹ‚ugoĹ›ci pola `summary`.

**Komenda:**
```bash
curl -s -X POST http://localhost:3003/api/summaries -H "Content-Type: application/json" -d '{"transcription":"Transkrypcja.","summary":"'"$(python -c 'print('A'*501)')"'","llm_generated":true}' | jq .
```
*(Uwaga: polecenie `$(python -c 'print('A'*501)')` wymaga zainstalowanego Pythona. JeĹ›li nie masz Pythona, musisz rÄ™cznie utworzyÄ‡ JSON z podsumowaniem dĹ‚uĹĽszym niĹĽ 500 znakĂłw).*

**Oczekiwany wynik:** Status `400 Bad Request` i JSON z bĹ‚Ä™dem walidacji Zod.

---

### Test 8: CiaĹ‚o ĹĽÄ…dania nie jest poprawnym JSONem (400 Bad Request)

**Opis:** Sprawdzenie obsĹ‚ugi bĹ‚Ä™du parsowania JSON przed walidacjÄ… Zod.

**Komenda:**
```bash
curl -s -X POST http://localhost:3003/api/summaries -H "Content-Type: application/json" -d '{"transcription": "...", "summary": "...", "llm_generated": true' | jq .
```

**Oczekiwany wynik:** Status `400 Bad Request` i JSON z ogĂłlnym bĹ‚Ä™dem parsowania JSON.

---

### Test 9: Opcjonalne pole `file_name` ma nieprawidĹ‚owy typ (liczba) (400 Bad Request)

**Opis:** Sprawdzenie walidacji Zod dla nieprawidĹ‚owego typu danych w polu opcjonalnym.

**Komenda:**
```bash
curl -s -X POST http://localhost:3003/api/summaries -H "Content-Type: application/json" -d '{"transcription":"...","summary":"KrĂłtkie podsumowanie.","llm_generated":true,"file_name":123}' | jq .
```

**Oczekiwany wynik:** Status `400 Bad Request` i JSON z bĹ‚Ä™dem walidacji Zod.

---

### Test 10: Pole `notes` ma nieprawidĹ‚owy typ (liczba) (400 Bad Request)

**Opis:** Sprawdzenie walidacji Zod dla nieprawidĹ‚owego typu danych w polu opcjonalnym.

**Komenda:**
```bash
curl -s -X POST http://localhost:3003/api/summaries -H "Content-Type: application/json" -d '{"transcription":"...","summary":"KrĂłtkie podsumowanie.","llm_generated":true,"notes":456}' | jq .
```

**Oczekiwany wynik:** Status `400 Bad Request` i JSON z bĹ‚Ä™dem walidacji Zod.

---

### Test 11: BĹ‚Ä…d wewnÄ™trzny serwera (np. konflikt RLS / bĹ‚Ä…d DB) (500 Internal Server Error)

**Opis:** Testuje, jak handler API reaguje na bĹ‚Ä™dy zgĹ‚oszone przez warstwÄ™ bazy danych (np. Supabase/PostgreSQL). W trybie MVP, gdzie uĹĽywamy `DEFAULT_USER_ID` zamiast `auth.uid()`, jeĹ›li RLS jest aktywne i skonfigurowane do sprawdzania `user_id = auth.uid()`, prĂłba wstawienia rekordu z jawnie podanym `DEFAULT_USER_ID` spowoduje bĹ‚Ä…d RLS na poziomie bazy danych, ktĂłry powinien zostaÄ‡ przechwycony i zwrĂłcony jako 500.

**Komenda:** UĹĽyj poprawnego ciaĹ‚a ĹĽÄ…dania, ktĂłre przeszĹ‚o walidacjÄ™ (np. z Testu 1 lub Testu 2). BĹ‚Ä…d 500 wystÄ…pi, jeĹ›li baza danych odrzuci zapytanie INSERT.

**Komenda:**
```bash
curl -s -X POST http://localhost:3003/api/summaries -H "Content-Type: application/json" -d '{"transcription":"Test transkrypcji dla bĹ‚Ä™du DB.","summary":"Testowe podsumowanie dla bĹ‚Ä™du DB.","llm_generated":true}' | jq .
```

**Oczekiwany wynik:** Status `500 Internal Server Error` i JSON z ogĂłlnym bĹ‚Ä™dem serwera.

---



================================================
File: .ai/summaries-endpoint.md
================================================
# Plan wdroĹĽenia punktu koĹ„cowego API: GET /api/summaries

## 1. PrzeglÄ…d punktu koĹ„cowego

Punkt koĹ„cowy `GET /api/summaries` sĹ‚uĹĽy do pobierania listy podsumowaĹ„ spotkaĹ„ naleĹĽÄ…cych do uwierzytelnionego uĹĽytkownika. UmoĹĽliwia filtrowanie wynikĂłw wedĹ‚ug daty utworzenia (domyĹ›lnie ostatnie 7 dni) oraz sortowanie wedĹ‚ug daty utworzenia lub modyfikacji, w kolejnoĹ›ci rosnÄ…cej lub malejÄ…cej. Endpoint zwraca jedynie metadane podsumowaĹ„ (ID, nazwÄ™ pliku, datÄ™ utworzenia i modyfikacji), bez peĹ‚nej treĹ›ci transkrypcji, podsumowania czy notatek, zgodnie z wymaganiami widoku listy.

## 2. SzczegĂłĹ‚y ĹĽÄ…dania

- Metoda HTTP: `GET`
- Struktura URL: `/api/summaries`
- Parametry zapytania (Query Parameters):
    - Wymagane: Brak
    - Opcjonalne:
        - `sort_by`: string (domyĹ›lnie: `created_at`). Dopuszczalne wartoĹ›ci: `created_at`, `updated_at`.
        - `sort_order`: string (domyĹ›lnie: `desc`). Dopuszczalne wartoĹ›ci: `asc`, `desc`.
        - `from_dt`: string (opcjonalnie). Data/czas (ISO 8601) - filtruj od/po tej dacie utworzenia.
        - `to_dt`: string (opcjonalnie). Data/czas (ISO 8601) - filtruj przed/do tej daty utworzenia.
    - Logika filtrowania dat:
        - JeĹ›li `from_dt` i `to_dt` sÄ… pominiÄ™te, filtr to `created_at >= NOW() - INTERVAL '7 days' AND created_at <= NOW()`.
        - JeĹ›li tylko `from_dt` jest podane, filtr to `created_at >= from_dt`.
        - JeĹ›li tylko `to_dt` jest podane, filtr to `created_at <= to_dt`.
        - JeĹ›li oba sÄ… podane, filtr to `created_at >= from_dt AND created_at <= to_dt`.
- Request Body: Brak

## 3. Wykorzystywane typy

Do implementacji tego punktu koĹ„cowego niezbÄ™dne bÄ™dÄ… nastÄ™pujÄ…ce typy z pliku `type_definitions.ts`:

-   `ListSummariesCommand`: Reprezentuje strukturÄ™ parametrĂłw zapytania (query parameters) przychodzÄ…cych w ĹĽÄ…daniu. SĹ‚uĹĽy do typowania i walidacji danych wejĹ›ciowych.
-   `MeetingSummaryListEntryDto`: Reprezentuje strukturÄ™ pojedynczego obiektu podsumowania zwracanego na liĹ›cie. Odwzorowuje wybrane pola z wiersza bazy danych (`id`, `file_name`, `created_at`, `modified_at`), zmieniajÄ…c nazwÄ™ `modified_at` na `updated_at` w API response.
-   `MeetingSummaryListDto`: Reprezentuje strukturÄ™ caĹ‚ej odpowiedzi - tablicÄ™ obiektĂłw `MeetingSummaryListEntryDto`.

WewnÄ™trznie, podczas interakcji z bazÄ… danych, bÄ™dziemy wykorzystywaÄ‡ typ `Tables<"meeting_summaries">` (lub jego czÄ™Ĺ›ciowe wersje) reprezentujÄ…cy strukturÄ™ wiersza tabeli `meeting_summaries`.

## 4. SzczegĂłĹ‚y odpowiedzi

- Sukces:
    - `200 OK`: Ĺ»Ä…danie zostaĹ‚o pomyĹ›lnie przetworzone, zwracana jest lista podsumowaĹ„.
        - Body: Tablica obiektĂłw typu `MeetingSummaryListEntryDto`.
        ```json
        [
          {
            "id": "uuid",
            "file_name": "string | null",
            "created_at": "timestamp with time zone",
            "updated_at": "timestamp with time zone"
          },
          // ... more summary objects
        ]
        ```
- BĹ‚Ä™dy:
    - `400 Bad Request`: NieprawidĹ‚owe parametry zapytania (np. niepoprawny format daty, niedozwolona wartoĹ›Ä‡ `sort_by`/`sort_order`). Body powinno zawieraÄ‡ opis bĹ‚Ä™du.
    - `401 Unauthorized`: Uwierzytelnienie jest wymagane lub token jest nieprawidĹ‚owy/nieobecny. Zwracany przez Supabase Auth lub middleware backendu.
    - `500 Internal Server Error`: WystÄ…piĹ‚ nieoczekiwany bĹ‚Ä…d po stronie serwera podczas przetwarzania ĹĽÄ…dania (np. bĹ‚Ä…d bazy danych, bĹ‚Ä…d w logice aplikacji). Body *nie* powinno zawieraÄ‡ szczegĂłĹ‚Ăłw bĹ‚Ä™du serwera.

## 5. PrzepĹ‚yw danych

1.  Klient wysyĹ‚a ĹĽÄ…danie `GET /api/summaries` z opcjonalnymi parametrami zapytania.
2.  Ĺ»Ä…danie trafia do backendu aplikacji zbudowanego w oparciu o Astro/React.
3.  Middleware lub handler autentykacji (wykorzystujÄ…cy Supabase Auth) weryfikuje, czy uĹĽytkownik jest uwierzytelniony. JeĹ›li nie, zwraca `401 Unauthorized`. JeĹ›li tak, kontekst uĹĽytkownika (np. `user_id`) jest dostÄ™pny.
4.  Handler punktu koĹ„cowego parsersuje parametry zapytania z ĹĽÄ…dania HTTP i prĂłbuje je przypisaÄ‡ do obiektu zgodnego z `ListSummariesCommand`.
5.  Przeprowadzana jest walidacja parametrĂłw zapytania:
    *   Sprawdzenie, czy `sort_by` i `sort_order` majÄ… dozwolone wartoĹ›ci.
    *   Walidacja formatu `from_dt` i `to_dt` jako poprawnych ciÄ…gĂłw znakĂłw reprezentujÄ…cych datÄ™/czas (np. ISO 8601). JeĹ›li format jest nieprawidĹ‚owy, zwracany jest bĹ‚Ä…d `400 Bad Request`.
6.  Na podstawie obecnoĹ›ci `from_dt` i `to_dt`, wyznaczany jest zakres dat do filtrowania. JeĹ›li oba sÄ… puste, zakres domyĹ›lnie obejmuje ostatnie 7 dni od aktualnego czasu serwera.
7.  Handler wywoĹ‚uje metodÄ™ w warstwie serwisowej/biznesowej (np. `SummaryService.listUserSummaries`), przekazujÄ…c ID uwierzytelnionego uĹĽytkownika, wyznaczony zakres dat oraz parametry sortowania.
8.  `SummaryService` uĹĽywa klienta Supabase (lub warstwy abstrakcji bazy danych) do zbudowania zapytania SQL do tabeli `meeting_summaries`.
9.  Zapytanie SELECT wybiera kolumny `id`, `file_name`, `created_at`, `modified_at`.
10. Zapytanie stosuje filtry:
    *   DomyĹ›lny filtr `user_id = auth.uid()` jest automatycznie narzucany przez Row Level Security (RLS) w bazie danych Supabase, dziÄ™ki czemu zapytanie pobiera tylko dane naleĹĽÄ…ce do uwierzytelnionego uĹĽytkownika. Kod aplikacji *nie* powinien rÄ™cznie dodawaÄ‡ warunku `WHERE user_id = ...` jeĹ›li RLS jest poprawnie skonfigurowane i wĹ‚Ä…czone.
    *   Dodane sÄ… warunki filtrowania daty na kolumnie `created_at` (`>= from_date`, `<= to_date`) zgodnie z logikÄ… z kroku 6.
11. Zapytanie stosuje klauzulÄ™ `ORDER BY` na kolumnie wskazanej przez `sort_by` (`created_at` lub `modified_at` w DB) z kierunkiem wskazanym przez `sort_order`.
12. Zapytanie jest wykonywane na bazie danych PostgreSQL (Supabase).
13. Klient Supabase zwraca wyniki do `SummaryService`. Wszelkie bĹ‚Ä™dy bazy danych sÄ… Ĺ‚apane i traktowane jako bĹ‚Ä™dy wewnÄ™trzne serwera.
14. `SummaryService` mapuje otrzymane wiersze bazy danych na listÄ™ obiektĂłw `MeetingSummaryListEntryDto`, w szczegĂłlnoĹ›ci zmieniajÄ…c nazwÄ™ pola `modified_at` na `updated_at`.
15. Zmapowana lista jest zwracana do handlera punktu koĹ„cowego.
16. Handler punktu koĹ„cowego zwraca zmapowanÄ… listÄ™ jako odpowiedĹş JSON z kodem statusu `200 OK`. W przypadku bĹ‚Ä™du na poziomie serwisu (np. bĹ‚Ä…d DB), handler zwraca `500 Internal Server Error` po zalogowaniu bĹ‚Ä™du.

## 5. WzglÄ™dy bezpieczeĹ„stwa

-   **Uwierzytelnienie:** ObowiÄ…zkowe sprawdzenie, czy uĹĽytkownik jest uwierzytelniony. OdpowiedzialnoĹ›Ä‡ Supabase Auth i/lub middleware backendu. Nieautoryzowane ĹĽÄ…dania muszÄ… byÄ‡ odrzucane z kodem `401 Unauthorized`.
-   **Autoryzacja (RLS):** Kluczowe jest poleganie na skonfigurowanych zasadach Row Level Security (RLS) w bazie danych PostgreSQL (Supabase). Zasada `select_meeting_summaries ON meeting_summaries FOR SELECT USING (user_id = auth.uid());` musi byÄ‡ wĹ‚Ä…czona i poprawnie dziaĹ‚ajÄ…ca. Gwarantuje to, ĹĽe nawet jeĹ›li w kodzie aplikacji pojawi siÄ™ bĹ‚Ä…d lub luka, uĹĽytkownik *fizycznie* nie bÄ™dzie w stanie pobraÄ‡ danych naleĹĽÄ…cych do innych uĹĽytkownikĂłw bezpoĹ›rednio z bazy danych poprzez ten endpoint.
-   **Walidacja danych wejĹ›ciowych:** Wszystkie parametry zapytania (`sort_by`, `sort_order`, `from_dt`, `to_dt`) muszÄ… byÄ‡ dokĹ‚adnie walidowane pod kÄ…tem typu, formatu i dozwolonych wartoĹ›ci, aby zapobiec bĹ‚Ä™dom aplikacji i potencjalnym wektorom ataku (np. prĂłb SQL Injection poprzez manipulacjÄ™ sortowaniem, choÄ‡ Supabase client powinien to Ĺ‚agodziÄ‡ przez parametryzacjÄ™ zapytaĹ„). NieprawidĹ‚owe dane wejĹ›ciowe powinny skutkowaÄ‡ odpowiedziÄ… `400 Bad Request`.
-   **SQL Injection:** UĹĽycie klienta Supabase (lub innej biblioteki ORM/DB, ktĂłra poprawnie parametryzuje zapytania) jest niezbÄ™dne, aby zapobiec atakom SQL Injection. Parametry filtrowania i sortowania powinny byÄ‡ przekazywane jako parametry zapytania, a nie konkatenowane do ciÄ…gu zapytania SQL.

## 6. ObsĹ‚uga bĹ‚Ä™dĂłw

-   **NieprawidĹ‚owe parametry zapytania:** JeĹ›li parsowanie lub walidacja parametrĂłw zapytania (`sort_by`, `sort_order`, `from_dt`, `to_dt`) zakoĹ„czy siÄ™ niepowodzeniem (np. niepoprawny format daty, niedozwolona wartoĹ›Ä‡ sortowania), zwrĂłÄ‡ `400 Bad Request` z komunikatem informujÄ…cym, ktĂłry parametr jest nieprawidĹ‚owy i dlaczego.
-   **BĹ‚Ä™dy uwierzytelnienia:** Ĺ»Ä…dania bez poprawnego tokenu autoryzacyjnego powinny byÄ‡ odrzucane przez warstwÄ™ autentykacji (Supabase Auth) z kodem `401 Unauthorized`.
-   **BĹ‚Ä™dy wewnÄ™trzne serwera:** Wszelkie nieoczekiwane bĹ‚Ä™dy podczas przetwarzania ĹĽÄ…dania, takie jak bĹ‚Ä™dy poĹ‚Ä…czenia z bazÄ… danych, bĹ‚Ä™dy podczas wykonywania zapytania SQL (nie zwiÄ…zane z RLS odrzuceniem), bĹ‚Ä™dy w logice aplikacji, powinny byÄ‡:
    *   ZĹ‚apane (np. w bloku `try...catch`).
    *   SzczegĂłĹ‚owo zalogowane po stronie serwera (np. do logĂłw aplikacji, systemu monitorowania bĹ‚Ä™dĂłw; chociaĹĽ w dostarczonym schemacie nie ma "tabeli bĹ‚Ä™dĂłw", standardowe logowanie serwerowe jest kluczowe).
    *   ZwrĂłcone do klienta jako `500 Internal Server Error` bez ujawniania wewnÄ™trznych szczegĂłĹ‚Ăłw bĹ‚Ä™du.

## 7. WydajnoĹ›Ä‡

-   **Indeksy Bazy Danych:** Dostarczony schemat bazy danych zawiera niezbÄ™dne indeksy na `user_id` (`idx_meeting_summaries_user_id`) oraz `created_at` (`idx_meeting_summaries_data_utworzenia`, uwaga na rĂłĹĽnicÄ™ w nazewnictwie w schemacie vs types/API spec, ale kolumna jest ta sama). Te indeksy sÄ… kluczowe dla wydajnego filtrowania po uĹĽytkowniku i dacie utworzenia oraz sortowania. W przypadku sortowania po `modified_at`, rĂłwnieĹĽ powinien istnieÄ‡ indeks na tej kolumnie, aby zapewniÄ‡ optymalnÄ… wydajnoĹ›Ä‡. (Schemat nie wymienia indeksu na `modified_at`, co moĹĽe byÄ‡ potencjalnym wÄ…skim gardĹ‚em przy sortowaniu wedĹ‚ug daty modyfikacji). *[NaleĹĽy dodaÄ‡ indeks na `meeting_summaries(modified_at)` dla optymalizacji sortowania przez `updated_at`/`modified_at`]*
-   **RLS:** WĹ‚Ä…czenie RLS moĹĽe wprowadzaÄ‡ niewielki narzut na wydajnoĹ›Ä‡, ale jest to akceptowalna cena za zapewnienie bezpieczeĹ„stwa danych na poziomie bazy.
-   **Zakres Danych:** Endpoint zwraca tylko niezbÄ™dne metadane, co minimalizuje iloĹ›Ä‡ danych przesyĹ‚anych przez sieÄ‡ i przetwarzanych w bazie danych. To jest zgodne z zasadÄ… minimalizacji danych w widoku listy.
-   **Brak paginacji:** Obecna specyfikacja nie przewiduje paginacji. Dla uĹĽytkownikĂłw z bardzo duĹĽÄ… liczbÄ… podsumowaĹ„ (tysiÄ…ce), zwracanie caĹ‚ej listy naraz moĹĽe staÄ‡ siÄ™ problemem wydajnoĹ›ciowym i pamiÄ™ciowym na serwerze i w przeglÄ…darce klienta. W przyszĹ‚oĹ›ci naleĹĽy rozwaĹĽyÄ‡ dodanie parametrĂłw paginacji (np. `limit`, `offset` lub cursor-based pagination).

## 8. Etapy wdroĹĽenia

1.  **Definicja trasy:** UtwĂłrz plik/moduĹ‚ dla handlera API `GET /api/summaries` w strukturze projektu (np. w katalogu `pages/api` w Astro/Next.js, jeĹ›li uĹĽywana jest architektura serverless functions, lub w odpowiednim miejscu frameworka backendowego).
2.  **Implementacja walidacji:** Dodaj logikÄ™ parsowania i walidacji parametrĂłw zapytania (queryString) w handlerze, uĹĽywajÄ…c typu `ListSummariesCommand`. Zastosuj walidacjÄ™ formatu daty i dozwolonych wartoĹ›ci dla `sort_by`/`sort_order`. ZwrĂłÄ‡ `400 Bad Request` w przypadku bĹ‚Ä™du walidacji.
3.  **Implementacja logiki daty domyĹ›lnej:** W handlerze, na podstawie obecnoĹ›ci `from_dt` i `to_dt`, zaimplementuj logikÄ™ wyznaczania koĹ„cowego zakresu dat filtrowania, w tym domyĹ›lnych ostatnich 7 dni, jeĹ›li oba parametry sÄ… pominiÄ™te. Konwertuj stringi dat na odpowiednie typy danych (np. `Date` objects).
4.  **Utworzenie/aktualizacja `SummaryService`:** JeĹ›li nie istnieje, utwĂłrz klasÄ™ lub moduĹ‚ `SummaryService`. Dodaj publicznÄ… metodÄ™ (np. `listUserSummaries`) przyjmujÄ…cÄ… ID uĹĽytkownika, wyznaczony zakres dat filtrowania i parametry sortowania.
5.  **Interakcja z bazÄ… danych (Supabase Client):** WewnÄ…trz `SummaryService.listUserSummaries`:
    *   UĹĽyj Supabase client, upewniajÄ…c siÄ™, ĹĽe jest zainicjowany w kontekĹ›cie uwierzytelnionego uĹĽytkownika, tak aby RLS dziaĹ‚aĹ‚o poprawnie.
    *   Skonstruuj zapytanie SELECT na tabeli `meeting_summaries`, wybierajÄ…c kolumny `id`, `file_name`, `created_at`, `modified_at`.
    *   Dodaj klauzule `WHERE` dla filtrowania daty utworzenia (`created_at >= from_date` i/lub `created_at <= to_date`).
    *   Dodaj klauzulÄ™ `ORDER BY` na odpowiedniej kolumnie (`created_at` lub `modified_at`) i kierunku (`asc` lub `desc`). PamiÄ™taj, ĹĽe `updated_at` w API odpowiada `modified_at` w DB.
    *   Wykonaj zapytanie.
6.  **Mapowanie wynikĂłw:** W `SummaryService` (lub w handlerze po otrzymaniu wynikĂłw), zmapuj wiersze bazy danych na strukturÄ™ `MeetingSummaryListEntryDto`, zmieniajÄ…c nazwÄ™ pola `modified_at` na `updated_at`.
7.  **ObsĹ‚uga bĹ‚Ä™dĂłw serwisu/DB:** W `SummaryService` i handlerze, zaimplementuj bloki `try...catch` do Ĺ‚apania potencjalnych bĹ‚Ä™dĂłw podczas interakcji z bazÄ… danych. Zalecane jest logowanie tych bĹ‚Ä™dĂłw po stronie serwera.
8.  **Zwracanie odpowiedzi:** W handlerze, jeĹ›li zapytanie zakoĹ„czyĹ‚o siÄ™ sukcesem, zwrĂłÄ‡ zmapowanÄ… listÄ™ jako odpowiedĹş JSON z kodem statusu `200 OK`. JeĹ›li wystÄ…piĹ‚ bĹ‚Ä…d zĹ‚apany w `try...catch`, zwrĂłÄ‡ `500 Internal Server Error`.
9.  **Implementacja autentykacji:** Upewnij siÄ™, ĹĽe warstwa autentykacji (middleware/guard) jest poprawnie skonfigurowana dla tej trasy i odrzuca nieautoryzowane ĹĽÄ…dania z kodem `401`.
10. **Testowanie:** Napisz testy jednostkowe dla logiki walidacji parametrĂłw i logiki daty domyĹ›lnej. Napisz testy integracyjne dla handlera API i `SummaryService`, symulujÄ…ce rĂłĹĽne scenariusze (sukces z rĂłĹĽnymi parametrami, brak parametrĂłw, niepoprawne parametry, bĹ‚Ä…d DB, brak autentykacji).
11. **WdroĹĽenie RLS:** Upewnij siÄ™, ĹĽe zasada RLS `select_meeting_summaries` na tabeli `meeting_summaries` jest wĹ‚Ä…czona w konfiguracji Supabase.
12. **Dodanie indeksu (jeĹ›li nie istnieje):** WdroĹĽenie indeksu na `meeting_summaries(modified_at)` w bazie danych dla lepszej wydajnoĹ›ci sortowania po tej kolumnie.
13. **Refaktoryzacja i przeglÄ…d kodu:** Przejrzyj zaimplementowany kod, upewnij siÄ™, ĹĽe jest zgodny ze standardami projektu, czysty i Ĺ‚atwy do zrozumienia.
14. **WdroĹĽenie i monitorowanie:** WdrĂłĹĽ zmiany na Ĺ›rodowisku testowym/produkcyjnym i monitoruj logi pod kÄ…tem bĹ‚Ä™dĂłw.


================================================
File: .ai/tech-stack.md
================================================
## Tech Stack - Meeting Summarizer

**GĹ‚Ăłwny cel:** Szybkie tworzenie aplikacji webowej do podsumowywania transkrypcji spotkaĹ„ w jÄ™zyku polskim.

**Kluczowe technologie:**

*   **Frontend:**
    *   **Astro.js:**  Framework do budowy szybkich stron z minimalnym JavaScript.
    *   **React:**  Biblioteka do budowy interfejsu uĹĽytkownika (komponenty).
    *   **Tailwind CSS:**  Utility-first framework CSS do szybkiego stylowania.
    *   **Lucide React:** Biblioteka ikon.
*   **Backend & Baza danych:**
    *   **Supabase:** Backend-as-a-Service (BaaS) - autentykacja, baza danych PostgreSQL.
*   **Inne:**
    *   **LLM API (np. GPT-3.5):**  Generowanie podsumowaĹ„ (alternatywnie lokalne LLM jak ollama).
    *   **ESLint/Prettier:**  Linting i formatowanie kodu.

**Zalety:**

*   Szybki development (Astro, React, Tailwind).
*   SkalowalnoĹ›Ä‡ (React, Astro, Supabase).
*   Relatywnie niski koszt poczÄ…tkowy (open-source, darmowy plan Supabase).
*   Autentykacja i baza danych "od rÄ™ki" (Supabase).

**Do rozwaĹĽenia/Optymalizacja:**

*   Koszty LLM API (optymalizacja promptĂłw, rozwaĹĽenie lokalnego LLM).
*   BezpieczeĹ„stwo (konfiguracja autentykacji Supabase, ochrona przed atakami).
*   Testowanie (brak frameworku testowego).
*   Aktualizacja przestarzaĹ‚ych zaleĹĽnoĹ›ci.
*   Monitorowanie logĂłw i obsĹ‚uga bĹ‚Ä™dĂłw.



================================================
File: .ai/ui-plan.md
================================================
# Architektura UI dla Meeting Summarizer

## 1. PrzeglÄ…d struktury UI

Architektura interfejsu uĹĽytkownika dla Meeting Summarizer MVP wykorzystuje minimalistyczny ukĹ‚ad strony z globalnym nagĹ‚Ăłwkiem (topbar) zawierajÄ…cym nawigacjÄ™, ktĂłry jest widoczny na stronach wymagajÄ…cych uwierzytelnienia. GĹ‚Ăłwny obszar zawartoĹ›ci pod topbarem dynamicznie Ĺ‚aduje widoki (Lista PodsumowaĹ„, Formularz Podsumowania - Tworzenie/Edycja). Strona logowania stanowi odrÄ™bny widok bez globalnej nawigacji. Aplikacja zbudowana jest z wykorzystaniem Astro do routingu i stron, a interaktywne czÄ™Ĺ›ci (widoki listy i formularza) sÄ… implementowane w React, stylizowane za pomocÄ… Tailwind CSS i opierajÄ… siÄ™ na kluczowych komponentach biblioteki shadcn/ui. Komunikacja z backendem odbywa siÄ™ poprzez REST API. ZarzÄ…dzanie stanem widokĂłw realizowane jest przy uĹĽyciu hookĂłw Reacta (`useState`, `useEffect`). Krytyczne bĹ‚Ä™dy API sÄ… wyĹ›wietlane inline w kontekĹ›cie akcji, ktĂłra je wywoĹ‚aĹ‚a. Komunikaty sukcesu oraz bĹ‚Ä™dy walidacji frontendowej (np. rozmiar pliku) sÄ… prezentowane uĹĽytkownikowi w formie globalnych powiadomieĹ„ "toast" (`Toast`) z shadcn/ui. Uwierzytelnienie uĹĽytkownika jest obsĹ‚ugiwane przez Supabase Auth z wykorzystaniem JWT (zarzÄ…dzane przez Supabase SDK) i egzekwowane na poziomie frontendowym przez sprawdzanie sesji Supabase przed zaĹ‚adowaniem chronionych widokĂłw.

## 2. Lista widokĂłw

**Nazwa widoku:** Strona Logowania

*   **ĹšcieĹĽka widoku:** `/login`
*   **GĹ‚Ăłwny cel:** UmoĹĽliwienie uĹĽytkownikowi zalogowania siÄ™ do aplikacji.
*   **Kluczowe informacje do wyĹ›wietlenia:** Formularz z polami na email i hasĹ‚o. Ewentualny komunikat o bĹ‚Ä™dzie logowania (inline w formularzu).
*   **Kluczowe komponenty widoku:**
    *   Formularz (`<form>`).
    *   Pole tekstowe Email (`Input` z `Label`, shadcn/ui).
    *   Pole hasĹ‚a (`Input` z `Label`, shadcn/ui).
    *   Przycisk "Zaloguj" (`Button`, shadcn/ui).
    *   Obszar wyĹ›wietlania bĹ‚Ä™dĂłw logowania (np. `<p class="text-red-500">`) inline w formularzu.
*   **UX, dostÄ™pnoĹ›Ä‡ i wzglÄ™dy bezpieczeĹ„stwa:** Prosty, zrozumiaĹ‚y formularz. Pola z odpowiednimi etykietami (`Label` dla dostÄ™pnoĹ›ci). Przycisk submit. BezpieczeĹ„stwo: Formularz przesyĹ‚a dane logowania do API Supabase; frontend nie przechowuje poĹ›wiadczeĹ„. Widok nie zawiera globalnej nawigacji. BĹ‚Ä™dy logowania sÄ… wyĹ›wietlane bezpoĹ›rednio w kontekĹ›cie formularza.

**Nazwa widoku:** Strona Listy PodsumowaĹ„

*   **ĹšcieĹĽka widoku:** `/summaries`
*   **GĹ‚Ăłwny cel:** WyĹ›wietlenie listy zapisanych podsumowaĹ„ uĹĽytkownika, umoĹĽliwienie filtrowania/sortowania oraz nawigacji do widoku edycji lub tworzenia nowego podsumowania.
*   **Kluczowe informacje do wyĹ›wietlenia:** Tabela podsumowaĹ„ z kolumnami "Nazwa pliku", "Data utworzenia", "Data modyfikacji", "Akcje". Pola do filtrowania listy po zakresie dat utworzenia. Przycisk do tworzenia nowego podsumowania. WskaĹşniki sortowania w nagĹ‚Ăłwkach kolumn. Ewentualny komunikat o bĹ‚Ä™dzie Ĺ‚adowania listy (inline).
*   **Kluczowe komponenty widoku:**
    *   Globalny Topbar (zawiera `NavigationMenu` z shadcn/ui).
    *   Kontener do filtrowania dat (`div` z ukĹ‚adem flex).
    *   Pole daty "Od" (`Input type="date"` z `Label`, shadcn/ui).
    *   Pole daty "Do" (`Input type="date"` z `Label`, shadcn/ui).
    *   Przycisk "Filtruj" (`Button`, shadcn/ui).
    *   Przycisk "Nowe podsumowanie" (`Button`, shadcn/ui, umieszczony w prawym gĂłrnym rogu sekcji listy jako dodatkowy skrĂłt).
    *   Tabela danych (`Table`, shadcn/ui).
    *   NagĹ‚Ăłwki tabeli (`<th>`) z moĹĽliwoĹ›ciÄ… klikniÄ™cia dla sortowania dat, zawierajÄ…ce wskaĹşnik sortowania (ikonÄ™).
    *   Wiersze tabeli (`<tr>`) wyĹ›wietlajÄ…ce dane podsumowaĹ„.
    *   Przycisk "Edytuj" (`Button`, shadcn/ui) w kolumnie "Akcje" dla kaĹĽdego wiersza.
    *   Spinner Ĺ‚adowania danych tabeli.
    *   Komunikat o pustej liĹ›cie podsumowaĹ„.
    *   Obszar wyĹ›wietlania bĹ‚Ä™dĂłw Ĺ‚adowania listy (np. `<p class="text-red-500">`) inline, np. nad tabelÄ….
*   **UX, dostÄ™pnoĹ›Ä‡ i wzglÄ™dy bezpieczeĹ„stwa:** Tabela zapewnia czytelny przeglÄ…d danych. Sortowanie i filtrowanie uĹ‚atwiajÄ… znalezienie potrzebnego podsumowania. Przyciski "Edytuj" zapewniajÄ… bezpoĹ›redni dostÄ™p do detali. Przycisk "Nowe podsumowanie" jest Ĺ‚atwo dostÄ™pny. BĹ‚Ä™dy sÄ… wyĹ›wietlane inline, co uĹ‚atwia powiÄ…zanie bĹ‚Ä™du z kontekstem tabeli. DostÄ™pnoĹ›Ä‡: Tabele z poprawnÄ… semantykÄ…. BezpieczeĹ„stwo: Dane sÄ… pobierane tylko dla zalogowanego uĹĽytkownika za pomocÄ… API chronionego RLS. Widok chroniony, wymaga uwierzytelnienia.

**Nazwa widoku:** Formularz Podsumowania (Tworzenie / Edycja)

*   **ĹšcieĹĽka widoku:** `/create` (Tworzenie), `/edit/:id` (Edycja)
*   **GĹ‚Ăłwny cel:** UmoĹĽliwienie wczytania transkrypcji, jej edycji, wygenerowania podsumowania, edycji podsumowania i zapisania caĹ‚oĹ›ci.
*   **Kluczowe informacje do wyĹ›wietlenia:** Pole tekstowe na transkrypcjÄ™, pole tekstowe na podsumowanie. Kontrolka wczytywania pliku. Przyciski akcji ("Podsumuj", "Zapisz", "Anuluj"). Nazwa pliku (tylko w trybie edycji). Komunikaty o bĹ‚Ä™dach LLM lub zapisu (inline).
*   **Kluczowe komponenty widoku:**
    *   Globalny Topbar (zawiera `NavigationMenu` z shadcn/ui).
    *   Kontener formularza (np. `div`).
    *   Sekcja kontroli wczytywania pliku.
    *   Wizualnie ukryty input pliku (`<input type="file">`, `accept=".txt"`).
    *   Stylizowana etykieta (`<label>`) dla inputu pliku, wyglÄ…dajÄ…ca jak przycisk "Wczytaj plik TXT (max 1 MB)" (wykorzystanie stylĂłw `Button` i `Label` z shadcn/ui).
    *   WyĹ›wietlanie nazwy wczytanego pliku.
    *   Pole tekstowe Transkrypcja (np. `Textarea`-like, shadcn/ui stylizacja).
    *   Pole tekstowe Podsumowanie (np. `Textarea`-like, shadcn/ui stylizacja).
    *   Sekcja przyciskĂłw akcji (`div` z `justify-end`).
    *   Przycisk "Podsumuj" (`Button`, shadcn/ui, wyĹ‚Ä…czony gdy transkrypcja pusta, ze spinnerem podczas Ĺ‚adowania).
    *   Przycisk "Zapisz" (`Button`, shadcn/ui, wyĹ‚Ä…czony gdy podsumowanie puste, ze spinnerem podczas Ĺ‚adowania).
    *   Przycisk "Anuluj" (`Button`, shadcn/ui).
    *   Stopka w trybie edycji wyĹ›wietlajÄ…ca nazwÄ™ pliku.
    *   Obszar wyĹ›wietlania bĹ‚Ä™dĂłw (np. `<p class="text-red-500">`) inline w obszarze formularza, np. nad przyciskami akcji, lub specyficznie pod przyciskiem "Podsumuj" dla bĹ‚Ä™dĂłw LLM.
    *   Globalne Powiadomienia Toast (`Toast`, shadcn/ui) do potwierdzeĹ„ zapisu i bĹ‚Ä™dĂłw walidacji rozmiaru pliku.
*   **UX, dostÄ™pnoĹ›Ä‡ i wzglÄ™dy bezpieczeĹ„stwa:** WyraĹşne pola do wprowadzania tekstu. Statusy przyciskĂłw informujÄ…ce o moĹĽliwoĹ›ci wykonania akcji. Spinner informujÄ…cy o trwajÄ…cych operacjach. Przycisk "Anuluj" umoĹĽliwia wyjĹ›cie bez zapisu. BĹ‚Ä™dy API wyĹ›wietlane sÄ… inline, w kontekĹ›cie akcji, ktĂłra je wywoĹ‚aĹ‚a (np. podsumowanie, zapis), co uĹ‚atwia uĹĽytkownikowi zrozumienie problemu. Toast dla potwierdzeĹ„ jest mniej inwazyjny. DostÄ™pnoĹ›Ä‡: Semantyczne etykiety (`Label`), obsĹ‚uga klawiatury (zapewniana przez shadcn/ui). BezpieczeĹ„stwo: Dane przesyĹ‚ane do API podlegajÄ… walidacji i RLS. Frontendowa walidacja rozmiaru pliku zapobiega wysyĹ‚aniu zbyt duĹĽych danych. Widok chroniony, wymaga uwierzytelnienia.

## 3. Mapa podrĂłĹĽy uĹĽytkownika

GĹ‚Ăłwna podrĂłĹĽ uĹĽytkownika w aplikacji Meeting Summarizer wyglÄ…da nastÄ™pujÄ…co:

1.  **WejĹ›cie do aplikacji / Uwierzytelnienie:** UĹĽytkownik wchodzi na adres aplikacji. Strony `/summaries`, `/create`, `/edit/:id` sÄ… chronione. JeĹ›li uĹĽytkownik nie jest zalogowany (brak aktywnej sesji Supabase), jest automatycznie przekierowywany na stronÄ™ `/login`.
2.  **Logowanie:** Na stronie `/login`, uĹĽytkownik podaje email i hasĹ‚o, a nastÄ™pnie klika "Zaloguj". W przypadku sukcesu (Supabase SDK potwierdza sesjÄ™), nastÄ™puje przekierowanie na `/summaries`. W przypadku bĹ‚Ä™du logowania, komunikat o bĹ‚Ä™dzie jest wyĹ›wietlany inline w obszarze formularza logowania.
3.  **PrzeglÄ…danie listy:** Po zalogowaniu, uĹĽytkownik lÄ…duje na stronie `/summaries`. Nad gĹ‚Ăłwnym kontentem widzi topbar nawigacyjny. Widzi tabelÄ™ ze swoimi zapisanymi podsumowaniami, domyĹ›lnie posortowanÄ… od najnowszych. MoĹĽe filtrowaÄ‡ listÄ™ wedĹ‚ug daty utworzenia za pomocÄ… pĂłl "Od" i "Do" i przycisku "Filtruj". MoĹĽe rĂłwnieĹĽ kliknÄ…Ä‡ nagĹ‚Ăłwki kolumn "Data utworzenia" i "Data modyfikacji" aby zmieniÄ‡ sortowanie listy. Z topbara moĹĽe przejĹ›Ä‡ do "Nowe podsumowanie" lub "Wyloguj". JeĹ›li Ĺ‚adowanie listy zakoĹ„czy siÄ™ bĹ‚Ä™dem API, komunikat o bĹ‚Ä™dzie jest wyĹ›wietlany inline, np. nad tabelÄ….
4.  **Tworzenie nowego podsumowania:** Z poziomu listy `/summaries` (klikajÄ…c przycisk obok tabeli) lub z topbara (klikajÄ…c link "Nowe podsumowanie"), uĹĽytkownik przechodzi na formularz podsumowania pod Ĺ›cieĹĽkÄ… `/create`.
    *   Na formularzu `/create`, uĹĽytkownik klika "Wczytaj plik TXT..." aby wybraÄ‡ plik z dysku. Tekst z pliku pojawia siÄ™ w polu "Transkrypcja". JeĹ›li plik jest za duĹĽy, wyĹ›wietlany jest toast z bĹ‚Ä™dem.
    *   (Opcjonalnie) UĹĽytkownik edytuje tekst w polu "Transkrypcja".
    *   UĹĽytkownik klika "Podsumuj" (jeĹ›li pole Transkrypcja nie jest puste). Pojawia siÄ™ spinner, API LLM (`POST /api/generate-summary`) jest wywoĹ‚ywane. Po zakoĹ„czeniu, wygenerowany tekst pojawia siÄ™ w polu "Podsumowanie". W przypadku bĹ‚Ä™du API/LLM, komunikat o bĹ‚Ä™dzie jest wyĹ›wietlany inline, np. pod przyciskiem "Podsumuj".
    *   (Opcjonalnie) UĹĽytkownik edytuje tekst w polu "Podsumowanie".
    *   UĹĽytkownik klika "Zapisz" (jeĹ›li pole Podsumowanie nie jest puste). Pojawia siÄ™ spinner, API `POST /api/summaries` jest wywoĹ‚ywane. Po sukcesie, wyĹ›wietlany jest toast "Zmiany zapisane" i uĹĽytkownik jest przekierowywany z powrotem na `/summaries`. W przypadku bĹ‚Ä™du API, komunikat o bĹ‚Ä™dzie jest wyĹ›wietlany inline, np. nad przyciskami akcji formularza.
    *   Alternatywnie, uĹĽytkownik klika "Anuluj" (lub link "Moje podsumowania" w topbarze) aby wrĂłciÄ‡ do `/summaries` bez zapisywania.
5.  **Edycja istniejÄ…cego podsumowania:** Z poziomu listy `/summaries`, uĹĽytkownik klika przycisk "Edytuj" przy wybranym podsumowaniu. Zostaje przekierowany na formularz podsumowania pod Ĺ›cieĹĽkÄ… `/edit/:id`.
    *   Na formularzu `/edit/:id`, dane (transkrypcja, podsumowanie) sÄ… pobierane z API `GET /api/summaries/{id}` i wyĹ›wietlane w polach tekstowych. Nazwa pliku jest wyĹ›wietlana w stopce. Widoczny jest topbar nawigacyjny. W przypadku bĹ‚Ä™du Ĺ‚adowania danych podsumowania, komunikat o bĹ‚Ä™dzie jest wyĹ›wietlany inline, np. na gĂłrze formularza.
    *   UĹĽytkownik edytuje tekst w polach "Transkrypcja" lub "Podsumowanie". Przycisk "Podsumuj" jest dostÄ™pny, jeĹ›li uĹĽytkownik chce ponownie wygenerowaÄ‡ podsumowanie po zmianach w transkrypcji.
    *   UĹĽytkownik klika "Zapisz" (jeĹ›li pole Podsumowanie nie jest puste). Pojawia siÄ™ spinner, API `PUT /api/summaries/{id}` jest wywoĹ‚ywane. Po sukcesie, wyĹ›wietlany jest toast "Zmiany zapisane" i uĹĽytkownik jest przekierowywany z powrotem na `/summaries`. W przypadku bĹ‚Ä™du API, komunikat o bĹ‚Ä™dzie jest wyĹ›wietlany inline, np. nad przyciskami akcji formularza.
    *   Alternatywnie, uĹĽytkownik klika "Anuluj" (lub link "Moje podsumowania" w topbarze) aby wrĂłciÄ‡ do `/summaries` bez zapisywania.
6.  **Wylogowanie:** Z dowolnej strony z widocznym topbarem, uĹĽytkownik klika "Wyloguj". Supabase SDK obsĹ‚uguje wylogowanie, a uĹĽytkownik jest przekierowywany na stronÄ™ `/login`.

## 4. UkĹ‚ad i struktura nawigacji

UkĹ‚ad strony skĹ‚ada siÄ™ z:
1.  **Globalnego Topbara:** Widoczny na wszystkich chronionych stronach (`/summaries`, `/create`, `/edit/:id`). Zawiera komponent `NavigationMenu` z shadcn/ui, z linkami do "Moje podsumowania" (`/summaries`) i "Nowe podsumowanie" (`/create`), oraz przyciskiem/linkiem "Wyloguj". Zapewnia spĂłjny sposĂłb poruszania siÄ™ po gĹ‚Ăłwnych sekcjach aplikacji po zalogowaniu. Strona logowania `/login` nie zawiera topbara.
2.  **GĹ‚Ăłwnego Obszaru ZawartoĹ›ci:** Znajduje siÄ™ poniĹĽej topbara (na chronionych stronach) lub wypeĹ‚nia caĹ‚Ä… wysokoĹ›Ä‡ (na stronie logowania). Renderuje aktualnie aktywny widok (Strona Logowania, Lista PodsumowaĹ„ lub Formularz Podsumowania). Jego zawartoĹ›Ä‡ zmienia siÄ™ w zaleĹĽnoĹ›ci od aktualnej Ĺ›cieĹĽki URL. Obszar ten zawiera rĂłwnieĹĽ miejsca na wyĹ›wietlanie inline komunikatĂłw o bĹ‚Ä™dach specyficznych dla danego widoku.
3.  **Globalnych KomponentĂłw UI:** Powiadomienia Toast (`Toast`) sÄ… renderowane na najwyĹĽszym poziomie aplikacji (np. w komponencie Layout), dziÄ™ki czemu mogÄ… byÄ‡ wywoĹ‚ywane z dowolnego miejsca w aplikacji i pojawiaÄ‡ siÄ™ niezaleĹĽnie od aktualnie wyĹ›wietlanego widoku, nie przerywajÄ…c interakcji (dla komunikatĂłw nietrwaĹ‚ych i niekrytycznych). Modal BĹ‚Ä™dĂłw (`Dialog`/`AlertDialog`) nie jest wykorzystywany dla krytycznych bĹ‚Ä™dĂłw API w MVP, ale moĹĽe byÄ‡ dostÄ™pny w kodzie jako narzÄ™dzie do innych celĂłw modalnych w przyszĹ‚oĹ›ci.

Struktura nawigacji opiera siÄ™ na routingu Astro:
*   **`/login`:** Publiczny punkt wejĹ›cia/wyjĹ›cia do aplikacji. Brak topbara.
*   **`/summaries`:** GĹ‚Ăłwny widok po zalogowaniu. DostÄ™pny poprzez bezpoĹ›redni URL po uwierzytelnieniu lub klikniÄ™cie "Moje podsumowania" w topbarze lub powrĂłt z formularza. Zawiera kontekstowe przyciski akcji ("Edytuj", "Nowe podsumowanie") i pola filtrowania/sortowania.
*   **`/create`:** Widok formularza do tworzenia. DostÄ™pny poprzez klikniÄ™cie "Nowe podsumowanie" na liĹ›cie lub w topbarze. Zawiera kontekstowe przyciski akcji ("Podsumuj", "Zapisz", "Anuluj").
*   **`/edit/:id`:** Widok formularza do edycji. DostÄ™pny poprzez klikniÄ™cie "Edytuj" na liĹ›cie. Zawiera kontekstowe przyciski akcji ("Podsumuj", "Zapisz", "Anuluj").

Uwierzytelnienie jest egzekwowane przez sprawdzenie sesji Supabase na poziomie stron Astro (`.astro`) dla chronionych tras.

## 5. Kluczowe komponenty

W architekturze UI wykorzystane zostanÄ… nastÄ™pujÄ…ce kluczowe komponenty, w wiÄ™kszoĹ›ci pochodzÄ…ce z biblioteki shadcn/ui, w celu zapewnienia spĂłjnoĹ›ci i przyspieszenia rozwoju:

*   **NavigationMenu (`shadcn/ui`):** GĹ‚Ăłwny komponent topbara nawigacyjnego, zawierajÄ…cy linki do kluczowych sekcji aplikacji po zalogowaniu oraz opcjÄ™ wylogowania.
*   **Button (`shadcn/ui`):** Wykorzystywany dla wszystkich interaktywnych przyciskĂłw akcji w aplikacji (Loguj, Wczytaj plik - jako styl dla labela, Podsumuj, Zapisz, Anuluj, Filtruj, Nowe podsumowanie, Edytuj, Wyloguj). Wspiera stany aktywny/nieaktywny (`disabled`) oraz wizualizacjÄ™ Ĺ‚adowania (np. poprzez spinner).
*   **Input / Textarea (`shadcn/ui`-like stylizacja):** Podstawowe komponenty dla pĂłl tekstowych (email, hasĹ‚o, daty filtrowania) oraz obszarĂłw tekstowych dla transkrypcji i podsumowania. WspierajÄ… podstawowÄ… edycjÄ™ tekstu.
*   **Label (`shadcn/ui`):** UĹĽywane do etykietowania pĂłl formularza i inputu pliku, poprawiajÄ…c dostÄ™pnoĹ›Ä‡ i powiÄ…zanie etykiety z kontrolkÄ… formularza.
*   **Table (`shadcn/ui`):** Komponent do wyĹ›wietlania danych w formie tabelarycznej na stronie listy podsumowaĹ„, wĹ‚Ä…czajÄ…c sortowalne nagĹ‚Ăłwki (z ikonami) i wiersze z akcjami (przycisk "Edytuj").
*   **Inline Error Display Element:** Generyczny element (np. `<p>` lub `<div>` z klasÄ… `text-red-500`) renderowany warunkowo wewnÄ…trz widoku, w pobliĹĽu akcji lub sekcji, ktĂłra wywoĹ‚aĹ‚a krytyczny bĹ‚Ä…d API (np. pod przyciskiem "Podsumuj", nad przyciskami "Zapisz"/"Anuluj", nad tabelÄ… listy). Wykorzystuje lokalny stan bĹ‚Ä™du komponentu.
*   **Toast (`shadcn/ui`):** Komponent systemu powiadomieĹ„ typu "toast", uĹĽywany do krĂłtkotrwaĹ‚ych, nietrwaĹ‚ych komunikatĂłw, takich jak potwierdzenie pomyĹ›lnego zapisu ("Zmiany zapisane") czy bĹ‚Ä…d walidacji rozmiaru pliku ("Plik jest za duĹĽy (max 1 MB)"). ZarzÄ…dzany globalnie (np. przez Context API).
*   **Spinner:** Wizualny wskaĹşnik Ĺ‚adowania/przetwarzania, uĹĽywany podczas operacji wymagajÄ…cych czasu (np. generowanie podsumowania, zapis, Ĺ‚adowanie danych listy, logowanie). MoĹĽe byÄ‡ zintegrowany w komponenty `Button`.
*   **File Input Control:** Niestandardowa kontrolka UI skĹ‚adajÄ…ca siÄ™ z wizualnie ukrytego `<input type="file">` i stylizowanego elementu `<label>` wyglÄ…dajÄ…cego jak przycisk (`Button`), wraz z logikÄ… wyĹ›wietlania nazwy wybranego pliku i frontendowÄ… walidacjÄ… rozmiaru pliku (do 1 MB).


================================================
File: .ai/ui-session.md
================================================
<conversation_summary>
<decisions>
1.  Minimalistyczny ukĹ‚ad strony z globalnym topbarem nawigacyjnym na stronach chronionych i dynamicznym obszarem zawartoĹ›ci dla widokĂłw listy i edycji. Strona logowania bez topbara.
2.  Standardowy `<input type="file">` ukryty wizualnie, z klikalnym elementem `<label>` stylizowanym jako przycisk "Wczytaj plik TXT (max 1 MB)". Nazwa pliku bÄ™dzie wyĹ›wietlana po wczytaniu. Walidacja rozmiaru pliku do 1 MB zostanie zaimplementowana na frontendzie.
3.  Przyciski akcji ("Podsumuj", "Zapisz") i "Anuluj" zostanÄ… umieszczone na dole ekranu edycji/tworzenia, wyrĂłwnane do prawej. Przycisk "Anuluj" nie wymaga potwierdzenia.
4.  Przyciski "Podsumuj" (jeĹ›li transkrypcja pusta) i "Zapisz" (jeĹ›li podsumowanie puste) powinny byÄ‡ wyszarzone (nieaktywne) wizualnie (klasy Tailwind `opacity-50 cursor-not-allowed`).
5.  **Krytyczne bĹ‚Ä™dy API (np. bĹ‚Ä…d LLM, bĹ‚Ä…d zapisu do bazy danych, bĹ‚Ä…d wczytywania podsumowania) bÄ™dÄ… wyĹ›wietlane inline w obszarze widoku, w ktĂłrym wystÄ…piĹ‚y (np. w pobliĹĽu przycisku "Podsumuj" lub "Zapisz", lub na gĂłrze formularza).**
6.  ZarzÄ…dzanie stanem aplikacji (dane formularzy, stany Ĺ‚adowania, bĹ‚Ä™dy API, stany filtrĂłw/sortowania listy) bÄ™dzie realizowane za pomocÄ… podstawowych hookĂłw React (`useState`, `useEffect`). Lokalne stany bĹ‚Ä™dĂłw bÄ™dÄ… uĹĽywane do wyĹ›wietlania komunikatĂłw inline.
7.  ResponsywnoĹ›Ä‡ interfejsu na rĂłĹĽnych urzÄ…dzeniach nie jest brana pod uwagÄ™ w MVP.
8.  Na ekranie listy podsumowaĹ„ bÄ™dÄ… dostÄ™pne dwa pola typu date (`<input type="date">`) z etykietami "Od" i "Do" do filtrowania listy po dacie utworzenia.
9.  Tabela listy podsumowaĹ„ bÄ™dzie miaĹ‚a klikalne nagĹ‚Ăłwki kolumn "Data utworzenia" i "Data modyfikacji" do sortowania. DomyĹ›lne sortowanie to "Data utworzenia" malejÄ…co (od najnowszych). KlikniÄ™cie na nagĹ‚Ăłwek aktualnie sortowanej kolumny przeĹ‚Ä…cza kierunek (DESC/ASC); klikniÄ™cie na inny nagĹ‚Ăłwek ustawia sortowanie na tÄ™ kolumnÄ™ malejÄ…co (DESC). Aktywna kolumna i kierunek sortowania bÄ™dÄ… wskazywane ikonÄ….
10. **Komunikaty sukcesu (np. pomyĹ›lny zapis) oraz bĹ‚Ä™dy walidacji frontendowej (np. plik za duĹĽy) bÄ™dÄ… wyĹ›wietlane jako powiadomienia typu "toast".** TreĹ›Ä‡ toastu dla sukcesu zapisu: "Zmiany zapisane".
11. Aplikacja bÄ™dzie wymagaĹ‚a podstawowego uwierzytelnienia za pomocÄ… Supabase Auth SDK. PrĂłba dostÄ™pu do chronionych stron (lista, tworzenie, edycja) bez zalogowania bÄ™dzie skutkowaÄ‡ przekierowaniem na dedykowanÄ… stronÄ™ logowania. RÄ™czne zarzÄ…dzanie JWT na frontendzie zostanie odroczone.
12. W MVP nie bÄ™dzie dodatkowego wizualnego wskaĹşnika "zmian niezapisanych" na ekranie edycji.
13. Nazwa pliku (jeĹ›li istnieje) bÄ™dzie wyĹ›wietlana tylko w stopce sekcji edycji istniejÄ…cego podsumowania.
14. Przycisk "Nowe podsumowanie" zostanie umieszczony rĂłwnieĹĽ w prawym gĂłrnym rogu sekcji zawierajÄ…cej tabelÄ™ listy podsumowaĹ„ (jako dodatkowy skrĂłt).
15. Strona logowania (`/login`) bÄ™dzie minimalnym formularzem z polami email i hasĹ‚o oraz przyciskiem "Zaloguj". Bez funkcji rejestracji w MVP.
16. **BĹ‚Ä…d przekroczenia rozmiaru pliku (powyĹĽej 1 MB) zostanie zgĹ‚oszony uĹĽytkownikowi jako toast (jak w decyzji 10).**
17. Gdzie moĹĽliwe, wykorzystane zostanÄ… gĹ‚Ăłwne komponenty shadcn/ui.
18. Globalny topbar nawigacyjny (komponent `NavigationMenu` z shadcn/ui) bÄ™dzie zawieraĹ‚ linki "Moje podsumowania" (`/summaries`), "Nowe podsumowanie" (`/create`) oraz przycisk "Wyloguj". BÄ™dzie widoczny na stronach `/summaries`, `/create`, `/edit/:id`.
</decisions>
<matched_recommendations>
1.  ZastosowaÄ‡ minimalistyczny ukĹ‚ad strony z globalnym topbarem (komponent `NavigationMenu` z shadcn/ui) na stronach chronionych i gĹ‚Ăłwnym obszarem kontenera (np. `div` z klasami `container mx-auto p-4`), gdzie dynamicznie bÄ™dÄ… renderowane widoki listy i edycji. Strona logowania bÄ™dzie bez topbara.
2.  StworzyÄ‡ komponent React renderujÄ…cy wizualnie ukryty `<input type="file" accept=".txt">` i stylizowany `<label>` (np. `bg-blue-500 text-white py-2 px-4 rounded cursor-pointer`) z tekstem "Wczytaj plik TXT (max 1 MB)". Po wczytaniu, wyĹ›wietlaÄ‡ nazwÄ™ pliku w pobliĹĽu labela. **RozwaĹĽyÄ‡ uĹĽycie komponentu `Input` z shadcn/ui jako bazowego elementu stylizacji dla inputu, oraz `Button` i `Label` dla stylizowanej kontrolki wyboru pliku.**
3.  UmieĹ›ciÄ‡ grupÄ™ przyciskĂłw akcji ("Podsumuj", "Zapisz", "Anuluj") w kontenerze na dole formularza edycji/tworzenia, uĹĽywajÄ…c klas Tailwind do wyrĂłwnania ich do prawej (np. `flex justify-end space-x-2 mt-4`). **WykorzystaÄ‡ komponent `Button` z shadcn/ui dla wszystkich przyciskĂłw akcji.**
4.  UstawiÄ‡ atrybut `disabled` na przycisku "Podsumuj" warunkowo na `true` gdy `transcription.trim() === ''`. UstawiÄ‡ `disabled` na przycisku "Zapisz" na `true` gdy `summary.trim() === ''`. Komponent `Button` z shadcn/ui wspiera atrybut `disabled` i odpowiednie style.
5.  **ZaimplementowaÄ‡ wyĹ›wietlanie krytycznych bĹ‚Ä™dĂłw API (np. z endpointĂłw LLM, POST/PUT/GET summaries) inline w odpowiednim miejscu w komponencie widoku (np. pod przyciskiem "Podsumuj", nad przyciskami akcji "Zapisz"/"Anuluj", lub w sekcji tabeli dla bĹ‚Ä™dĂłw Ĺ‚adowania listy). UĹĽyÄ‡ lokalnego stanu `error` w komponencie i warunkowo renderowaÄ‡ element tekstowy (np. `<p class="text-red-500">`) z komunikatem bĹ‚Ä™du.** Komponenty `Dialog`/`AlertDialog` z shadcn/ui mogÄ… byÄ‡ zarezerwowane dla innych typĂłw modalnych okienek, jeĹ›li zajdzie taka potrzeba w przyszĹ‚oĹ›ci, ale nie bÄ™dÄ… uĹĽywane dla tych konkretnych bĹ‚Ä™dĂłw API w MVP.
6.  W komponentach edycji/tworzenia oraz listy, uĹĽywaÄ‡ hookĂłw `useState`: `transcription`, `summary`, `isLoadingGenerate`, `isLoadingSave`, `error` (dla bĹ‚Ä™dĂłw API do wyĹ›wietlenia inline), `summaries`, `isLoadingList`, `dateFrom`, `dateTo`, `sortBy`, `sortOrder`. UĹĽywaÄ‡ `useEffect` do asynchronicznego pobierania danych.
7.  Nad tabelÄ… listy, dodaÄ‡ dwa elementy `<input type="date">` z etykietami ("Od", "Do") i przycisk "Filtruj", umieszczone np. w `div` z klasÄ… `flex gap-4 mb-4 items-center`. **RozwaĹĽyÄ‡ uĹĽycie komponentu `Input` z `type="date"` oraz komponentu `Label` i `Button` z shadcn/ui dla tych elementĂłw.**
8.  WewnÄ…trz `<th>` dla kolumn datowych, umieĹ›ciÄ‡ tekst nagĹ‚Ăłwka i warunkowo renderowanÄ… ikonÄ™ z Lucide React (np. `ChevronUp` dla ASC, `ChevronDown` dla DESC) obok tekstu, gdy kolumna jest sortowana. ZaimplementowaÄ‡ logikÄ™ w handlerze klikniÄ™cia, ktĂłra aktualizuje stan `sortBy` i `sortOrder`. **RozwaĹĽyÄ‡ uĹĽycie komponentu `Table` z shadcn/ui jako podstawy do budowy tabeli listy podsumowaĹ„.**
9.  W plikach `.astro` dla tras `/summaries`, `/create`, `/edit/[id]`, uĹĽyÄ‡ Supabase SDK do sprawdzenia sesji. JeĹ›li sesja nie istnieje, wywoĹ‚aÄ‡ `Astro.redirect('/login')`. JeĹ›li sesja istnieje, renderowaÄ‡ layout strony *zawierajÄ…cy komponent `GlobalHeader` (topbar)*. Strona `/login.astro` powinna byÄ‡ publicznie dostÄ™pna i renderowaÄ‡ layout *bez komponentu `GlobalHeader`*.
10. W dolnej czÄ™Ĺ›ci sekcji edycji (np. `div` pod polami tekstowymi), warunkowo renderowaÄ‡ tekst "Plik: {fileName}" jeĹ›li `fileName` jest dostÄ™pny w stanie komponentu.
11. **ZaimplementowaÄ‡ globalny system toastĂłw (np. poprzez Context API) z funkcjÄ… `showToast(message)`. Po udanym zapisie (POST lub PUT API), wywoĹ‚aÄ‡ `showToast('Zmiany zapisane')`.** **WykorzystaÄ‡ komponent `Toast` z shadcn/ui do wyĹ›wietlania powiadomieĹ„ o sukcesie (zapis) i bĹ‚Ä™dach walidacji (plik za duĹĽy).**
12. W handlerze `onChange` dla inputu pliku, po uzyskaniu obiektu `file`, sprawdziÄ‡ `if (file && file.size > 1 * 1024 * 1024)`. JeĹ›li true, zresetowaÄ‡ input (`event.target.value = ''`) i wywoĹ‚aÄ‡ `showToast('Plik jest za duĹĽy (max 1 MB)')`.
13. StworzyÄ‡ komponent React dla strony logowania (`/login`) zawierajÄ…cy element `form`, wewnÄ…trz ktĂłrego znajdÄ… siÄ™ dwa `div`-y dla pĂłl email i hasĹ‚a (kaĹĽdy z `<label>` i `<input type="text/password">`) oraz przycisk `<button type="submit">Zaloguj</button>` na dole formularza. UĹĽywaÄ‡ prostych klas Tailwind do stylizacji. **ZastosowaÄ‡ komponenty `Input`, `Label` i `Button` z shadcn/ui w formularzu logowania.** Strona ta bÄ™dzie renderowana *bez globalnego topbara*.
14. UmieĹ›ciÄ‡ przycisk "Nowe podsumowanie" (komponent `Button` z shadcn/ui) w prawym gĂłrnym rogu sekcji zawierajÄ…cej tabelÄ™ listy podsumowaĹ„ (rĂłwnieĹĽ, pomimo obecnoĹ›ci linku w topbarze).
15. StworzyÄ‡ komponent `GlobalHeader` renderujÄ…cy `NavigationMenu` z shadcn/ui. WewnÄ…trz `NavigationMenuContent` umieĹ›ciÄ‡ `NavigationMenuItem` z `NavigationMenuLink` do `/summaries` ("Moje podsumowania") i `/create` ("Nowe podsumowanie"). DodaÄ‡ przycisk "Wyloguj" (komponent `Button` obsĹ‚ugujÄ…cy akcjÄ™ wylogowania przez Supabase SDK) poza `NavigationMenu`, ale w tym samym topbarze. Ten komponent `GlobalHeader` bÄ™dzie renderowany warunkowo na stronach chronionych (np. w gĹ‚Ăłwnym komponencie Layout dla tych tras).
</matched_recommendations>

<ui_architecture_planning_summary>
Podsumowanie planowania architektury UI dla MVP Meeting Summarizer zakĹ‚ada budowÄ™ minimalistycznej aplikacji webowej, z wykorzystaniem Astro, React, Tailwind CSS i Supabase. KluczowÄ… decyzjÄ… jest wykorzystanie gĹ‚Ăłwnych komponentĂłw biblioteki shadcn/ui wszÄ™dzie tam, gdzie jest to moĹĽliwe, w celu przyspieszenia rozwoju i zapewnienia spĂłjnego wyglÄ…du i zachowania. Aplikacja bÄ™dzie posiadaÄ‡ globalny topbar nawigacyjny (komponent `NavigationMenu` z shadcn/ui) widoczny na chronionych stronach.

**GĹ‚Ăłwne wymagania UI:** Wczytywanie/edycja transkrypcji i podsumowania, generowanie podsumowania LLM, zapis/odczyt z DB, przeglÄ…danie listy podsumowaĹ„, uwierzytelnienie uĹĽytkownika przez Supabase Auth SDK.

**Strategia wyĹ›wietlania bĹ‚Ä™dĂłw i powiadomieĹ„:** Krytyczne bĹ‚Ä™dy API (LLM, zapis, wczytanie) bÄ™dÄ… wyĹ›wietlane *inline* w obszarze widoku, w ktĂłrym wystÄ…piĹ‚y, przy uĹĽyciu lokalnego stanu bĹ‚Ä™du. Komunikaty sukcesu (zapis) i bĹ‚Ä™dy walidacji frontendowej (plik za duĹĽy) bÄ™dÄ… wyĹ›wietlane jako globalne powiadomienia typu "toast" (komponent `Toast` z shadcn/ui).

**Kluczowe widoki, ekrany i przepĹ‚ywy uĹĽytkownika:**
*   **Strona Logowania (`/login`):** Prosty formularz logowania bez topbara.
*   **Strona Listy PodsumowaĹ„ (`/summaries`):** Tabela z listÄ… podsumowaĹ„ (sortowanie, filtrowanie), topbar nawigacyjny, przycisk "Nowe podsumowanie" (dodatkowy skrĂłt). Potencjalne bĹ‚Ä™dy Ĺ‚adowania listy wyĹ›wietlane inline.
*   **Ekran Tworzenia/Edycji Podsumowania (`/create`, `/edit/:id`):** Formularz do edycji/tworzenia, kontrolka wczytywania pliku, przyciski akcji (Podsumuj, Zapisz, Anuluj), topbar nawigacyjny. BĹ‚Ä™dy LLM i zapisu wyĹ›wietlane inline w obszarze formularza/przyciskĂłw akcji. Potwierdzenia zapisu wyĹ›wietlane jako toast.
*   **PrzepĹ‚ywy uĹĽytkownika:** Logowanie -> Lista -> [Nowe] lub [Edytuj] -> Edycja/Tworzenie -> [Zapisz] lub [Anuluj] -> Lista. Nawigacja miÄ™dzy chronionymi stronami gĹ‚Ăłwnie przez topbar lub kontekstowe przyciski.

**Strategia integracji z API i zarzÄ…dzania stanem:**
*   Komunikacja z API Supabase dla operacji CRUD na podsumowaniach i endpointem LLM.
*   ZarzÄ…dzanie stanem za pomocÄ… podstawowych hookĂłw React (`useState`, `useEffect`). Lokalny stan bĹ‚Ä™du dla komunikatĂłw inline.
*   Globalny system toastĂłw do powiadomieĹ„ o sukcesie i bĹ‚Ä™dach walidacji.

**Kwestie dotyczÄ…ce responsywnoĹ›ci, dostÄ™pnoĹ›ci i bezpieczeĹ„stwa:**
*   **ResponsywnoĹ›Ä‡:** Nie jest priorytetem w MVP.
*   **DostÄ™pnoĹ›Ä‡:** W pewnym stopniu wspierana przez uĹĽycie gotowych komponentĂłw shadcn/ui i semantyczne etykietowanie. WyĹ›wietlanie bĹ‚Ä™dĂłw inline w pobliĹĽu miejsca ich wystÄ…pienia poprawia dostÄ™pnoĹ›Ä‡ dla uĹĽytkownikĂłw korzystajÄ…cych z czytnikĂłw ekranu lub nawigujÄ…cych klawiaturÄ….
*   **BezpieczeĹ„stwo:** Zapewnione przez Supabase Auth (SDK) i RLS. Frontend egzekwuje uwierzytelnienie i przekierowuje na stronÄ™ logowania.

**NierozwiÄ…zane kwestie lub obszary wymagajÄ…ce dalszego wyjaĹ›nienia:**
Wszystkie poprzednio zidentyfikowane kwestie zostaĹ‚y wyjaĹ›nione i podjÄ™to decyzje dotyczÄ…ce ich implementacji w ramach zakresu MVP, z uwzglÄ™dnieniem wykorzystania komponentĂłw shadcn/ui, specyfikacji topbara nawigacyjnego oraz zaktualizowanej strategii wyĹ›wietlania bĹ‚Ä™dĂłw (inline) i powiadomieĹ„ (toasts).
</ui_architecture_planning_summary>
<unresolved_issues>
</unresolved_issues>
</conversation_summary>


================================================
File: .ai/ui-shadcn-helper.md
================================================
# Shadcn UI Components

Ten projekt wykorzystuje @shadcn/ui dla komponentĂłw interfejsu uĹĽytkownika. SÄ… to piÄ™knie zaprojektowane, dostÄ™pne komponenty, ktĂłre moĹĽna dostosowaÄ‡ do swojej aplikacji.

## Odszukiwanie zainstalowanych komponentĂłw

Komponenty sÄ… dostÄ™pne w folderze `src/components/ui`, zgodnie z aliasami z pliku `components.json`

## Wykorzystanie komponentu

Zaimportuj komponent zgodnie ze skonfigurowanym aliasem `@/`

```tsx
import { Button } from "@/components/ui/button"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card"
```

PrzykĹ‚adowe wykorzystanie komponnetĂłw:

```tsx
<Button variant="outline">Click me</Button>

<Card>
  <CardHeader>
    <CardTitle>Card Title</CardTitle>
    <CardDescription>Card Description</CardDescription>
  </CardHeader>
  <CardContent>
    <p>Card Content</p>
  </CardContent>
  <CardFooter>
    <p>Card Footer</p>
  </CardFooter>
</Card>
```

## Instalowanie dodatkowych komponentĂłw

Wiele innych komponentĂłw jest dostÄ™pnych, ale nie sÄ… one obecnie zainstalowane. PeĹ‚nÄ… listÄ™ moĹĽna znaleĹşÄ‡ na stronie https://ui.shadcn.com/r

Aby zainstalowaÄ‡ nowy komponent, wykorzystaj shadcn CLI


```bash
npx shadcn@latest add [component-name]
```

PrzykĹ‚adowo, aby dodaÄ‡ komponent accordion

```bash
npx shadcn@latest add accordion
```

WaĹĽne: `npx shadcn-ui@latest` zostaĹ‚o wycofane, korzystaj z `npx shadcn@latest`

NiektĂłre popularne komponenty to:

- Accordion
- Alert
- AlertDialog
- AspectRatio
- Avatar
- Calendar
- Checkbox
- Collapsible
- Command
- ContextMenu
- DataTable
- DatePicker
- Dropdown Menu
- Form
- Hover Card
- Menubar
- Navigation Menu
- Popover
- Progress
- Radio Group
- ScrollArea
- Select
- Separator
- Sheet
- Skeleton
- Slider
- Switch
- Table
- Textarea
- Sonner (previously Toast)
- Toggle
- Tooltip

## Component Styling

Ten projekt wykorzystuje wariant stylu â€žnew-yorkâ€ť z kolorem bazowym "neutral" i zmiennymi CSS do tworzenia motywĂłw, zgodnie z konfiguracjÄ… w sekcji `components.json`.


================================================
File: .ai/ui-view-implementation.md
================================================
Twoim zadaniem jest zaimplementowanie widoku frontendu w oparciu o podany plan implementacji i zasady implementacji. Twoim celem jest stworzenie szczegĂłĹ‚owej i dokĹ‚adnej implementacji, ktĂłra jest zgodna z dostarczonym planem, poprawnie reprezentuje strukturÄ™ komponentĂłw, integruje siÄ™ z API i obsĹ‚uguje wszystkie okreĹ›lone interakcje uĹĽytkownika.

Najpierw przejrzyj plan implementacji:

<implementation_plan>
{{implementation-plan}} <- zamieĹ„ na referencjÄ™ do planu implementacji widoku (np. @generations-view-implementation-plan.md)
</implementation_plan>

Teraz przejrzyj zasady implementacji:

<implementation_rules>
{{frontend-rules}}  <- zamieĹ„ na referencjÄ™ do reguĹ‚ frontendowych (np. @shared.mdc, @frontend.mdc, @astro.mdc, @react.mdc, @ui-shadcn-helper.mdc)
</implementation_rules>

Przejrzyj zdefiniowane typy:

<types>
{{types}} <- zamieĹ„ na referencjÄ™ do definicji DTOsĂłw (np. @types.ts)
</types>

WdraĹĽaj plan zgodnie z nastÄ™pujÄ…cym podejĹ›ciem:

<implementation_approach>
Realizuj maksymalnie 3 kroki planu implementacji, podsumuj krĂłtko co zrobiĹ‚eĹ› i opisz plan na 3 kolejne dziaĹ‚ania - zatrzymaj w tym momencie pracÄ™ i czekaj na mĂłj feedback.
</implementation_approach>

DokĹ‚adnie przeanalizuj plan wdroĹĽenia i zasady. ZwrĂłÄ‡ szczegĂłlnÄ… uwagÄ™ na strukturÄ™ komponentĂłw, wymagania dotyczÄ…ce integracji API i interakcje uĹĽytkownika opisane w planie.

Wykonaj nastÄ™pujÄ…ce kroki, aby zaimplementowaÄ‡ widok frontendu:

1. Struktura komponentĂłw:
   - Zidentyfikuj wszystkie komponenty wymienione w planie wdroĹĽenia.
   - UtwĂłrz hierarchicznÄ… strukturÄ™ tych komponentĂłw.
   - Upewnij siÄ™, ĹĽe obowiÄ…zki i relacje kaĹĽdego komponentu sÄ… jasno zdefiniowane.

2. Integracja API:
   - Zidentyfikuj wszystkie endpointy API wymienione w planie.
   - WdrĂłĹĽ niezbÄ™dne wywoĹ‚ania API dla kaĹĽdego endpointa.
   - ObsĹ‚uĹĽ odpowiedzi z API i odpowiednio aktualizacji stan komponentĂłw.

3. Interakcje uĹĽytkownika:
   - Wylistuj wszystkie interakcje uĹĽytkownika okreĹ›lone w planie wdroĹĽenia.
   - WdrĂłĹĽ obsĹ‚ugi zdarzeĹ„ dla kaĹĽdej interakcji.
   - Upewnij siÄ™, ĹĽe kaĹĽda interakcja wyzwala odpowiedniÄ… akcjÄ™ lub zmianÄ™ stanu.

4. ZarzÄ…dzanie stanem:
   - Zidentyfikuj wymagany stan dla kaĹĽdego komponentu.
   - Zaimplementuj zarzÄ…dzanie stanem przy uĹĽyciu odpowiedniej metody (stan lokalny, custom hook, stan wspĂłĹ‚dzielony).
   - Upewnij siÄ™, ĹĽe zmiany stanu wyzwalajÄ… niezbÄ™dne ponowne renderowanie.

5. Stylowanie i layout:
   - Zastosuj okreĹ›lone stylowanie i layout, jak wspomniano w planie wdroĹĽenia.
   - Zapewnienie responsywnoĹ›ci, jeĹ›li wymaga tego plan.

6. ObsĹ‚uga bĹ‚Ä™dĂłw i przypadki brzegowe:
   - WdroĹĽenie obsĹ‚ugi bĹ‚Ä™dĂłw dla wywoĹ‚aĹ„ API i interakcji uĹĽytkownika.
   - RozwaĹĽ i obsĹ‚uĹĽ potencjalne edge case'y wymienione w planie.

7. Optymalizacja wydajnoĹ›ci:
   - WdroĹĽenie wszelkich optymalizacji wydajnoĹ›ci okreĹ›lonych w planie lub zasadach.
   - Zapewnienie wydajnego renderowania i minimalnej liczby niepotrzebnych ponownych renderowaĹ„.

8. Testowanie:
   - JeĹ›li zostaĹ‚o to okreĹ›lone w planie, zaimplementuj testy jednostkowe dla komponentĂłw i funkcji.
   - DokĹ‚adnie przetestuj wszystkie interakcje uĹĽytkownika i integracje API.

W trakcie caĹ‚ego procesu implementacji naleĹĽy Ĺ›ciĹ›le przestrzegaÄ‡ dostarczonych zasad implementacji. Zasady te majÄ… pierwszeĹ„stwo przed wszelkimi ogĂłlnymi najlepszymi praktykami, ktĂłre mogÄ… byÄ‡ z nimi sprzeczne.

Upewnij siÄ™, ĹĽe twoja implementacja dokĹ‚adnie odzwierciedla dostarczony plan implementacji i przestrzega wszystkich okreĹ›lonych zasad. ZwrĂłÄ‡ szczegĂłlnÄ… uwagÄ™ na strukturÄ™ komponentĂłw, integracjÄ™ API i obsĹ‚ugÄ™ interakcji uĹĽytkownika.


================================================
File: .astro/content-assets.mjs
================================================
export default new Map();


================================================
File: .astro/content-modules.mjs
================================================
export default new Map();


================================================
File: .astro/data-store.json
================================================
[["Map",1,2],"meta::meta",["Map",3,4,5,6],"astro-version","5.5.5","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"server\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":3003,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\",\"entrypoint\":\"astro/assets/endpoint/node\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[]},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"math\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"responsiveImages\":false,\"session\":true,\"serializeConfig\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false},\"legacy\":{\"collections\":false},\"session\":{\"driver\":\"fs-lite\",\"options\":{\"base\":\"C:\\\\Users\\\\waldekd\\\\Documents\\\\Coding\\\\JS\\\\10xDEVs\\\\meeting-summary\\\\node_modules\\\\.astro\\\\sessions\"}}}"]


================================================
File: .astro/settings.json
================================================
{
	"_variables": {
		"lastUpdateCheck": 1745090623379
	}
}


================================================
File: .astro/types.d.ts
================================================
/// <reference types="astro/client" />




================================================
File: .cursor/rules/api-supabase-astro-init.mdc
================================================
---
description: 
globs: 
alwaysApply: false
---
# Supabase Astro Initialization

This document provides a reproducible guide to create the necessary file structure for integrating Supabase with your Astro project.

## Prerequisites

- Your project should use Astro 5, TypeScript 5, React 19, and Tailwind 4.
- Install the `@supabase/supabase-js` package.
- Ensure that `/supabase/config.toml` exists
- Ensure that a file `/src/db/database.types.ts` exists and contains the correct type definitions for your database.

IMPORTANT: Check prerequisites before perfoming actions below. If they're not met, stop and ask a user for the fix.

## File Structure and Setup

### 1. Supabase Client Initialization

Create the file `/src/db/supabase.client.ts` with the following content:

```ts
import { createClient } from '@supabase/supabase-js';

import type { Database } from '../db/database.types.ts';

const supabaseUrl = import.meta.env.SUPABASE_URL;
const supabaseAnonKey = import.meta.env.SUPABASE_KEY;

export const supabaseClient = createClient<Database>(supabaseUrl, supabaseAnonKey);
```

This file initializes the Supabase client using the environment variables `SUPABASE_URL` and `SUPABASE_KEY`.


### 2. Middleware Setup

Create the file `/src/middleware/index.ts` with the following content:

```ts
import { defineMiddleware } from 'astro:middleware';

import { supabaseClient } from '../db/supabase.client.ts';

export const onRequest = defineMiddleware((context, next) => {
  context.locals.supabase = supabaseClient;
  return next();
});
```

This middleware adds the Supabase client to the Astro context locals, making it available throughout your application.


### 3. TypeScript Environment Definitions

Create the file `src/env.d.ts` with the following content:

```ts
/// <reference types="astro/client" />

import type { SupabaseClient } from '@supabase/supabase-js';
import type { Database } from './db/database.types.ts';

declare global {
  namespace App {
    interface Locals {
      supabase: SupabaseClient<Database>;
    }
  }
}

interface ImportMetaEnv {
  readonly SUPABASE_URL: string;
  readonly SUPABASE_KEY: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}
```

This file augments the global types to include the Supabase client on the Astro `App.Locals` object, ensuring proper typing throughout your application.



================================================
File: .cursor/rules/astro.mdc
================================================
---
description: 
globs: *.astro
alwaysApply: false
---
### Guidelines for Astro

- Leverage View Transitions API for smooth page transitions (use ClientRouter)
- Use content collections with type safety for blog posts, documentation, etc.
- Leverage Server Endpoints for API routes
- Use POST, GET  - uppercase format for endpoint handlers
- Use `export const prerender = false` for API routes
- Use zod for input validation in API routes
- Extract logic into services in `src/lib/services`
- Implement middleware for request/response modification
- Use image optimization with the Astro Image integration
- Implement hybrid rendering with server-side rendering where needed
- Use Astro.cookies for server-side cookie management
- Leverage import.meta.env for environment variables



================================================
File: .cursor/rules/backend.mdc
================================================
---
description: 
globs: src/db/*.ts,src/middleware/*.ts,src/lib/*.ts
alwaysApply: false
---
### Backend and Database

- Use Supabase for backend services, including authentication and database interactions.
- Follow Supabase guidelines for security and performance.
- Use Zod schemas to validate data exchanged with the backend.
- Use supabase from context.locals in Astro routes instead of importing supabaseClient directly
- Use SupabaseClient type from `src/db/supabase.client.ts`, not from `@supabase/supabase-js`


================================================
File: .cursor/rules/db-supabase-migrations.mdc
================================================
---
description: 
globs: 
alwaysApply: false
---
# Database: Create migration

You are a Postgres Expert who loves creating secure database schemas.

This project uses the migrations provided by the Supabase CLI.

## Creating a migration file

Given the context of the user's message, create a database migration file inside the folder `supabase/migrations/`.

The file MUST following this naming convention:

The file MUST be named in the format `YYYYMMDDHHmmss_short_description.sql` with proper casing for months, minutes, and seconds in UTC time:

1. `YYYY` - Four digits for the year (e.g., `2024`).
2. `MM` - Two digits for the month (01 to 12).
3. `DD` - Two digits for the day of the month (01 to 31).
4. `HH` - Two digits for the hour in 24-hour format (00 to 23).
5. `mm` - Two digits for the minute (00 to 59).
6. `ss` - Two digits for the second (00 to 59).
7. Add an appropriate description for the migration.

For example:

```
20240906123045_create_profiles.sql
```


## SQL Guidelines

Write Postgres-compatible SQL code for Supabase migration files that:

- Includes a header comment with metadata about the migration, such as the purpose, affected tables/columns, and any special considerations.
- Includes thorough comments explaining the purpose and expected behavior of each migration step.
- Write all SQL in lowercase.
- Add copious comments for any destructive SQL commands, including truncating, dropping, or column alterations.
- When creating a new table, you MUST enable Row Level Security (RLS) even if the table is intended for public access.
- When creating RLS Policies
  - Ensure the policies cover all relevant access scenarios (e.g. select, insert, update, delete) based on the table's purpose and data sensitivity.
  - If the table  is intended for public access the policy can simply return `true`.
  - RLS Policies should be granular: one policy for `select`, one for `insert` etc) and for each supabase role (`anon` and `authenticated`). DO NOT combine Policies even if the functionality is the same for both roles.
  - Include comments explaining the rationale and intended behavior of each security policy

The generated SQL code should be production-ready, well-documented, and aligned with Supabase's best practices.



================================================
File: .cursor/rules/frontend.mdc
================================================
---
description: 
globs: *.tsx,*.astro
alwaysApply: false
---
## Frontend

### General Guidelines

- Use Astro components (.astro) for static content and layout
- Implement framework components in React only when interactivity is needed

### Guidelines for Styling

#### Tailwind

- Use the @layer directive to organize styles into components, utilities, and base layers
- Use arbitrary values with square brackets (e.g., w-[123px]) for precise one-off designs
- Implement the Tailwind configuration file for customizing theme, plugins, and variants
- Leverage the theme() function in CSS for accessing Tailwind theme values
- Implement dark mode with the dark: variant
- Use responsive variants (sm:, md:, lg:, etc.) for adaptive designs
- Leverage state variants (hover:, focus-visible:, active:, etc.) for interactive elements

### Guidelines for Accessibility

#### ARIA Best Practices

- Use ARIA landmarks to identify regions of the page (main, navigation, search, etc.)
- Apply appropriate ARIA roles to custom interface elements that lack semantic HTML equivalents
- Set aria-expanded and aria-controls for expandable content like accordions and dropdowns
- Use aria-live regions with appropriate politeness settings for dynamic content updates
- Implement aria-hidden to hide decorative or duplicative content from screen readers
- Apply aria-label or aria-labelledby for elements without visible text labels
- Use aria-describedby to associate descriptive text with form inputs or complex elements
- Implement aria-current for indicating the current item in a set, navigation, or process
- Avoid redundant ARIA that duplicates the semantics of native HTML elements


================================================
File: .cursor/rules/react.mdc
================================================
---
description: 
globs: *.tsx
alwaysApply: false
---
### Guidelines for React

- Use functional components with hooks instead of class components
- Never use "use client" and other Next.js directives as we use React with Astro
- Extract logic into custom hooks in `src/components/hooks`
- Implement React.memo() for expensive components that render often with the same props
- Utilize React.lazy() and Suspense for code-splitting and performance optimization
- Use the useCallback hook for event handlers passed to child components to prevent unnecessary re-renders
- Prefer useMemo for expensive calculations to avoid recomputation on every render
- Implement useId() for generating unique IDs for accessibility attributes
- Consider using the new useOptimistic hook for optimistic UI updates in forms
- Use useTransition for non-urgent state updates to keep the UI responsive


================================================
File: .cursor/rules/shared.mdc
================================================
---
description: 
globs: 
alwaysApply: true
---
# AI Rules for {app-name}

{project-description}

## Tech Stack

- Astro 5
- TypeScript 5
- React 19
- Tailwind 4
- Shadcn/ui

## Project Structure

When introducing changes to the project, always follow the directory structure below:

- `./src` - source code
- `./src/layouts` - Astro layouts
- `./src/pages` - Astro pages
- `./src/pages/api` - API endpoints
- `./src/middleware/index.ts` - Astro middleware
- `./src/db` - Supabase clients and types
- `./src/types.ts` - Shared types for backend and frontend (Entities, DTOs)
- `./src/components` - Client-side components written in Astro (static) and React (dynamic)
- `./src/components/ui` - Client-side components from Shadcn/ui
- `./src/lib` - Services and helpers 
- `./src/assets` - static internal assets
- `./public` - public assets

When modifying the directory structure, always update this section.

## Coding practices

### Guidelines for clean code

- Use feedback from linters to improve the code when making changes.
- Prioritize error handling and edge cases.
- Handle errors and edge cases at the beginning of functions.
- Use early returns for error conditions to avoid deeply nested if statements.
- Place the happy path last in the function for improved readability.
- Avoid unnecessary else statements; use if-return pattern instead.
- Use guard clauses to handle preconditions and invalid states early.
- Implement proper error logging and user-friendly error messages.
- Consider using custom error types or error factories for consistent error handling.



================================================
File: .cursor/rules/ui-shadcn-helper.mdc
================================================
---
description: 
globs: 
alwaysApply: false
---
# Shadcn UI Components

Ten projekt wykorzystuje @shadcn/ui dla komponentĂłw interfejsu uĹĽytkownika. SÄ… to piÄ™knie zaprojektowane, dostÄ™pne komponenty, ktĂłre moĹĽna dostosowaÄ‡ do swojej aplikacji.

## Odszukiwanie zainstalowanych komponentĂłw

Komponenty sÄ… dostÄ™pne w folderze `src/components/ui`, zgodnie z aliasami z pliku `components.json`

## Wykorzystanie komponentu

Zaimportuj komponent zgodnie ze skonfigurowanym aliasem `@/`

```tsx
import { Button } from "@/components/ui/button"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card"
```

PrzykĹ‚adowe wykorzsytanie komponnetĂłw:

```tsx
<Button variant="outline">Click me</Button>

<Card>
  <CardHeader>
    <CardTitle>Card Title</CardTitle>
    <CardDescription>Card Description</CardDescription>
  </CardHeader>
  <CardContent>
    <p>Card Content</p>
  </CardContent>
  <CardFooter>
    <p>Card Footer</p>
  </CardFooter>
</Card>
```

## Instalowanie dodatkowych komponentĂłw

Wiele innych komponentĂłw jest dostÄ™pnych, ale nie sÄ… one obecnie zainstalowane. PeĹ‚nÄ… listÄ™ moĹĽna znaleĹşÄ‡ na stronie https://ui.shadcn.com/r

Aby zainstalowaÄ‡ nowy komponent, wykorzystaj shadcn CLI


```bash
npx shadcn@latest add [component-name]
```

PrzykĹ‚adowo, aby dodaÄ‡ komponent accordion

```bash
npx shadcn@latest add accordion
```

WaĹĽne: `npx shadcn-ui@latest` zostaĹ‚o wycofane, korzystaj z `npx shadcn@latest`

NiektĂłre popularne komponenty to:

- Accordion
- Alert
- AlertDialog
- AspectRatio
- Avatar
- Calendar
- Checkbox
- Collapsible
- Command
- ContextMenu
- DataTable
- DatePicker
- Dropdown Menu
- Form
- Hover Card
- Menubar
- Navigation Menu
- Popover
- Progress
- Radio Group
- ScrollArea
- Select
- Separator
- Sheet
- Skeleton
- Slider
- Switch
- Table
- Textarea
- Sonner (previously Toast)
- Toggle
- Tooltip

## Component Styling

Ten projekt wykorzystuje wariant stylu â€žnew-yorkâ€ť z kolorem bazowym "neutral" i zmiennymi CSS do tworzenia motywĂłw, zgodnie z konfiguracjÄ… w sekcji `components.json`.


================================================
File: .github/copilot-instructions.md
================================================
# AI Rules for {{project-name}}

{{project-description}}

## Tech Stack

- Astro 5
- TypeScript 5
- React 19
- Tailwind 4
- Shadcn/ui

## Project Structure

When introducing changes to the project, always follow the directory structure below:

- `./src` - source code
- `./src/layouts` - Astro layouts
- `./src/pages` - Astro pages
- `./src/pages/api` - API endpoints
- `./src/middleware/index.ts` - Astro middleware
- `./src/db` - Supabase clients and types
- `./src/types.ts` - Shared types for backend and frontend (Entities, DTOs)
- `./src/components` - Client-side components written in Astro (static) and React (dynamic)
- `./src/components/ui` - Client-side components from Shadcn/ui
- `./src/lib` - Services and helpers
- `./src/assets` - static internal assets
- `./public` - public assets

When modifying the directory structure, always update this section.

## Coding practices

### Guidelines for clean code

- Use feedback from linters to improve the code when making changes.
- Prioritize error handling and edge cases.
- Handle errors and edge cases at the beginning of functions.
- Use early returns for error conditions to avoid deeply nested if statements.
- Place the happy path last in the function for improved readability.
- Avoid unnecessary else statements; use if-return pattern instead.
- Use guard clauses to handle preconditions and invalid states early.
- Implement proper error logging and user-friendly error messages.
- Consider using custom error types or error factories for consistent error handling.

## Frontend

### General Guidelines

- Use Astro components (.astro) for static content and layout
- Implement framework components in React only when interactivity is needed

### Guidelines for Styling

#### Tailwind

- Use the @layer directive to organize styles into components, utilities, and base layers
- Use arbitrary values with square brackets (e.g., w-[123px]) for precise one-off designs
- Implement the Tailwind configuration file for customizing theme, plugins, and variants
- Leverage the theme() function in CSS for accessing Tailwind theme values
- Implement dark mode with the dark: variant
- Use responsive variants (sm:, md:, lg:, etc.) for adaptive designs
- Leverage state variants (hover:, focus-visible:, active:, etc.) for interactive elements

### Guidelines for Accessibility

#### ARIA Best Practices

- Use ARIA landmarks to identify regions of the page (main, navigation, search, etc.)
- Apply appropriate ARIA roles to custom interface elements that lack semantic HTML equivalents
- Set aria-expanded and aria-controls for expandable content like accordions and dropdowns
- Use aria-live regions with appropriate politeness settings for dynamic content updates
- Implement aria-hidden to hide decorative or duplicative content from screen readers
- Apply aria-label or aria-labelledby for elements without visible text labels
- Use aria-describedby to associate descriptive text with form inputs or complex elements
- Implement aria-current for indicating the current item in a set, navigation, or process
- Avoid redundant ARIA that duplicates the semantics of native HTML elements

### Guidelines for Astro

- Leverage View Transitions API for smooth page transitions (use ClientRouter)
- Use content collections with type safety for blog posts, documentation, etc.
- Leverage Server Endpoints for API routes
- Use POST, GET  - uppercase format for endpoint handlers
- Use `export const prerender = false` for API routes
- Use zod for input validation in API routes
- Extract logic into services in `src/lib/services`
- Implement middleware for request/response modification
- Use image optimization with the Astro Image integration
- Implement hybrid rendering with server-side rendering where needed
- Use Astro.cookies for server-side cookie management
- Leverage import.meta.env for environment variables

### Guidelines for React

- Use functional components with hooks instead of class components
- Never use "use client" and other Next.js directives as we use React with Astro
- Extract logic into custom hooks in `src/components/hooks`
- Implement React.memo() for expensive components that render often with the same props
- Utilize React.lazy() and Suspense for code-splitting and performance optimization
- Use the useCallback hook for event handlers passed to child components to prevent unnecessary re-renders
- Prefer useMemo for expensive calculations to avoid recomputation on every render
- Implement useId() for generating unique IDs for accessibility attributes
- Consider using the new useOptimistic hook for optimistic UI updates in forms
- Use useTransition for non-urgent state updates to keep the UI responsive

### Backend and Database

- Use Supabase for backend services, including authentication and database interactions.
- Follow Supabase guidelines for security and performance.
- Use Zod schemas to validate data exchanged with the backend.
- Use supabase from context.locals in Astro routes instead of importing supabaseClient directly
- Use SupabaseClient type from `src/db/supabase.client.ts`, not from `@supabase/supabase-js`


================================================
File: .history/tailwind.config_20250421130423.mjs
================================================
/** @type {import('tailwindcss').Config} */
const config = {
  content: [
    "./src/**/*.{astro,html,js,jsx,md,mdx,svelte,ts,tsx,vue}",
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
    "./@/**/*.{js,ts,jsx,tsx}", // Ensure shadcn components are included
  ],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: `var(--radius)`,
        md: `calc(var(--radius) - 2px)`,
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
        "caret-blink": {
          "0%,70%,100%": { opacity: "1" },
          "15%,55%": { opacity: "0" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "caret-blink": "caret-blink 1.2s ease-out infinite", // Added for potential future use
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
};

export default config;



================================================
File: .history/tailwind.config_20250421133817.mjs
================================================
/** @type {import('tailwindcss').Config} */
const config = {
  content: [
    "./src/**/*.{astro,html,js,jsx,md,mdx,svelte,ts,tsx,vue}",
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
    "./@/**/*.{js,ts,jsx,tsx}", // Ensure shadcn components are included
  ],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: `var(--radius)`,
        md: `calc(var(--radius) - 2px)`,
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
        "caret-blink": {
          "0%,70%,100%": { opacity: "1" },
          "15%,55%": { opacity: "0" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "caret-blink": "caret-blink 1.2s ease-out infinite", // Added for potential future use
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
};

export default config;



================================================
File: .history/src/auth_20250421132412.ts
================================================
// src/auth.ts
// Central module for Supabase client initialization and server-side session check.
// Contains both the browser-side client and the server-side getSession helper.

// Import createServerClient and the base SupabaseClient type from the SSR library
// Although the browser client is used primarily client-side, using createServerClient
// with `browser: true` is often recommended in SSR frameworks like Astro for cookie handling.
import { createServerClient, type SupabaseClient as SupabaseClientBase } from "@supabase/ssr";
import type { APIContext } from "astro"; // Import APIContext type for server-side context
import type { Session } from "@supabase/supabase-js";

// Import your local Database type
import type { Database } from "./db/database.types"; // Adjust path as needed

// Define the Supabase client type alias parameterized with your Database type
export type SupabaseClient = SupabaseClientBase<Database>;

// --- Supabase Browser Client ---
// This client is used in React components that run in the browser.
// It handles client-side session persistence (cookies/localStorage).
// Use your actual Supabase URL and Anon Key from environment variables (PUBLIC prefixed for client access).
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY;

// Use createServerClient for browser client to handle cookies properly in SSR environments
// Ensure env vars are checked (though Astro handles this somewhat via env.d.ts)
if (typeof window !== "undefined" && (!supabaseUrl || !supabaseAnonKey)) {
  console.error("PUBLIC_SUPABASE_URL or PUBLIC_SUPABASE_ANON_KEY are not set for the browser client.");
  // In a real app, you might show an error message or handle this gracefully.
}

export const supabase = createServerClient<Database>(supabaseUrl, supabaseAnonKey, {
  browser: true, // Explicitly configure for browser environment
  cookies: {
    get: (name: string) => {
      // Basic browser cookie parsing (needed by createServerClient in browser mode)
      if (typeof document === "undefined") return undefined;
      const match = document.cookie.split("; ").find((row) => row.startsWith(name + "="));
      return match ? match.split("=")[1] : undefined;
    },
    set: (name, value, options) => {
      if (typeof document !== "undefined") {
        document.cookie = `${name}=${value}; path=${options.path || "/"}; ${options.maxAge ? `Max-Age=${options.maxAge}` : ""} ${options.domain ? `Domain=${options.domain}` : ""} ${options.secure ? "Secure" : ""} ${options.httpOnly ? "HttpOnly" : ""} ${options.sameSite ? `SameSite=${options.sameSite}` : ""}`;
      }
    },
    remove: (name, options) => {
      if (typeof document !== "undefined") {
        document.cookie = `${name}=; Max-Age=0; path=${options?.path || "/"}; ${options?.domain ? `Domain=${options.domain}` : ""} ${options?.secure ? "Secure" : ""} ${options?.httpOnly ? "HttpOnly" : ""} ${options?.sameSite ? `SameSite=${options.sameSite}` : ""}`;
      }
    },
  },
  global: {
    fetch: fetch.bind(globalThis), // Ensure fetch is bound to globalThis in browser
  },
});

// --- Supabase Server Session Check (Astro SSR) ---
// This function is used in Astro pages/layouts/middleware for server-side authentication checks for ROUTE ACCESS.
// It uses the Supabase client instance provided via context.locals by the middleware.

export async function getSession(context: APIContext): Promise<Session | null> {
  // Get the server-side Supabase client from context.locals
  const supabaseServer: SupabaseClient = context.locals.supabase;

  if (!supabaseServer) {
    console.error("getSession: Supabase client not found in context.locals. Ensure middleware is running.");
    // This indicates a critical setup error if middleware didn't run.
    return null;
  }

  // Use the server-side client to get the session from the request cookies
  // This checks if *any* user is authenticated for ROUTE protection.
  const {
    data: { session },
    error: authError,
  } = await supabaseServer.auth.getSession();

  if (authError) {
    console.error("getSession: Error fetching session on server:", authError);
    return null;
  }

  console.log(`getSession: Session found for route protection? ${!!session}`);
  return session;
}



================================================
File: .history/src/auth_20250421133017.ts
================================================
// src/auth.ts
// Placeholder for Supabase session check logic and client initialization.
// In a real project, this would use environment variables and potentially
// handle server-side initialization differently for SSR requests vs client-side.

import { createClient } from "@supabase/supabase-js";
import { type Database } from "./db/database.types"; // Adjust path as needed
import type { Session } from "@supabase/supabase-js";

// --- Supabase Browser Client ---
// This client is used in React components that run in the browser.
// Use your actual Supabase URL and Anon Key from environment variables.
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL || "YOUR_SUPABASE_URL";
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY || "YOUR_SUPABASE_ANON_KEY";

export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey);

// --- Supabase Server Session Check (Astro SSR) ---
// This function is used in Astro pages/layouts/middleware for server-side checks.
// It simulates fetching the session from the request context.
// A proper implementation uses @supabase/ssr createServerClient.

export async function getSession(request: Request): Promise<Session | null> {
  // This is a simplified mock using cookies header.
  // A proper Supabase SSR setup is recommended.
  // Example using @supabase/ssr (requires setting up cookie handling):
  /*
  const supabaseServer = createServerClient<Database>(
    import.meta.env.SUPABASE_URL, // Server-side env var
    import.meta.env.SUPABASE_ANON_KEY, // Server-side env var
    {
      cookies: {
        get: (name: string) => {
          const cookie = request.headers.get('Cookie');
          if (!cookie) return undefined;
          const c = cookie.split(';').find(c => c.trim().startsWith(name + '='));
          return c ? c.split('=')[1] : undefined;
        },
        // set/remove are needed if you modify cookies server-side,
        // but get is sufficient for just checking the session from request.
        set: (name, value, options) => {},
        remove: (name) => {},
      },
    }
  );
  const { data: { session } } = await supabaseServer.auth.getSession();
  return session;
  */

  // Basic Mock Check (NOT SECURE FOR PRODUCTION): Checks for a mock cookie
  const cookies = request.headers.get("Cookie");
  if (cookies && (cookies.includes("sb-access-token") || cookies.includes("supabase-auth-token"))) {
    // Look for common Supabase cookies
    // Simulate a basic session object if cookies are present
    // In a real app, you'd decode the JWT or use the SSR client session object
    console.log("Simulating authenticated session based on cookies");
    return {
      access_token: "mock-token",
      refresh_token: "mock-refresh-token",
      expires_in: 3600,
      expires_at: Math.floor(Date.now() / 1000) + 3600,
      token_type: "Bearer",
      user: {
        id: "mock-user-id-from-cookie",
        aud: "authenticated",
        role: "authenticated",
        email: "user@example.com", // Mock email
        email_confirmed_at: new Date().toISOString(),
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        identities: [],
        app_metadata: {},
        user_metadata: {},
      },
    };
  }
  console.log("No authenticated session found");
  return null;
}



================================================
File: .history/src/auth_20250421133031.ts
================================================
// src/auth.ts
// Central module for Supabase client initialization and server-side session check.
// Contains both the browser-side client and the server-side getSession helper.

// Import createServerClient and the base SupabaseClient type from the SSR library
// Although the browser client is used primarily client-side, using createServerClient
// with `browser: true` is often recommended in SSR frameworks like Astro for cookie handling.
import { createServerClient, type SupabaseClient as SupabaseClientBase } from '@supabase/ssr';
import type { APIContext } from "astro"; // Import APIContext type for server-side context
import type { Session } from "@supabase/supabase-js";

// Import your local Database type
import type { Database } from "./db/database.types"; // Adjust path as needed


// Define the Supabase client type alias parameterized with your Database type
export type SupabaseClient = SupabaseClientBase<Database>;


// --- Supabase Browser Client ---
// This client is used in React components that run in the browser.
// It handles client-side session persistence (cookies/localStorage).
// Use your actual Supabase URL and Anon Key from environment variables (PUBLIC prefixed for client access).
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY;

// Use createServerClient for browser client to handle cookies properly in SSR environments
// Ensure env vars are checked (though Astro handles this somewhat via env.d.ts)
if (typeof window !== 'undefined' && (!supabaseUrl || !supabaseAnonKey)) {
   console.error("PUBLIC_SUPABASE_URL or PUBLIC_SUPABASE_ANON_KEY are not set for the browser client.");
   // In a real app, you might show an error message or handle this gracefully.
}


export const supabase = createServerClient<Database>(supabaseUrl, supabaseAnonKey, {
   browser: true, // Explicitly configure for browser environment
   cookies: {
      get: (name: string) => {
          // Basic browser cookie parsing (needed by createServerClient in browser mode)
          if (typeof document === 'undefined') return undefined;
          const match = document.cookie.split('; ').find(row => row.startsWith(name + '='));
          return match ? match.split('=')[1] : undefined;
      },
      set: (name, value, options) => {
          if (typeof document !== 'undefined') {
             document.cookie = `${name}=${value}; path=${options.path || '/'}; ${options.maxAge ? `Max-Age=${options.maxAge}` : ''} ${options.domain ? `Domain=${options.domain}` : ''} ${options.secure ? 'Secure' : ''} ${options.httpOnly ? 'HttpOnly' : ''} ${options.sameSite ? `SameSite=${options.sameSite}` : ''}`;
          }
      },
      remove: (name, options) => {
           if (typeof document !== 'undefined') {
             document.cookie = `${name}=; Max-Age=0; path=${options?.path || '/'}; ${options?.domain ? `Domain=${options.domain}` : ''} ${options?.secure ? 'Secure' : ''} ${options?.httpOnly ? 'HttpOnly' : ''} ${options?.sameSite ? `SameSite=${options.sameSite}` : ''}`;
           }
      },
   },
   global: {
       fetch: fetch.bind(globalThis), // Ensure fetch is bound to globalThis in browser
   }
});


// --- Supabase Server Session Check (Astro SSR) ---
// This function is used in Astro pages/layouts/middleware for server-side authentication checks for ROUTE ACCESS.
// It uses the Supabase client instance provided via context.locals by the middleware.

export async function getSession(context: APIContext): Promise<Session | null> {
  // Get the server-side Supabase client from context.locals
  const supabaseServer: SupabaseClient = context.locals.supabase;

  if (!supabaseServer) {
      console.error("getSession: Supabase client not found in context.locals. Ensure middleware is running.");
      // This indicates a critical setup error if middleware didn't run.
      return null;
  }

  // Use the server-side client to get the session from the request cookies
  // This checks if *any* user is authenticated for ROUTE protection.
  const { data: { session }, error: authError } = await supabaseServer.auth.getSession();

  if (authError) {
      console.error("getSession: Error fetching session on server:", authError);
      return null;
  }

  console.log(`getSession: Session found for route protection? ${!!session}`);
  return session;
}


================================================
File: .history/src/auth_20250421133115.ts
================================================
// src/auth.ts
// Placeholder for Supabase session check logic and client initialization.
// In a real project, this would use environment variables and potentially
// handle server-side initialization differently for SSR requests vs client-side.

import { createClient } from "@supabase/supabase-js";
import { type Database } from "./db/database.types"; // Adjust path as needed
import type { Session } from "@supabase/supabase-js";

// --- Supabase Browser Client ---
// This client is used in React components that run in the browser.
// Use your actual Supabase URL and Anon Key from environment variables.
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL || "YOUR_SUPABASE_URL";
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY || "YOUR_SUPABASE_ANON_KEY";

export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey);

// --- Supabase Server Session Check (Astro SSR) ---
// This function is used in Astro pages/layouts/middleware for server-side checks.
// It simulates fetching the session from the request context.
// A proper implementation uses @supabase/ssr createServerClient.

export async function getSession(request: Request): Promise<Session | null> {
  // This is a simplified mock using cookies header.
  // A proper Supabase SSR setup is recommended.
  // Example using @supabase/ssr (requires setting up cookie handling):
  /*
  const supabaseServer = createServerClient<Database>(
    import.meta.env.SUPABASE_URL, // Server-side env var
    import.meta.env.SUPABASE_ANON_KEY, // Server-side env var
    {
      cookies: {
        get: (name: string) => {
          const cookie = request.headers.get('Cookie');
          if (!cookie) return undefined;
          const c = cookie.split(';').find(c => c.trim().startsWith(name + '='));
          return c ? c.split('=')[1] : undefined;
        },
        // set/remove are needed if you modify cookies server-side,
        // but get is sufficient for just checking the session from request.
        set: (name, value, options) => {},
        remove: (name) => {},
      },
    }
  );
  const { data: { session } } = await supabaseServer.auth.getSession();
  return session;
  */

  // Basic Mock Check (NOT SECURE FOR PRODUCTION): Checks for a mock cookie
  const cookies = request.headers.get("Cookie");
  if (cookies && (cookies.includes("sb-access-token") || cookies.includes("supabase-auth-token"))) {
    // Look for common Supabase cookies
    // Simulate a basic session object if cookies are present
    // In a real app, you'd decode the JWT or use the SSR client session object
    console.log("Simulating authenticated session based on cookies");
    return {
      access_token: "mock-token",
      refresh_token: "mock-refresh-token",
      expires_in: 3600,
      expires_at: Math.floor(Date.now() / 1000) + 3600,
      token_type: "Bearer",
      user: {
        id: "mock-user-id-from-cookie",
        aud: "authenticated",
        role: "authenticated",
        email: "user@example.com", // Mock email
        email_confirmed_at: new Date().toISOString(),
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        identities: [],
        app_metadata: {},
        user_metadata: {},
      },
    };
  }
  console.log("No authenticated session found");
  return null;
}



================================================
File: .history/src/auth_20250421133124.ts
================================================
// src/auth.ts
// Central module for Supabase client initialization and server-side session check.
// Contains both the browser-side client and the server-side getSession helper.

// Import createServerClient and the base SupabaseClient type from the SSR library
// Although the browser client is used primarily client-side, using createServerClient
// with `browser: true` is often recommended in SSR frameworks like Astro for cookie handling.
import { createServerClient, type SupabaseClient as SupabaseClientBase } from '@supabase/ssr';
import type { APIContext } from "astro"; // Import APIContext type for server-side context
import type { Session } from "@supabase/supabase-js";

// Import your local Database type
import type { Database } from "./db/database.types"; // Adjust path as needed


// Define the Supabase client type alias parameterized with your Database type
export type SupabaseClient = SupabaseClientBase<Database>;


// --- Supabase Browser Client ---
// This client is used in React components that run in the browser.
// It handles client-side session persistence (cookies/localStorage).
// Use your actual Supabase URL and Anon Key from environment variables (PUBLIC prefixed for client access).
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY;

// Use createServerClient for browser client to handle cookies properly in SSR environments
// Ensure env vars are checked (though Astro handles this somewhat via env.d.ts)
if (typeof window !== 'undefined' && (!supabaseUrl || !supabaseAnonKey)) {
   console.error("PUBLIC_SUPABASE_URL or PUBLIC_SUPABASE_ANON_KEY are not set for the browser client.");
   // In a real app, you might show an error message or handle this gracefully.
}


export const supabase = createServerClient<Database>(supabaseUrl, supabaseAnonKey, {
   browser: true, // Explicitly configure for browser environment
   cookies: {
      get: (name: string) => {
          // Basic browser cookie parsing (needed by createServerClient in browser mode)
          if (typeof document === 'undefined') return undefined;
          const match = document.cookie.split('; ').find(row => row.startsWith(name + '='));
          return match ? match.split('=')[1] : undefined;
      },
      set: (name, value, options) => {
          if (typeof document !== 'undefined') {
             document.cookie = `${name}=${value}; path=${options.path || '/'}; ${options.maxAge ? `Max-Age=${options.maxAge}` : ''} ${options.domain ? `Domain=${options.domain}` : ''} ${options.secure ? 'Secure' : ''} ${options.httpOnly ? 'HttpOnly' : ''} ${options.sameSite ? `SameSite=${options.sameSite}` : ''}`;
          }
      },
      remove: (name, options) => {
           if (typeof document !== 'undefined') {
             document.cookie = `${name}=; Max-Age=0; path=${options?.path || '/'}; ${options?.domain ? `Domain=${options.domain}` : ''} ${options?.secure ? 'Secure' : ''} ${options?.httpOnly ? 'HttpOnly' : ''} ${options?.sameSite ? `SameSite=${options.sameSite}` : ''}`;
           }
      },
   },
   global: {
       fetch: fetch.bind(globalThis), // Ensure fetch is bound to globalThis in browser
   }
});


// --- Supabase Server Session Check (Astro SSR) ---
// This function is used in Astro pages/layouts/middleware for server-side authentication checks for ROUTE ACCESS.
// It uses the Supabase client instance provided via context.locals by the middleware.

export async function getSession(context: APIContext): Promise<Session | null> {
  // Get the server-side Supabase client from context.locals
  const supabaseServer: SupabaseClient = context.locals.supabase;

  if (!supabaseServer) {
      console.error("getSession: Supabase client not found in context.locals. Ensure middleware is running.");
      // This indicates a critical setup error if middleware didn't run.
      return null;
  }

  // Use the server-side client to get the session from the request cookies
  // This checks if *any* user is authenticated for ROUTE protection.
  const { data: { session }, error: authError } = await supabaseServer.auth.getSession();

  if (authError) {
      console.error("getSession: Error fetching session on server:", authError);
      return null;
  }

  console.log(`getSession: Session found for route protection? ${!!session}`);
  return session;
}


================================================
File: .history/src/auth_20250421133310.ts
================================================
// src/auth.ts
// Placeholder for Supabase session check logic and client initialization.
// In a real project, this would use environment variables and potentially
// handle server-side initialization differently for SSR requests vs client-side.

import { createClient } from "@supabase/supabase-js";
import { type Database } from "./db/database.types"; // Adjust path as needed
import type { Session } from "@supabase/supabase-js";

// --- Supabase Browser Client ---
// This client is used in React components that run in the browser.
// Use your actual Supabase URL and Anon Key from environment variables.
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL || "YOUR_SUPABASE_URL";
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY || "YOUR_SUPABASE_ANON_KEY";

export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey);

// --- Supabase Server Session Check (Astro SSR) ---
// This function is used in Astro pages/layouts/middleware for server-side checks.
// It simulates fetching the session from the request context.
// A proper implementation uses @supabase/ssr createServerClient.

export async function getSession(request: Request): Promise<Session | null> {
  // This is a simplified mock using cookies header.
  // A proper Supabase SSR setup is recommended.
  // Example using @supabase/ssr (requires setting up cookie handling):
  /*
  const supabaseServer = createServerClient<Database>(
    import.meta.env.SUPABASE_URL, // Server-side env var
    import.meta.env.SUPABASE_ANON_KEY, // Server-side env var
    {
      cookies: {
        get: (name: string) => {
          const cookie = request.headers.get('Cookie');
          if (!cookie) return undefined;
          const c = cookie.split(';').find(c => c.trim().startsWith(name + '='));
          return c ? c.split('=')[1] : undefined;
        },
        // set/remove are needed if you modify cookies server-side,
        // but get is sufficient for just checking the session from request.
        set: (name, value, options) => {},
        remove: (name) => {},
      },
    }
  );
  const { data: { session } } = await supabaseServer.auth.getSession();
  return session;
  */

  // Basic Mock Check (NOT SECURE FOR PRODUCTION): Checks for a mock cookie
  const cookies = request.headers.get("Cookie");
  if (cookies && (cookies.includes("sb-access-token") || cookies.includes("supabase-auth-token"))) {
    // Look for common Supabase cookies
    // Simulate a basic session object if cookies are present
    // In a real app, you'd decode the JWT or use the SSR client session object
    console.log("Simulating authenticated session based on cookies");
    return {
      access_token: "mock-token",
      refresh_token: "mock-refresh-token",
      expires_in: 3600,
      expires_at: Math.floor(Date.now() / 1000) + 3600,
      token_type: "Bearer",
      user: {
        id: "mock-user-id-from-cookie",
        aud: "authenticated",
        role: "authenticated",
        email: "user@example.com", // Mock email
        email_confirmed_at: new Date().toISOString(),
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        identities: [],
        app_metadata: {},
        user_metadata: {},
      },
    };
  }
  console.log("No authenticated session found");
  return null;
}



================================================
File: .history/src/auth_20250421133311.ts
================================================
// src/auth.ts
// Placeholder for Supabase session check logic and client initialization.
// In a real project, this would use environment variables and potentially
// handle server-side initialization differently for SSR requests vs client-side.

import { createClient } from "@supabase/supabase-js";
import { type Database } from "./db/database.types"; // Adjust path as needed
import type { Session } from "@supabase/supabase-js";

// --- Supabase Browser Client ---
// This client is used in React components that run in the browser.
// Use your actual Supabase URL and Anon Key from environment variables.
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL || "YOUR_SUPABASE_URL";
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY || "YOUR_SUPABASE_ANON_KEY";

export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey);

// --- Supabase Server Session Check (Astro SSR) ---
// This function is used in Astro pages/layouts/middleware for server-side checks.
// It simulates fetching the session from the request context.
// A proper implementation uses @supabase/ssr createServerClient.

export async function getSession(request: Request): Promise<Session | null> {
  // This is a simplified mock using cookies header.
  // A proper Supabase SSR setup is recommended.
  // Example using @supabase/ssr (requires setting up cookie handling):
  /*
  const supabaseServer = createServerClient<Database>(
    import.meta.env.SUPABASE_URL, // Server-side env var
    import.meta.env.SUPABASE_ANON_KEY, // Server-side env var
    {
      cookies: {
        get: (name: string) => {
          const cookie = request.headers.get('Cookie');
          if (!cookie) return undefined;
          const c = cookie.split(';').find(c => c.trim().startsWith(name + '='));
          return c ? c.split('=')[1] : undefined;
        },
        // set/remove are needed if you modify cookies server-side,
        // but get is sufficient for just checking the session from request.
        set: (name, value, options) => {},
        remove: (name) => {},
      },
    }
  );
  const { data: { session } } = await supabaseServer.auth.getSession();
  return session;
  */

  // Basic Mock Check (NOT SECURE FOR PRODUCTION): Checks for a mock cookie
  const cookies = request.headers.get("Cookie");
  if (cookies && (cookies.includes("sb-access-token") || cookies.includes("supabase-auth-token"))) {
    // Look for common Supabase cookies
    // Simulate a basic session object if cookies are present
    // In a real app, you'd decode the JWT or use the SSR client session object
    console.log("Simulating authenticated session based on cookies");
    return {
      access_token: "mock-token",
      refresh_token: "mock-refresh-token",
      expires_in: 3600,
      expires_at: Math.floor(Date.now() / 1000) + 3600,
      token_type: "Bearer",
      user: {
        id: "mock-user-id-from-cookie",
        aud: "authenticated",
        role: "authenticated",
        email: "user@example.com", // Mock email
        email_confirmed_at: new Date().toISOString(),
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        identities: [],
        app_metadata: {},
        user_metadata: {},
      },
    };
  }
  console.log("No authenticated session found");
  return null;
}



================================================
File: .history/src/auth_20250421133312.ts
================================================
// src/auth.ts
// Placeholder for Supabase session check logic and client initialization.
// In a real project, this would use environment variables and potentially
// handle server-side initialization differently for SSR requests vs client-side.

import { createClient } from "@supabase/supabase-js";
import { type Database } from "./db/database.types"; // Adjust path as needed
import type { Session } from "@supabase/supabase-js";

// --- Supabase Browser Client ---
// This client is used in React components that run in the browser.
// Use your actual Supabase URL and Anon Key from environment variables.
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL || "YOUR_SUPABASE_URL";
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY || "YOUR_SUPABASE_ANON_KEY";

export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey);

// --- Supabase Server Session Check (Astro SSR) ---
// This function is used in Astro pages/layouts/middleware for server-side checks.
// It simulates fetching the session from the request context.
// A proper implementation uses @supabase/ssr createServerClient.

export async function getSession(request: Request): Promise<Session | null> {
  // This is a simplified mock using cookies header.
  // A proper Supabase SSR setup is recommended.
  // Example using @supabase/ssr (requires setting up cookie handling):
  /*
  const supabaseServer = createServerClient<Database>(
    import.meta.env.SUPABASE_URL, // Server-side env var
    import.meta.env.SUPABASE_ANON_KEY, // Server-side env var
    {
      cookies: {
        get: (name: string) => {
          const cookie = request.headers.get('Cookie');
          if (!cookie) return undefined;
          const c = cookie.split(';').find(c => c.trim().startsWith(name + '='));
          return c ? c.split('=')[1] : undefined;
        },
        // set/remove are needed if you modify cookies server-side,
        // but get is sufficient for just checking the session from request.
        set: (name, value, options) => {},
        remove: (name) => {},
      },
    }
  );
  const { data: { session } } = await supabaseServer.auth.getSession();
  return session;
  */

  // Basic Mock Check (NOT SECURE FOR PRODUCTION): Checks for a mock cookie
  const cookies = request.headers.get("Cookie");
  if (cookies && (cookies.includes("sb-access-token") || cookies.includes("supabase-auth-token"))) {
    // Look for common Supabase cookies
    // Simulate a basic session object if cookies are present
    // In a real app, you'd decode the JWT or use the SSR client session object
    console.log("Simulating authenticated session based on cookies");
    return {
      access_token: "mock-token",
      refresh_token: "mock-refresh-token",
      expires_in: 3600,
      expires_at: Math.floor(Date.now() / 1000) + 3600,
      token_type: "Bearer",
      user: {
        id: "mock-user-id-from-cookie",
        aud: "authenticated",
        role: "authenticated",
        email: "user@example.com", // Mock email
        email_confirmed_at: new Date().toISOString(),
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        identities: [],
        app_metadata: {},
        user_metadata: {},
      },
    };
  }
  console.log("No authenticated session found");
  return null;
}



================================================
File: .history/src/auth_20250421133327.ts
================================================
// src/auth.ts
// Central module for Supabase client initialization and server-side session check.
// Contains both the browser-side client and the server-side getSession helper.

// Import createServerClient and the base SupabaseClient type from the SSR library
// Although the browser client is used primarily client-side, using createServerClient
// with `browser: true` is often recommended in SSR frameworks like Astro for cookie handling.
import { createServerClient, type SupabaseClient as SupabaseClientBase } from '@supabase/ssr';
import type { APIContext } from "astro"; // Import APIContext type for server-side context
import type { Session } from "@supabase/supabase-js";

// Import your local Database type
import type { Database } from "./db/database.types"; // Adjust path as needed


// Define the Supabase client type alias parameterized with your Database type
export type SupabaseClient = SupabaseClientBase<Database>;


// --- Supabase Browser Client ---
// This client is used in React components that run in the browser.
// It handles client-side session persistence (cookies/localStorage).
// Use your actual Supabase URL and Anon Key from environment variables (PUBLIC prefixed for client access).
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY;

// Use createServerClient for browser client to handle cookies properly in SSR environments
// Ensure env vars are checked (though Astro handles this somewhat via env.d.ts)
if (typeof window !== 'undefined' && (!supabaseUrl || !supabaseAnonKey)) {
   console.error("PUBLIC_SUPABASE_URL or PUBLIC_SUPABASE_ANON_KEY are not set for the browser client.");
   // In a real app, you might show an error message or handle this gracefully.
}


export const supabase = createServerClient<Database>(supabaseUrl, supabaseAnonKey, {
   browser: true, // Explicitly configure for browser environment
   cookies: {
      get: (name: string) => {
          // Basic browser cookie parsing (needed by createServerClient in browser mode)
          if (typeof document === 'undefined') return undefined;
          const match = document.cookie.split('; ').find(row => row.startsWith(name + '='));
          return match ? match.split('=')[1] : undefined;
      },
      set: (name, value, options) => {
          if (typeof document !== 'undefined') {
             document.cookie = `${name}=${value}; path=${options.path || '/'}; ${options.maxAge ? `Max-Age=${options.maxAge}` : ''} ${options.domain ? `Domain=${options.domain}` : ''} ${options.secure ? 'Secure' : ''} ${options.httpOnly ? 'HttpOnly' : ''} ${options.sameSite ? `SameSite=${options.sameSite}` : ''}`;
          }
      },
      remove: (name, options) => {
           if (typeof document !== 'undefined') {
             document.cookie = `${name}=; Max-Age=0; path=${options?.path || '/'}; ${options?.domain ? `Domain=${options.domain}` : ''} ${options?.secure ? 'Secure' : ''} ${options?.httpOnly ? 'HttpOnly' : ''} ${options?.sameSite ? `SameSite=${options.sameSite}` : ''}`;
           }
      },
   },
   global: {
       fetch: fetch.bind(globalThis), // Ensure fetch is bound to globalThis in browser
   }
});


// --- Supabase Server Session Check (Astro SSR) ---
// This function is used in Astro pages/layouts/middleware for server-side authentication checks for ROUTE ACCESS.
// It uses the Supabase client instance provided via context.locals by the middleware.

export async function getSession(context: APIContext): Promise<Session | null> {
  // Get the server-side Supabase client from context.locals
  const supabaseServer: SupabaseClient = context.locals.supabase;

  if (!supabaseServer) {
      console.error("getSession: Supabase client not found in context.locals. Ensure middleware is running.");
      // This indicates a critical setup error if middleware didn't run.
      return null;
  }

  // Use the server-side client to get the session from the request cookies
  // This checks if *any* user is authenticated for ROUTE protection.
  const { data: { session }, error: authError } = await supabaseServer.auth.getSession();

  if (authError) {
      console.error("getSession: Error fetching session on server:", authError);
      return null;
  }

  console.log(`getSession: Session found for route protection? ${!!session}`);
  return session;
}


================================================
File: .history/src/auth_20250421133432.ts
================================================
// src/auth.ts
// Placeholder for Supabase session check logic and client initialization.
// In a real project, this would use environment variables and potentially
// handle server-side initialization differently for SSR requests vs client-side.

import { createClient } from "@supabase/supabase-js";
import { type Database } from "./db/database.types"; // Adjust path as needed
import type { Session } from "@supabase/supabase-js";

// --- Supabase Browser Client ---
// This client is used in React components that run in the browser.
// Use your actual Supabase URL and Anon Key from environment variables.
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL || "YOUR_SUPABASE_URL";
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY || "YOUR_SUPABASE_ANON_KEY";

export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey);

// --- Supabase Server Session Check (Astro SSR) ---
// This function is used in Astro pages/layouts/middleware for server-side checks.
// It simulates fetching the session from the request context.
// A proper implementation uses @supabase/ssr createServerClient.

export async function getSession(request: Request): Promise<Session | null> {
  // This is a simplified mock using cookies header.
  // A proper Supabase SSR setup is recommended.
  // Example using @supabase/ssr (requires setting up cookie handling):
  /*
  const supabaseServer = createServerClient<Database>(
    import.meta.env.SUPABASE_URL, // Server-side env var
    import.meta.env.SUPABASE_ANON_KEY, // Server-side env var
    {
      cookies: {
        get: (name: string) => {
          const cookie = request.headers.get('Cookie');
          if (!cookie) return undefined;
          const c = cookie.split(';').find(c => c.trim().startsWith(name + '='));
          return c ? c.split('=')[1] : undefined;
        },
        // set/remove are needed if you modify cookies server-side,
        // but get is sufficient for just checking the session from request.
        set: (name, value, options) => {},
        remove: (name) => {},
      },
    }
  );
  const { data: { session } } = await supabaseServer.auth.getSession();
  return session;
  */

  // Basic Mock Check (NOT SECURE FOR PRODUCTION): Checks for a mock cookie
  const cookies = request.headers.get("Cookie");
  if (cookies && (cookies.includes("sb-access-token") || cookies.includes("supabase-auth-token"))) {
    // Look for common Supabase cookies
    // Simulate a basic session object if cookies are present
    // In a real app, you'd decode the JWT or use the SSR client session object
    console.log("Simulating authenticated session based on cookies");
    return {
      access_token: "mock-token",
      refresh_token: "mock-refresh-token",
      expires_in: 3600,
      expires_at: Math.floor(Date.now() / 1000) + 3600,
      token_type: "Bearer",
      user: {
        id: "mock-user-id-from-cookie",
        aud: "authenticated",
        role: "authenticated",
        email: "user@example.com", // Mock email
        email_confirmed_at: new Date().toISOString(),
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        identities: [],
        app_metadata: {},
        user_metadata: {},
      },
    };
  }
  console.log("No authenticated session found");
  return null;
}



================================================
File: .history/src/auth_20250421133433.ts
================================================
// src/auth.ts
// Placeholder for Supabase session check logic and client initialization.
// In a real project, this would use environment variables and potentially
// handle server-side initialization differently for SSR requests vs client-side.

import { createClient } from "@supabase/supabase-js";
import { type Database } from "./db/database.types"; // Adjust path as needed
import type { Session } from "@supabase/supabase-js";

// --- Supabase Browser Client ---
// This client is used in React components that run in the browser.
// Use your actual Supabase URL and Anon Key from environment variables.
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL || "YOUR_SUPABASE_URL";
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY || "YOUR_SUPABASE_ANON_KEY";

export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey);

// --- Supabase Server Session Check (Astro SSR) ---
// This function is used in Astro pages/layouts/middleware for server-side checks.
// It simulates fetching the session from the request context.
// A proper implementation uses @supabase/ssr createServerClient.

export async function getSession(request: Request): Promise<Session | null> {
  // This is a simplified mock using cookies header.
  // A proper Supabase SSR setup is recommended.
  // Example using @supabase/ssr (requires setting up cookie handling):
  /*
  const supabaseServer = createServerClient<Database>(
    import.meta.env.SUPABASE_URL, // Server-side env var
    import.meta.env.SUPABASE_ANON_KEY, // Server-side env var
    {
      cookies: {
        get: (name: string) => {
          const cookie = request.headers.get('Cookie');
          if (!cookie) return undefined;
          const c = cookie.split(';').find(c => c.trim().startsWith(name + '='));
          return c ? c.split('=')[1] : undefined;
        },
        // set/remove are needed if you modify cookies server-side,
        // but get is sufficient for just checking the session from request.
        set: (name, value, options) => {},
        remove: (name) => {},
      },
    }
  );
  const { data: { session } } = await supabaseServer.auth.getSession();
  return session;
  */

  // Basic Mock Check (NOT SECURE FOR PRODUCTION): Checks for a mock cookie
  const cookies = request.headers.get("Cookie");
  if (cookies && (cookies.includes("sb-access-token") || cookies.includes("supabase-auth-token"))) {
    // Look for common Supabase cookies
    // Simulate a basic session object if cookies are present
    // In a real app, you'd decode the JWT or use the SSR client session object
    console.log("Simulating authenticated session based on cookies");
    return {
      access_token: "mock-token",
      refresh_token: "mock-refresh-token",
      expires_in: 3600,
      expires_at: Math.floor(Date.now() / 1000) + 3600,
      token_type: "Bearer",
      user: {
        id: "mock-user-id-from-cookie",
        aud: "authenticated",
        role: "authenticated",
        email: "user@example.com", // Mock email
        email_confirmed_at: new Date().toISOString(),
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        identities: [],
        app_metadata: {},
        user_metadata: {},
      },
    };
  }
  console.log("No authenticated session found");
  return null;
}



================================================
File: .history/src/auth_20250421133459.ts
================================================
// src/auth.ts
// Placeholder for Supabase session check logic and client initialization.
// In a real project, this would use environment variables and potentially
// handle server-side initialization differently for SSR requests vs client-side.

import { createClient } from "@supabase/supabase-js";
import { type Database } from "./db/database.types"; // Adjust path as needed
import type { Session } from "@supabase/supabase-js";

// --- Supabase Browser Client ---
// This client is used in React components that run in the browser.
// Use your actual Supabase URL and Anon Key from environment variables.// src/auth.ts
// Central module for Supabase client initialization and server-side session check.
// Contains both the browser-side client and the server-side getSession helper.

// Import createServerClient and the base SupabaseClient type from the SSR library
// Although the browser client is used primarily client-side, using createServerClient
// with `browser: true` is often recommended in SSR frameworks like Astro for cookie handling.
import { createServerClient, type SupabaseClient as SupabaseClientBase } from "@supabase/ssr";
import type { APIContext } from "astro"; // Import APIContext type for server-side context
import type { Session } from "@supabase/supabase-js";

// Import your local Database type
import type { Database } from "./db/database.types"; // Adjust path as needed

// Define the Supabase client type alias parameterized with your Database type
export type SupabaseClient = SupabaseClientBase<Database>;

// --- Supabase Browser Client ---
// This client is used in React components that run in the browser.
// It handles client-side session persistence (cookies/localStorage).
// Use your actual Supabase URL and Anon Key from environment variables (PUBLIC prefixed for client access).
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY;

// Use createServerClient for browser client to handle cookies properly in SSR environments
// Ensure env vars are checked (though Astro handles this somewhat via env.d.ts)
if (typeof window !== "undefined" && (!supabaseUrl || !supabaseAnonKey)) {
  console.error("PUBLIC_SUPABASE_URL or PUBLIC_SUPABASE_ANON_KEY are not set for the browser client.");
  // In a real app, you might show an error message or handle this gracefully.
}

export const supabase = createServerClient<Database>(supabaseUrl, supabaseAnonKey, {
  browser: true, // Explicitly configure for browser environment
  cookies: {
    get: (name: string) => {
      // Basic browser cookie parsing (needed by createServerClient in browser mode)
      if (typeof document === "undefined") return undefined;
      const match = document.cookie.split("; ").find((row) => row.startsWith(name + "="));
      return match ? match.split("=")[1] : undefined;
    },
    set: (name, value, options) => {
      if (typeof document !== "undefined") {
        document.cookie = `${name}=${value}; path=${options.path || "/"}; ${options.maxAge ? `Max-Age=${options.maxAge}` : ""} ${options.domain ? `Domain=${options.domain}` : ""} ${options.secure ? "Secure" : ""} ${options.httpOnly ? "HttpOnly" : ""} ${options.sameSite ? `SameSite=${options.sameSite}` : ""}`;
      }
    },
    remove: (name, options) => {
      if (typeof document !== "undefined") {
        document.cookie = `${name}=; Max-Age=0; path=${options?.path || "/"}; ${options?.domain ? `Domain=${options.domain}` : ""} ${options?.secure ? "Secure" : ""} ${options?.httpOnly ? "HttpOnly" : ""} ${options?.sameSite ? `SameSite=${options.sameSite}` : ""}`;
      }
    },
  },
  global: {
    fetch: fetch.bind(globalThis), // Ensure fetch is bound to globalThis in browser
  },
});

// --- Supabase Server Session Check (Astro SSR) ---
// This function is used in Astro pages/layouts/middleware for server-side authentication checks for ROUTE ACCESS.
// It uses the Supabase client instance provided via context.locals by the middleware.

export async function getSession(context: APIContext): Promise<Session | null> {
  // Get the server-side Supabase client from context.locals
  const supabaseServer: SupabaseClient = context.locals.supabase;

  if (!supabaseServer) {
    console.error("getSession: Supabase client not found in context.locals. Ensure middleware is running.");
    // This indicates a critical setup error if middleware didn't run.
    return null;
  }

  // Use the server-side client to get the session from the request cookies
  // This checks if *any* user is authenticated for ROUTE protection.
  const {
    data: { session },
    error: authError,
  } = await supabaseServer.auth.getSession();

  if (authError) {
    console.error("getSession: Error fetching session on server:", authError);
    return null;
  }

  console.log(`getSession: Session found for route protection? ${!!session}`);
  return session;
}
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL || "YOUR_SUPABASE_URL";
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY || "YOUR_SUPABASE_ANON_KEY";

export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey);

// --- Supabase Server Session Check (Astro SSR) ---
// This function is used in Astro pages/layouts/middleware for server-side checks.
// It simulates fetching the session from the request context.
// A proper implementation uses @supabase/ssr createServerClient.

export async function getSession(request: Request): Promise<Session | null> {
  // This is a simplified mock using cookies header.
  // A proper Supabase SSR setup is recommended.
  // Example using @supabase/ssr (requires setting up cookie handling):
  /*
  const supabaseServer = createServerClient<Database>(
    import.meta.env.SUPABASE_URL, // Server-side env var
    import.meta.env.SUPABASE_ANON_KEY, // Server-side env var
    {
      cookies: {
        get: (name: string) => {
          const cookie = request.headers.get('Cookie');
          if (!cookie) return undefined;
          const c = cookie.split(';').find(c => c.trim().startsWith(name + '='));
          return c ? c.split('=')[1] : undefined;
        },
        // set/remove are needed if you modify cookies server-side,
        // but get is sufficient for just checking the session from request.
        set: (name, value, options) => {},
        remove: (name) => {},
      },
    }
  );
  const { data: { session } } = await supabaseServer.auth.getSession();
  return session;
  */

  // Basic Mock Check (NOT SECURE FOR PRODUCTION): Checks for a mock cookie
  const cookies = request.headers.get("Cookie");
  if (cookies && (cookies.includes("sb-access-token") || cookies.includes("supabase-auth-token"))) {
    // Look for common Supabase cookies
    // Simulate a basic session object if cookies are present
    // In a real app, you'd decode the JWT or use the SSR client session object
    console.log("Simulating authenticated session based on cookies");
    return {
      access_token: "mock-token",
      refresh_token: "mock-refresh-token",
      expires_in: 3600,
      expires_at: Math.floor(Date.now() / 1000) + 3600,
      token_type: "Bearer",
      user: {
        id: "mock-user-id-from-cookie",
        aud: "authenticated",
        role: "authenticated",
        email: "user@example.com", // Mock email
        email_confirmed_at: new Date().toISOString(),
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        identities: [],
        app_metadata: {},
        user_metadata: {},
      },
    };
  }
  console.log("No authenticated session found");
  return null;
}



================================================
File: .history/src/auth_20250421133541.ts
================================================
// src/auth.ts
// Placeholder for Supabase session check logic and client initialization.
// In a real project, this would use environment variables and potentially
// handle server-side initialization differently for SSR requests vs client-side.

import { createClient } from "@supabase/supabase-js";
import { type Database } from "./db/database.types"; // Adjust path as needed
import type { Session } from "@supabase/supabase-js";

// --- Supabase Browser Client ---
// This client is used in React components that run in the browser.
// Use your actual Supabase URL and Anon Key from environment variables.// src/auth.ts
// Central module for Supabase client initialization and server-side session check.
// Contains both the browser-side client and the server-side getSession helper.

// Import createServerClient and the base SupabaseClient type from the SSR library
// Although the browser client is used primarily client-side, using createServerClient
// with `browser: true` is often recommended in SSR frameworks like Astro for cookie handling.
import { createServerClient, type SupabaseClient as SupabaseClientBase } from "@supabase/ssr";
import type { APIContext } from "astro"; // Import APIContext type for server-side context
import type { Session } from "@supabase/supabase-js";

// Import your local Database type
import type { Database } from "./db/database.types"; // Adjust path as needed

// Define the Supabase client type alias parameterized with your Database type
export type SupabaseClient = SupabaseClientBase<Database>;

// --- Supabase Browser Client ---
// This client is used in React components that run in the browser.
// It handles client-side session persistence (cookies/localStorage).
// Use your actual Supabase URL and Anon Key from environment variables (PUBLIC prefixed for client access).
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY;

// Use createServerClient for browser client to handle cookies properly in SSR environments
// Ensure env vars are checked (though Astro handles this somewhat via env.d.ts)
if (typeof window !== "undefined" && (!supabaseUrl || !supabaseAnonKey)) {
  console.error("PUBLIC_SUPABASE_URL or PUBLIC_SUPABASE_ANON_KEY are not set for the browser client.");
  // In a real app, you might show an error message or handle this gracefully.
}

export const supabase = createServerClient<Database>(supabaseUrl, supabaseAnonKey, {
  browser: true, // Explicitly configure for browser environment
  cookies: {
    get: (name: string) => {
      // Basic browser cookie parsing (needed by createServerClient in browser mode)
      if (typeof document === "undefined") return undefined;
      const match = document.cookie.split("; ").find((row) => row.startsWith(name + "="));
      return match ? match.split("=")[1] : undefined;
    },
    set: (name, value, options) => {
      if (typeof document !== "undefined") {
        document.cookie = `${name}=${value}; path=${options.path || "/"}; ${options.maxAge ? `Max-Age=${options.maxAge}` : ""} ${options.domain ? `Domain=${options.domain}` : ""} ${options.secure ? "Secure" : ""} ${options.httpOnly ? "HttpOnly" : ""} ${options.sameSite ? `SameSite=${options.sameSite}` : ""}`;
      }
    },
    remove: (name, options) => {
      if (typeof document !== "undefined") {
        document.cookie = `${name}=; Max-Age=0; path=${options?.path || "/"}; ${options?.domain ? `Domain=${options.domain}` : ""} ${options?.secure ? "Secure" : ""} ${options?.httpOnly ? "HttpOnly" : ""} ${options?.sameSite ? `SameSite=${options.sameSite}` : ""}`;
      }
    },
  },
  global: {
    fetch: fetch.bind(globalThis), // Ensure fetch is bound to globalThis in browser
  },
});

// --- Supabase Server Session Check (Astro SSR) ---
// This function is used in Astro pages/layouts/middleware for server-side authentication checks for ROUTE ACCESS.
// It uses the Supabase client instance provided via context.locals by the middleware.

export async function getSession(context: APIContext): Promise<Session | null> {
  // Get the server-side Supabase client from context.locals
  const supabaseServer: SupabaseClient = context.locals.supabase;

  if (!supabaseServer) {
    console.error("getSession: Supabase client not found in context.locals. Ensure middleware is running.");
    // This indicates a critical setup error if middleware didn't run.
    return null;
  }

  // Use the server-side client to get the session from the request cookies
  // This checks if *any* user is authenticated for ROUTE protection.
  const {
    data: { session },
    error: authError,
  } = await supabaseServer.auth.getSession();

  if (authError) {
    console.error("getSession: Error fetching session on server:", authError);
    return null;
  }

  console.log(`getSession: Session found for route protection? ${!!session}`);
  return session;
}
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL || "YOUR_SUPABASE_URL";
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY || "YOUR_SUPABASE_ANON_KEY";

export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey);

// --- Supabase Server Session Check (Astro SSR) ---
// This function is used in Astro pages/layouts/middleware for server-side checks.
// It simulates fetching the session from the request context.
// A proper implementation uses @supabase/ssr createServerClient.

export async function getSession(request: Request): Promise<Session | null> {
  // This is a simplified mock using cookies header.
  // A proper Supabase SSR setup is recommended.
  // Example using @supabase/ssr (requires setting up cookie handling):
  /*
  const supabaseServer = createServerClient<Database>(
    import.meta.env.SUPABASE_URL, // Server-side env var
    import.meta.env.SUPABASE_ANON_KEY, // Server-side env var
    {
      cookies: {
        get: (name: string) => {
          const cookie = request.headers.get('Cookie');
          if (!cookie) return undefined;
          const c = cookie.split(';').find(c => c.trim().startsWith(name + '='));
          return c ? c.split('=')[1] : undefined;
        },
        // set/remove are needed if you modify cookies server-side,
        // but get is sufficient for just checking the session from request.
        set: (name, value, options) => {},
        remove: (name) => {},
      },
    }
  );
  const { data: { session } } = await supabaseServer.auth.getSession();
  return session;
  */

  // Basic Mock Check (NOT SECURE FOR PRODUCTION): Checks for a mock cookie
  const cookies = request.headers.get("Cookie");
  if (cookies && (cookies.includes("sb-access-token") || cookies.includes("supabase-auth-token"))) {
    // Look for common Supabase cookies
    // Simulate a basic session object if cookies are present
    // In a real app, you'd decode the JWT or use the SSR client session object
    console.log("Simulating authenticated session based on cookies");
    return {
      access_token: "mock-token",
      refresh_token: "mock-refresh-token",
      expires_in: 3600,
      expires_at: Math.floor(Date.now() / 1000) + 3600,
      token_type: "Bearer",
      user: {
        id: "mock-user-id-from-cookie",
        aud: "authenticated",
        role: "authenticated",
        email: "user@example.com", // Mock email
        email_confirmed_at: new Date().toISOString(),
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        identities: [],
        app_metadata: {},
        user_metadata: {},
      },
    };
  }
  console.log("No authenticated session found");
  return null;
}



================================================
File: .history/src/auth_20250421134605.ts
================================================
// src/auth.ts
// Central module for Supabase client initialization and server-side session check.

// Import createServerClient and the base SupabaseClient type from the SSR library
// Using createServerClient with `browser: true` is recommended in SSR frameworks like Astro for cookie handling.
import { createServerClient, type SupabaseClient as SupabaseClientBase } from "@supabase/ssr";
import type { APIContext } from "astro"; // Import APIContext type for server-side context
import type { Session } from "@supabase/supabase-js";

// Import your local Database type
import type { Database } from "./db/database.types"; // Adjust path as needed

// Define the Supabase client type alias parameterized with your Database type
export type SupabaseClient = SupabaseClientBase<Database>;

// --- Supabase Browser Client Instance ---
// This client instance is used in React components that run in the browser.
// It handles client-side session persistence (cookies/localStorage).
// Use your actual Supabase URL and Anon Key from environment variables (PUBLIC prefixed for client access).
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY;

// Ensure env vars are checked in development, though Astro handles this somewhat via env.d.ts
if (typeof window !== "undefined" && import.meta.env.DEV && (!supabaseUrl || !supabaseAnonKey)) {
  console.warn(
    "PUBLIC_SUPABASE_URL or PUBLIC_SUPABASE_ANON_KEY are not set for the browser client. API calls may fail."
  );
}

// Initialize the browser client instance
export const supabase = createServerClient<Database>(supabaseUrl, supabaseAnonKey, {
  browser: true, // Explicitly configure for browser environment
  cookies: {
    get: (name: string) => {
      // Basic browser cookie parsing (needed by createServerClient in browser mode)
      if (typeof document === "undefined") return undefined;
      const match = document.cookie.split("; ").find((row) => row.trim().startsWith(name + "="));
      return match ? match.split("=")[1] : undefined;
    },
    // Supabase SDK manages set/remove in browser with createServerClient(..., { browser: true })
    // You typically don't need to provide custom set/remove for the browser client
    // unless you have very specific cookie requirements.
    // Let's remove them and let the SDK handle it.
    /*
      set: (name, value, options) => {
          if (typeof document !== 'undefined') {
             let cookieString = `${name}=${value}; path=${options.path || '/'}`;
             if (options.maxAge) cookieString += `; Max-Age=${options.maxAge}`;
             if (options.domain) cookieString += `; Domain=${options.domain}`;
             if (options.secure) cookieString += `; Secure`;
             if (options.httpOnly) cookieString += `; HttpOnly`; // Note: HttpOnly cookies are not readable by client JS
             if (options.sameSite) cookieString += `; SameSite=${options.sameSite}`;
             document.cookie = cookieString;
          }
      },
      remove: (name, options) => {
           if (typeof document !== 'undefined') {
             let cookieString = `${name}=; Max-Age=0; path=${options?.path || '/'}`;
             if (options?.domain) cookieString += `; Domain=${options.domain}`;
             if (options?.secure) cookieString += `; Secure`;
             if (options?.httpOnly) cookieString += `; HttpOnly`;
             if (options?.sameSite) cookieString += `; SameSite=${options.sameSite}`;
             document.cookie = cookieString;
           }
      },
      */
  },
  global: {
    fetch: fetch.bind(globalThis), // Ensure fetch is bound to globalThis in browser
  },
});

// --- Supabase Server Session Check Helper (Astro SSR) ---
// This function is used in Astro pages/layouts for server-side authentication checks for ROUTE ACCESS.
// It requires the APIContext to access the server-side Supabase client provided by the middleware.

export async function getSession(context: APIContext): Promise<Session | null> {
  // Get the server-side Supabase client instance from context.locals
  const supabaseServer: SupabaseClient = context.locals.supabase;

  if (!supabaseServer) {
    console.error(
      "getSession: Supabase client not found in context.locals. Ensure middleware is running and setting 'context.locals.supabase'."
    );
    // This indicates a critical setup error if middleware didn't run.
    return null;
  }

  // Use the server-side client to get the session from the request cookies
  // This checks if *any* user is authenticated for ROUTE protection.
  const {
    data: { session },
    error: authError,
  } = await supabaseServer.auth.getSession();

  if (authError) {
    console.error("getSession: Error fetching session on server:", authError);
    return null;
  }

  console.log(`getSession: Session found for route protection? ${!!session}`);
  return session;
}



================================================
File: .history/src/auth_20250421134917.ts
================================================
// src/auth.ts
// Central module for Supabase client initialization and server-side session check.

// Import createServerClient and the base SupabaseClient type from the SSR library
// Using createServerClient with `browser: true` is recommended in SSR frameworks like Astro for cookie handling.
import { createBrowserClient, type SupabaseClient as SupabaseClientBase } from "@supabase/auth-helpers-shared";
import type { APIContext } from "astro"; // Import APIContext type for server-side context
import type { Session } from "@supabase/supabase-js";

// Import your local Database type
import type { Database } from "./db/database.types"; // Adjust path as needed

// Define the Supabase client type alias parameterized with your Database type
export type SupabaseClient = SupabaseClientBase<Database>;

// --- Supabase Browser Client Instance ---
// This client instance is used in React components that run in the browser.
// It handles client-side session persistence (cookies/localStorage).
// Use your actual Supabase URL and Anon Key from environment variables (PUBLIC prefixed for client access).
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY;

// Ensure env vars are checked in development, though Astro handles this somewhat via env.d.ts
if (typeof window !== "undefined" && import.meta.env.DEV && (!supabaseUrl || !supabaseAnonKey)) {
  console.warn(
    "PUBLIC_SUPABASE_URL or PUBLIC_SUPABASE_ANON_KEY are not set for the browser client. API calls may fail."
  );
}

// Initialize the browser client instance
export const supabase = createBrowserClient<Database>(supabaseUrl, supabaseAnonKey, {
  browser: true, // Explicitly configure for browser environment
  cookies: {
    get: (name: string) => {
      // Basic browser cookie parsing (needed by createServerClient in browser mode)
      if (typeof document === "undefined") return undefined;
      const match = document.cookie.split("; ").find((row) => row.trim().startsWith(name + "="));
      return match ? match.split("=")[1] : undefined;
    },
    // Supabase SDK manages set/remove in browser with createServerClient(..., { browser: true })
    // You typically don't need to provide custom set/remove for the browser client
    // unless you have very specific cookie requirements.
    // Let's remove them and let the SDK handle it.
    /*
      set: (name, value, options) => {
          if (typeof document !== 'undefined') {
             let cookieString = `${name}=${value}; path=${options.path || '/'}`;
             if (options.maxAge) cookieString += `; Max-Age=${options.maxAge}`;
             if (options.domain) cookieString += `; Domain=${options.domain}`;
             if (options.secure) cookieString += `; Secure`;
             if (options.httpOnly) cookieString += `; HttpOnly`; // Note: HttpOnly cookies are not readable by client JS
             if (options.sameSite) cookieString += `; SameSite=${options.sameSite}`;
             document.cookie = cookieString;
          }
      },
      remove: (name, options) => {
           if (typeof document !== 'undefined') {
             let cookieString = `${name}=; Max-Age=0; path=${options?.path || '/'}`;
             if (options?.domain) cookieString += `; Domain=${options.domain}`;
             if (options?.secure) cookieString += `; Secure`;
             if (options?.httpOnly) cookieString += `; HttpOnly`;
             if (options?.sameSite) cookieString += `; SameSite=${options.sameSite}`;
             document.cookie = cookieString;
           }
      },
      */
  },
  global: {
    fetch: fetch.bind(globalThis), // Ensure fetch is bound to globalThis in browser
  },
});

// --- Supabase Server Session Check Helper (Astro SSR) ---
// This function is used in Astro pages/layouts for server-side authentication checks for ROUTE ACCESS.
// It requires the APIContext to access the server-side Supabase client provided by the middleware.

export async function getSession(context: APIContext): Promise<Session | null> {
  // Get the server-side Supabase client instance from context.locals
  const supabaseServer: SupabaseClient = context.locals.supabase;

  if (!supabaseServer) {
    console.error(
      "getSession: Supabase client not found in context.locals. Ensure middleware is running and setting 'context.locals.supabase'."
    );
    // This indicates a critical setup error if middleware didn't run.
    return null;
  }

  // Use the server-side client to get the session from the request cookies
  // This checks if *any* user is authenticated for ROUTE protection.
  const {
    data: { session },
    error: authError,
  } = await supabaseServer.auth.getSession();

  if (authError) {
    console.error("getSession: Error fetching session on server:", authError);
    return null;
  }

  console.log(`getSession: Session found for route protection? ${!!session}`);
  return session;
}



================================================
File: .history/src/auth_20250421135118.ts
================================================
// src/auth.ts
// Central module for Supabase client initialization and server-side session check.

// Import createServerClient and the base SupabaseClient type from the SSR library
// Using createServerClient with `browser: true` is recommended in SSR frameworks like Astro for cookie handling.
import { createBrowserClient } from "@supabase/supabase-js";
import type { SupabaseClient as SupabaseClientBase } from "@supabase/supabase-js";
import type { APIContext } from "astro"; // Import APIContext type for server-side context
import type { Session } from "@supabase/supabase-js";

// Import your local Database type
import type { Database } from "./db/database.types"; // Adjust path as needed

// Define the Supabase client type alias parameterized with your Database type
export type SupabaseClient = SupabaseClientBase<Database>;

// --- Supabase Browser Client Instance ---
// This client instance is used in React components that run in the browser.
// It handles client-side session persistence (cookies/localStorage).
// Use your actual Supabase URL and Anon Key from environment variables (PUBLIC prefixed for client access).
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY;

// Ensure env vars are checked in development, though Astro handles this somewhat via env.d.ts
if (typeof window !== "undefined" && import.meta.env.DEV && (!supabaseUrl || !supabaseAnonKey)) {
  console.warn(
    "PUBLIC_SUPABASE_URL or PUBLIC_SUPABASE_ANON_KEY are not set for the browser client. API calls may fail."
  );
}

// Initialize the browser client instance
export const supabase = createBrowserClient<Database>(supabaseUrl, supabaseAnonKey, {
  browser: true, // Explicitly configure for browser environment
  cookies: {
    get: (name: string) => {
      // Basic browser cookie parsing (needed by createServerClient in browser mode)
      if (typeof document === "undefined") return undefined;
      const match = document.cookie.split("; ").find((row) => row.trim().startsWith(name + "="));
      return match ? match.split("=")[1] : undefined;
    },
    // Supabase SDK manages set/remove in browser with createServerClient(..., { browser: true })
    // You typically don't need to provide custom set/remove for the browser client
    // unless you have very specific cookie requirements.
    // Let's remove them and let the SDK handle it.
    /*
      set: (name, value, options) => {
          if (typeof document !== 'undefined') {
             let cookieString = `${name}=${value}; path=${options.path || '/'}`;
             if (options.maxAge) cookieString += `; Max-Age=${options.maxAge}`;
             if (options.domain) cookieString += `; Domain=${options.domain}`;
             if (options.secure) cookieString += `; Secure`;
             if (options.httpOnly) cookieString += `; HttpOnly`; // Note: HttpOnly cookies are not readable by client JS
             if (options.sameSite) cookieString += `; SameSite=${options.sameSite}`;
             document.cookie = cookieString;
          }
      },
      remove: (name, options) => {
           if (typeof document !== 'undefined') {
             let cookieString = `${name}=; Max-Age=0; path=${options?.path || '/'}`;
             if (options?.domain) cookieString += `; Domain=${options.domain}`;
             if (options?.secure) cookieString += `; Secure`;
             if (options?.httpOnly) cookieString += `; HttpOnly`;
             if (options?.sameSite) cookieString += `; SameSite=${options.sameSite}`;
             document.cookie = cookieString;
           }
      },
      */
  },
  global: {
    fetch: fetch.bind(globalThis), // Ensure fetch is bound to globalThis in browser
  },
});

// --- Supabase Server Session Check Helper (Astro SSR) ---
// This function is used in Astro pages/layouts for server-side authentication checks for ROUTE ACCESS.
// It requires the APIContext to access the server-side Supabase client provided by the middleware.

export async function getSession(context: APIContext): Promise<Session | null> {
  // Get the server-side Supabase client instance from context.locals
  const supabaseServer: SupabaseClient = context.locals.supabase;

  if (!supabaseServer) {
    console.error(
      "getSession: Supabase client not found in context.locals. Ensure middleware is running and setting 'context.locals.supabase'."
    );
    // This indicates a critical setup error if middleware didn't run.
    return null;
  }

  // Use the server-side client to get the session from the request cookies
  // This checks if *any* user is authenticated for ROUTE protection.
  const {
    data: { session },
    error: authError,
  } = await supabaseServer.auth.getSession();

  if (authError) {
    console.error("getSession: Error fetching session on server:", authError);
    return null;
  }

  console.log(`getSession: Session found for route protection? ${!!session}`);
  return session;
}



================================================
File: .history/src/auth_20250421135154.ts
================================================
// src/auth.ts
// Central module for Supabase client initialization and server-side session check.

// Import createServerClient and the base SupabaseClient type from the SSR library
// Using createServerClient with `browser: true` is recommended in SSR frameworks like Astro for cookie handling.
import { createClient } from "@supabase/supabase-js";
import type { SupabaseClient as SupabaseClientBase } from "@supabase/supabase-js";
import type { APIContext } from "astro"; // Import APIContext type for server-side context
import type { Session } from "@supabase/supabase-js";

// Import your local Database type
import type { Database } from "./db/database.types"; // Adjust path as needed

// Define the Supabase client type alias parameterized with your Database type
export type SupabaseClient = SupabaseClientBase<Database>;

// --- Supabase Browser Client Instance ---
// This client instance is used in React components that run in the browser.
// It handles client-side session persistence (cookies/localStorage).
// Use your actual Supabase URL and Anon Key from environment variables (PUBLIC prefixed for client access).
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY;

// Ensure env vars are checked in development, though Astro handles this somewhat via env.d.ts
if (typeof window !== "undefined" && import.meta.env.DEV && (!supabaseUrl || !supabaseAnonKey)) {
  console.warn(
    "PUBLIC_SUPABASE_URL or PUBLIC_SUPABASE_ANON_KEY are not set for the browser client. API calls may fail."
  );
}

// Initialize the browser client instance
export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey, {
  browser: true, // Explicitly configure for browser environment
  cookies: {
    get: (name: string) => {
      // Basic browser cookie parsing (needed by createServerClient in browser mode)
      if (typeof document === "undefined") return undefined;
      const match = document.cookie.split("; ").find((row) => row.trim().startsWith(name + "="));
      return match ? match.split("=")[1] : undefined;
    },
    // Supabase SDK manages set/remove in browser with createServerClient(..., { browser: true })
    // You typically don't need to provide custom set/remove for the browser client
    // unless you have very specific cookie requirements.
    // Let's remove them and let the SDK handle it.
    /*
      set: (name, value, options) => {
          if (typeof document !== 'undefined') {
             let cookieString = `${name}=${value}; path=${options.path || '/'}`;
             if (options.maxAge) cookieString += `; Max-Age=${options.maxAge}`;
             if (options.domain) cookieString += `; Domain=${options.domain}`;
             if (options.secure) cookieString += `; Secure`;
             if (options.httpOnly) cookieString += `; HttpOnly`; // Note: HttpOnly cookies are not readable by client JS
             if (options.sameSite) cookieString += `; SameSite=${options.sameSite}`;
             document.cookie = cookieString;
          }
      },
      remove: (name, options) => {
           if (typeof document !== 'undefined') {
             let cookieString = `${name}=; Max-Age=0; path=${options?.path || '/'}`;
             if (options?.domain) cookieString += `; Domain=${options.domain}`;
             if (options?.secure) cookieString += `; Secure`;
             if (options?.httpOnly) cookieString += `; HttpOnly`;
             if (options?.sameSite) cookieString += `; SameSite=${options.sameSite}`;
             document.cookie = cookieString;
           }
      },
      */
  },
  global: {
    fetch: fetch.bind(globalThis), // Ensure fetch is bound to globalThis in browser
  },
});

// --- Supabase Server Session Check Helper (Astro SSR) ---
// This function is used in Astro pages/layouts for server-side authentication checks for ROUTE ACCESS.
// It requires the APIContext to access the server-side Supabase client provided by the middleware.

export async function getSession(context: APIContext): Promise<Session | null> {
  // Get the server-side Supabase client instance from context.locals
  const supabaseServer: SupabaseClient = context.locals.supabase;

  if (!supabaseServer) {
    console.error(
      "getSession: Supabase client not found in context.locals. Ensure middleware is running and setting 'context.locals.supabase'."
    );
    // This indicates a critical setup error if middleware didn't run.
    return null;
  }

  // Use the server-side client to get the session from the request cookies
  // This checks if *any* user is authenticated for ROUTE protection.
  const {
    data: { session },
    error: authError,
  } = await supabaseServer.auth.getSession();

  if (authError) {
    console.error("getSession: Error fetching session on server:", authError);
    return null;
  }

  console.log(`getSession: Session found for route protection? ${!!session}`);
  return session;
}



================================================
File: .history/src/auth_20250421135202.ts
================================================
// src/auth.ts
// Central module for Supabase client initialization and server-side session check.

// Import createServerClient and the base SupabaseClient type from the SSR library
// Using createServerClient with `browser: true` is recommended in SSR frameworks like Astro for cookie handling.
import { createClient } from "@supabase/supabase-js";
import type { SupabaseClient as SupabaseClientBase } from "@supabase/supabase-js";
import type { APIContext } from "astro"; // Import APIContext type for server-side context
import type { Session } from "@supabase/supabase-js";

// Import your local Database type
import type { Database } from "./db/database.types"; // Adjust path as needed

// Define the Supabase client type alias parameterized with your Database type
export type SupabaseClient = SupabaseClientBase<Database>;

// --- Supabase Browser Client Instance ---
// This client instance is used in React components that run in the browser.
// It handles client-side session persistence (cookies/localStorage).
// Use your actual Supabase URL and Anon Key from environment variables (PUBLIC prefixed for client access).
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY;

// Ensure env vars are checked in development, though Astro handles this somewhat via env.d.ts
if (typeof window !== "undefined" && import.meta.env.DEV && (!supabaseUrl || !supabaseAnonKey)) {
  console.warn(
    "PUBLIC_SUPABASE_URL or PUBLIC_SUPABASE_ANON_KEY are not set for the browser client. API calls may fail."
  );
}

// Initialize the browser client instance
export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey, {
  browser: true, // Explicitly configure for browser environment
  cookies: {
    get: (name: string) => {
      // Basic browser cookie parsing (needed by createServerClient in browser mode)
      if (typeof document === "undefined") return undefined;
      const match = document.cookie.split("; ").find((row) => row.trim().startsWith(name + "="));
      return match ? match.split("=")[1] : undefined;
    },
    // Supabase SDK manages set/remove in browser with createServerClient(..., { browser: true })
    // You typically don't need to provide custom set/remove for the browser client
    // unless you have very specific cookie requirements.
    // Let's remove them and let the SDK handle it.
    /*
      set: (name, value, options) => {
          if (typeof document !== 'undefined') {
             let cookieString = `${name}=${value}; path=${options.path || '/'}`;
             if (options.maxAge) cookieString += `; Max-Age=${options.maxAge}`;
             if (options.domain) cookieString += `; Domain=${options.domain}`;
             if (options.secure) cookieString += `; Secure`;
             if (options.httpOnly) cookieString += `; HttpOnly`; // Note: HttpOnly cookies are not readable by client JS
             if (options.sameSite) cookieString += `; SameSite=${options.sameSite}`;
             document.cookie = cookieString;
          }
      },
      remove: (name, options) => {
           if (typeof document !== 'undefined') {
             let cookieString = `${name}=; Max-Age=0; path=${options?.path || '/'}`;
             if (options?.domain) cookieString += `; Domain=${options.domain}`;
             if (options?.secure) cookieString += `; Secure`;
             if (options?.httpOnly) cookieString += `; HttpOnly`;
             if (options?.sameSite) cookieString += `; SameSite=${options.sameSite}`;
             document.cookie = cookieString;
           }
      },
      */
  },
  global: {
    fetch: fetch.bind(globalThis), // Ensure fetch is bound to globalThis in browser
  },
});

// --- Supabase Server Session Check Helper (Astro SSR) ---
// This function is used in Astro pages/layouts for server-side authentication checks for ROUTE ACCESS.
// It requires the APIContext to access the server-side Supabase client provided by the middleware.

export async function getSession(context: APIContext): Promise<Session | null> {
  // Get the server-side Supabase client instance from context.locals
  const supabaseServer: SupabaseClient = context.locals.supabase;

  if (!supabaseServer) {
    console.error(
      "getSession: Supabase client not found in context.locals. Ensure middleware is running and setting 'context.locals.supabase'."
    );
    // This indicates a critical setup error if middleware didn't run.
    return null;
  }

  // Use the server-side client to get the session from the request cookies
  // This checks if *any* user is authenticated for ROUTE protection.
  const {
    data: { session },
    error: authError,
  } = await supabaseServer.auth.getSession();

  if (authError) {
    console.error("getSession: Error fetching session on server:", authError);
    return null;
  }

  console.log(`getSession: Session found for route protection? ${!!session}`);
  return session;
}



================================================
File: .history/src/auth_20250421135258.ts
================================================
// src/auth.ts
// Central module for Supabase client initialization and server-side session check.

// Import createServerClient and the base SupabaseClient type from the SSR library
// Using createServerClient with `browser: true` is recommended in SSR frameworks like Astro for cookie handling.
import { createClient } from "@supabase/supabase-js";
import type { SupabaseClient as SupabaseClientBase } from "@supabase/supabase-js";
import type { APIContext } from "astro"; // Import APIContext type for server-side context
import type { Session } from "@supabase/supabase-js";

// Import your local Database type
import type { Database } from "./db/database.types"; // Adjust path as needed

// Define the Supabase client type alias parameterized with your Database type
export type SupabaseClient = SupabaseClientBase<Database>;

// --- Supabase Browser Client Instance ---
// This client instance is used in React components that run in the browser.
// It handles client-side session persistence (cookies/localStorage).
// Use your actual Supabase URL and Anon Key from environment variables (PUBLIC prefixed for client access).
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY;

// Ensure env vars are checked in development, though Astro handles this somewhat via env.d.ts
if (typeof window !== "undefined" && import.meta.env.DEV && (!supabaseUrl || !supabaseAnonKey)) {
  console.warn(
    "PUBLIC_SUPABASE_URL or PUBLIC_SUPABASE_ANON_KEY are not set for the browser client. API calls may fail."
  );
}

// Initialize the browser client instance
export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey, {
  cookies: {
    get: (name: string) => {
      // Basic browser cookie parsing (needed by createServerClient in browser mode)
      if (typeof document === "undefined") return undefined;
      const match = document.cookie.split("; ").find((row) => row.trim().startsWith(name + "="));
      return match ? match.split("=")[1] : undefined;
    },
    // Supabase SDK manages set/remove in browser with createServerClient(..., { browser: true })
    // You typically don't need to provide custom set/remove for the browser client
    // unless you have very specific cookie requirements.
    // Let's remove them and let the SDK handle it.
    /*
      set: (name, value, options) => {
          if (typeof document !== 'undefined') {
             let cookieString = `${name}=${value}; path=${options.path || '/'}`;
             if (options.maxAge) cookieString += `; Max-Age=${options.maxAge}`;
             if (options.domain) cookieString += `; Domain=${options.domain}`;
             if (options.secure) cookieString += `; Secure`;
             if (options.httpOnly) cookieString += `; HttpOnly`; // Note: HttpOnly cookies are not readable by client JS
             if (options.sameSite) cookieString += `; SameSite=${options.sameSite}`;
             document.cookie = cookieString;
          }
      },
      remove: (name, options) => {
           if (typeof document !== 'undefined') {
             let cookieString = `${name}=; Max-Age=0; path=${options?.path || '/'}`;
             if (options?.domain) cookieString += `; Domain=${options.domain}`;
             if (options?.secure) cookieString += `; Secure`;
             if (options?.httpOnly) cookieString += `; HttpOnly`;
             if (options?.sameSite) cookieString += `; SameSite=${options.sameSite}`;
             document.cookie = cookieString;
           }
      },
      */
  },
  global: {
    fetch: fetch.bind(globalThis), // Ensure fetch is bound to globalThis in browser
  },
});

// --- Supabase Server Session Check Helper (Astro SSR) ---
// This function is used in Astro pages/layouts for server-side authentication checks for ROUTE ACCESS.
// It requires the APIContext to access the server-side Supabase client provided by the middleware.

export async function getSession(context: APIContext): Promise<Session | null> {
  // Get the server-side Supabase client instance from context.locals
  const supabaseServer: SupabaseClient = context.locals.supabase;

  if (!supabaseServer) {
    console.error(
      "getSession: Supabase client not found in context.locals. Ensure middleware is running and setting 'context.locals.supabase'."
    );
    // This indicates a critical setup error if middleware didn't run.
    return null;
  }

  // Use the server-side client to get the session from the request cookies
  // This checks if *any* user is authenticated for ROUTE protection.
  const {
    data: { session },
    error: authError,
  } = await supabaseServer.auth.getSession();

  if (authError) {
    console.error("getSession: Error fetching session on server:", authError);
    return null;
  }

  console.log(`getSession: Session found for route protection? ${!!session}`);
  return session;
}



================================================
File: .history/src/auth_20250421141317.ts
================================================
// src/auth.ts
// Central module for Supabase client initialization and server-side session check.

// Import createClient from the main supabase-js library for the BROWSER client instance
import { createClient } from "@supabase/supabase-js";
// Import APIContext type for server-side context
import type { APIContext } from "astro";
// Import Session type
import type { Session } from "@supabase/supabase-js";

// Import the shared SupabaseClient type alias from the server client file
// FIX: Import the SupabaseClient type from the designated file
import type { SupabaseClient } from "./db/supabase.client";

// Import your local Database type (needed if SupabaseClient alias wasn't used)
// import type { Database } from "./db/database.types"; // Adjust path as needed

// --- Supabase Browser Client Instance ---
// This client instance is used in React components that run in the browser.
// It handles client-side session persistence (cookies/localStorage).
// Use your actual Supabase URL and Anon Key from environment variables (PUBLIC prefixed for client access).
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY;

// Ensure env vars are checked in development, though Astro handles this somewhat via env.d.ts
if (typeof window !== "undefined" && import.meta.env.DEV && (!supabaseUrl || !supabaseAnonKey)) {
  console.warn(
    "PUBLIC_SUPABASE_URL or PUBLIC_SUPABASE_ANON_KEY are not set for the browser client. API calls may fail."
  );
}

// Initialize the browser client instance using createClient
// FIX: Use createClient for the browser instance as intended
export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  // No `browser: true` option in createClient, it's the default for browser environments
  // No custom cookie handling needed for createClient in the browser, SDK handles it.
  global: {
    fetch: fetch.bind(globalThis), // Ensure fetch is bound to globalThis in browser
  },
}) as SupabaseClient; // Assert to the shared type alias

// --- Supabase Server Session Check Helper (Astro SSR) ---
// This function is used in Astro pages/layouts for server-side authentication checks for ROUTE ACCESS.
// It requires the APIContext to access the server-side Supabase client provided by the middleware.

export async function getSession(context: APIContext): Promise<Session | null> {
  // Get the server-side Supabase client instance from context.locals
  // It is already typed as SupabaseClient from src/db/supabase.client in env.d.ts
  const supabaseServer: SupabaseClient = context.locals.supabase;

  if (!supabaseServer) {
    console.error(
      "getSession: Supabase client not found in context.locals. Ensure middleware is running and setting 'context.locals.supabase'."
    );
    // This indicates a critical setup error if middleware didn't run.
    return null;
  }

  // Use the server-side client to get the session from the request cookies
  // This checks if *any* user is authenticated for ROUTE protection.
  const {
    data: { session },
    error: authError,
  } = await supabaseServer.auth.getSession();

  if (authError) {
    console.error("getSession: Error fetching session on server:", authError);
    return null;
  }

  console.log(`getSession: Session found for route protection? ${!!session}`);
  return session;
}



================================================
File: .history/src/auth_20250421141426.ts
================================================
/* eslint-disable no-console */
// src/auth.ts
// Central module for Supabase client initialization and server-side session check.

// Import createClient from the main supabase-js library for the BROWSER client instance
import { createClient } from "@supabase/supabase-js";
// Import APIContext type for server-side context
import type { APIContext } from "astro";
// Import Session type
import type { Session } from "@supabase/supabase-js";

// Import the shared SupabaseClient type alias from the server client file
// FIX: Import the SupabaseClient type from the designated file
import type { SupabaseClient } from "./db/supabase.client";

// Import your local Database type (needed if SupabaseClient alias wasn't used)
// import type { Database } from "./db/database.types"; // Adjust path as needed

// --- Supabase Browser Client Instance ---
// This client instance is used in React components that run in the browser.
// It handles client-side session persistence (cookies/localStorage).
// Use your actual Supabase URL and Anon Key from environment variables (PUBLIC prefixed for client access).
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY;

// Ensure env vars are checked in development, though Astro handles this somewhat via env.d.ts
if (typeof window !== "undefined" && import.meta.env.DEV && (!supabaseUrl || !supabaseAnonKey)) {
  console.warn(
    "PUBLIC_SUPABASE_URL or PUBLIC_SUPABASE_ANON_KEY are not set for the browser client. API calls may fail."
  );
}

// Initialize the browser client instance using createClient
// FIX: Use createClient for the browser instance as intended
export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  // No `browser: true` option in createClient, it's the default for browser environments
  // No custom cookie handling needed for createClient in the browser, SDK handles it.
  global: {
    fetch: fetch.bind(globalThis), // Ensure fetch is bound to globalThis in browser
  },
}) as SupabaseClient; // Assert to the shared type alias

// --- Supabase Server Session Check Helper (Astro SSR) ---
// This function is used in Astro pages/layouts for server-side authentication checks for ROUTE ACCESS.
// It requires the APIContext to access the server-side Supabase client provided by the middleware.

export async function getSession(context: APIContext): Promise<Session | null> {
  // Get the server-side Supabase client instance from context.locals
  // It is already typed as SupabaseClient from src/db/supabase.client in env.d.ts
  const supabaseServer: SupabaseClient = context.locals.supabase;

  if (!supabaseServer) {
    console.error(
      "getSession: Supabase client not found in context.locals. Ensure middleware is running and setting 'context.locals.supabase'."
    );
    // This indicates a critical setup error if middleware didn't run.
    return null;
  }

  // Use the server-side client to get the session from the request cookies
  // This checks if *any* user is authenticated for ROUTE protection.
  const {
    data: { session },
    error: authError,
  } = await supabaseServer.auth.getSession();

  if (authError) {
    console.error("getSession: Error fetching session on server:", authError);
    return null;
  }

  console.log(`getSession: Session found for route protection? ${!!session}`);
  return session;
}



================================================
File: .history/src/auth_20250421141430.ts
================================================
/* eslint-disable no-console */
// src/auth.ts
// Central module for Supabase client initialization and server-side session check.

// Import createClient from the main supabase-js library for the BROWSER client instance
import { createClient } from "@supabase/supabase-js";
// Import APIContext type for server-side context
import type { APIContext } from "astro";
// Import Session type
import type { Session } from "@supabase/supabase-js";

// Import the shared SupabaseClient type alias from the server client file
// FIX: Import the SupabaseClient type from the designated file
import type { SupabaseClient } from "./db/supabase.client";

// Import your local Database type (needed if SupabaseClient alias wasn't used)
// import type { Database } from "./db/database.types"; // Adjust path as needed

// --- Supabase Browser Client Instance ---
// This client instance is used in React components that run in the browser.
// It handles client-side session persistence (cookies/localStorage).
// Use your actual Supabase URL and Anon Key from environment variables (PUBLIC prefixed for client access).
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY;

// Ensure env vars are checked in development, though Astro handles this somewhat via env.d.ts
if (typeof window !== "undefined" && import.meta.env.DEV && (!supabaseUrl || !supabaseAnonKey)) {
  console.warn(
    "PUBLIC_SUPABASE_URL or PUBLIC_SUPABASE_ANON_KEY are not set for the browser client. API calls may fail."
  );
}

// Initialize the browser client instance using createClient
// FIX: Use createClient for the browser instance as intended
export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  // No `browser: true` option in createClient, it's the default for browser environments
  // No custom cookie handling needed for createClient in the browser, SDK handles it.
  global: {
    fetch: fetch.bind(globalThis), // Ensure fetch is bound to globalThis in browser
  },
}) as SupabaseClient; // Assert to the shared type alias

// --- Supabase Server Session Check Helper (Astro SSR) ---
// This function is used in Astro pages/layouts for server-side authentication checks for ROUTE ACCESS.
// It requires the APIContext to access the server-side Supabase client provided by the middleware.

export async function getSession(context: APIContext): Promise<Session | null> {
  // Get the server-side Supabase client instance from context.locals
  // It is already typed as SupabaseClient from src/db/supabase.client in env.d.ts
  const supabaseServer: SupabaseClient = context.locals.supabase;

  if (!supabaseServer) {
    console.error(
      "getSession: Supabase client not found in context.locals. Ensure middleware is running and setting 'context.locals.supabase'."
    );
    // This indicates a critical setup error if middleware didn't run.
    return null;
  }

  // Use the server-side client to get the session from the request cookies
  // This checks if *any* user is authenticated for ROUTE protection.
  const {
    data: { session },
    error: authError,
  } = await supabaseServer.auth.getSession();

  if (authError) {
    console.error("getSession: Error fetching session on server:", authError);
    return null;
  }

  console.log(`getSession: Session found for route protection? ${!!session}`);
  return session;
}



================================================
File: .history/src/auth_20250421141432.ts
================================================
/* eslint-disable no-console */
// src/auth.ts
// Central module for Supabase client initialization and server-side session check.

// Import createClient from the main supabase-js library for the BROWSER client instance
import { createClient } from "@supabase/supabase-js";
// Import APIContext type for server-side context
import type { APIContext } from "astro";
// Import Session type
import type { Session } from "@supabase/supabase-js";

// Import the shared SupabaseClient type alias from the server client file
// FIX: Import the SupabaseClient type from the designated file
import type { SupabaseClient } from "./db/supabase.client";

// Import your local Database type (needed if SupabaseClient alias wasn't used)
// import type { Database } from "./db/database.types"; // Adjust path as needed

// --- Supabase Browser Client Instance ---
// This client instance is used in React components that run in the browser.
// It handles client-side session persistence (cookies/localStorage).
// Use your actual Supabase URL and Anon Key from environment variables (PUBLIC prefixed for client access).
const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY;

// Ensure env vars are checked in development, though Astro handles this somewhat via env.d.ts
if (typeof window !== "undefined" && import.meta.env.DEV && (!supabaseUrl || !supabaseAnonKey)) {
  console.warn(
    "PUBLIC_SUPABASE_URL or PUBLIC_SUPABASE_ANON_KEY are not set for the browser client. API calls may fail."
  );
}

// Initialize the browser client instance using createClient
// FIX: Use createClient for the browser instance as intended
export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  // No `browser: true` option in createClient, it's the default for browser environments
  // No custom cookie handling needed for createClient in the browser, SDK handles it.
  global: {
    fetch: fetch.bind(globalThis), // Ensure fetch is bound to globalThis in browser
  },
}) as SupabaseClient; // Assert to the shared type alias

// --- Supabase Server Session Check Helper (Astro SSR) ---
// This function is used in Astro pages/layouts for server-side authentication checks for ROUTE ACCESS.
// It requires the APIContext to access the server-side Supabase client provided by the middleware.

export async function getSession(context: APIContext): Promise<Session | null> {
  // Get the server-side Supabase client instance from context.locals
  // It is already typed as SupabaseClient from src/db/supabase.client in env.d.ts
  const supabaseServer: SupabaseClient = context.locals.supabase;

  if (!supabaseServer) {
    console.error(
      "getSession: Supabase client not found in context.locals. Ensure middleware is running and setting 'context.locals.supabase'."
    );
    // This indicates a critical setup error if middleware didn't run.
    return null;
  }

  // Use the server-side client to get the session from the request cookies
  // This checks if *any* user is authenticated for ROUTE protection.
  const {
    data: { session },
    error: authError,
  } = await supabaseServer.auth.getSession();

  if (authError) {
    console.error("getSession: Error fetching session on server:", authError);
    return null;
  }

  console.log(`getSession: Session found for route protection? ${!!session}`);
  return session;
}



================================================
File: .history/src/env.d_20250419200309.ts
================================================
/// <reference types="astro/client" />

// Import the SupabaseClient type alias from your local client file
import { type SupabaseClient } from "../../db/supabase.client";

declare global {
  namespace App {
    interface Locals {
      // Use the imported SupabaseClient type alias, which is SupabaseClientBase<Database>
      // The Database type is brought in by the alias itself, no need to parameterize here
      supabase: SupabaseClient; // <--- Use the alias type directly
    }
  }
}

interface ImportMetaEnv {
  readonly SUPABASE_URL: string;
  readonly SUPABASE_KEY: string;
  readonly OPENROUTER_API_KEY: string; // Ensure this matches your .env file
  // more env variables...
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}



================================================
File: .history/src/env.d_20250421133747.ts
================================================
/// <reference types="astro/client" />

// Import the SupabaseClient type alias from your local client file
import { type SupabaseClient } from "./db/supabase.client";

declare global {
  namespace App {
    interface Locals {
      // Use the imported SupabaseClient type alias, which is SupabaseClientBase<Database>
      // The Database type is brought in by the alias itself, no need to parameterize here
      supabase: SupabaseClient; // <--- Use the alias type directly for the server client instance
      // Add other server-side locals here if needed
      runtime: {
        env: ImportMetaEnv; // Make server-side env vars available in locals.runtime.env
      };
    }
  }
}

interface ImportMetaEnv {
  // Public variables (available client-side via import.meta.env.PUBLIC_...)
  readonly PUBLIC_SUPABASE_URL: string;
  readonly PUBLIC_SUPABASE_ANON_KEY: string;

  // Server-side variables (available only on the server via import.meta.env or locals.runtime.env)
  readonly SUPABASE_URL: string;
  readonly SUPABASE_KEY: string;
  readonly OPENROUTER_API_KEY: string; // Ensure this matches your .env file

  // Add any other server-side environment variables here
  // readonly SUPABASE_SERVICE_ROLE_KEY: string; // Example server-side key
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}



================================================
File: .history/src/env.d_20250421133750.ts
================================================
/// <reference types="astro/client" />

// Import the SupabaseClient type alias from your local client file
import { type SupabaseClient } from "./db/supabase.client";

declare global {
  namespace App {
    interface Locals {
      // Use the imported SupabaseClient type alias, which is SupabaseClientBase<Database>
      // The Database type is brought in by the alias itself, no need to parameterize here
      supabase: SupabaseClient; // <--- Use the alias type directly for the server client instance
      // Add other server-side locals here if needed
      runtime: {
        env: ImportMetaEnv; // Make server-side env vars available in locals.runtime.env
      };
    }
  }
}

interface ImportMetaEnv {
  // Public variables (available client-side via import.meta.env.PUBLIC_...)
  readonly PUBLIC_SUPABASE_URL: string;
  readonly PUBLIC_SUPABASE_ANON_KEY: string;

  // Server-side variables (available only on the server via import.meta.env or locals.runtime.env)
  readonly SUPABASE_URL: string;
  readonly SUPABASE_KEY: string;
  readonly OPENROUTER_API_KEY: string; // Ensure this matches your .env file

  // Add any other server-side environment variables here
  // readonly SUPABASE_SERVICE_ROLE_KEY: string; // Example server-side key
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}



================================================
File: .history/src/env.d_20250421133803.ts
================================================
/// <reference types="astro/client" />

// Import the SupabaseClient type alias from your local client file
import { type SupabaseClient } from "./db/supabase.client";

declare global {
  namespace App {
    interface Locals {
      // Use the imported SupabaseClient type alias, which is SupabaseClientBase<Database>
      // The Database type is brought in by the alias itself, no need to parameterize here
      supabase: SupabaseClient; // <--- Use the alias type directly for the server client instance
      // Add other server-side locals here if needed
      runtime: {
        env: ImportMetaEnv; // Make server-side env vars available in locals.runtime.env
      };
    }
  }
}

interface ImportMetaEnv {
  // Public variables (available client-side via import.meta.env.PUBLIC_...)
  readonly PUBLIC_SUPABASE_URL: string;
  readonly PUBLIC_SUPABASE_ANON_KEY: string;

  // Server-side variables (available only on the server via import.meta.env or locals.runtime.env)
  readonly SUPABASE_URL: string;
  readonly SUPABASE_KEY: string;
  readonly OPENROUTER_API_KEY: string; // Ensure this matches your .env file

  // Add any other server-side environment variables here
  // readonly SUPABASE_SERVICE_ROLE_KEY: string; // Example server-side key
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}



================================================
File: .history/src/components/views/SummaryForm_20250421130012.tsx
================================================
// src/components/views/SummaryForm.tsx
import * as React from "react";
import { useState, useRef, useEffect } from "react";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea"; // Assuming Textarea component is installed
import { toast } from "sonner";
import { Loader2 } from "lucide-react";
import type {
  GenerateSummaryCommand,
  GenerateSummaryResponseDto,
  CreateSummaryRequestDTO,
  MeetingSummaryDetailsDto,
  UpdateSummaryRequestDTO,
} from "@/types"; // Import relevant types
import { supabase } from "@/auth"; // Import supabase client

// Placeholder API Client (replace with actual fetch/axios using JWT)
const apiClient = {
  generateSummary: async (data: GenerateSummaryCommand, accessToken?: string): Promise<GenerateSummaryResponseDto> => {
    console.log("Generating summary for transcription:", data.transcription.substring(0, 100) + "...");
    // Simulate API call
    await new Promise((resolve) => setTimeout(resolve, 1500));
    if (Math.random() < 0.15) {
      // Simulate occasional error (15% chance)
      console.error("Simulating LLM error");
      throw new Error("LLM failed to generate summary. Try again or edit manually.");
    }
    return {
      summary:
        "To jest symulowane podsumowanie tekstu wejściowego. " +
        data.transcription.split(" ").slice(0, 30).join(" ") +
        "... [LLM Generated]",
    };
  },

  createSummary: async (data: CreateSummaryRequestDTO, accessToken?: string): Promise<MeetingSummaryDetailsDto> => {
    console.log("Creating summary:", data);
    // Simulate API call: POST /api/summaries
    // In a real app:
    /*
     const response = await fetch('/api/summaries', {
          method: 'POST',
          headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${accessToken}`,
          },
          body: JSON.stringify(data),
     });

     if (!response.ok) {
          const errorBody = await response.json();
          throw new Error(errorBody.message || `API Error: ${response.status}`);
     }

     const createdSummary: MeetingSummaryDetailsDto = await response.json();
     return createdSummary;
     */

    // Mock implementation
    const mockResponse: MeetingSummaryDetailsDto = {
      id: `mock-${Date.now()}`,
      title: data.file_name || data.transcription.substring(0, 30) + "...", // Simulate backend generating title
      file_name: data.file_name || null,
      transcription: data.transcription,
      summary: data.summary,
      llm_generated: data.llm_generated,
      notes: data.notes || null,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(), // Same as created_at initially
    };
    await new Promise((resolve) => setTimeout(resolve, 1000));
    if (Math.random() < 0.15) {
      // Simulate occasional error (15% chance)
      console.error("Simulating Save Error (Create)");
      throw new Error("Failed to save new summary. Check your data.");
    }
    return mockResponse;
  },

  updateSummary: async (
    id: string,
    data: UpdateSummaryRequestDTO,
    accessToken?: string
  ): Promise<MeetingSummaryDetailsDto> => {
    console.log(`Updating summary ${id}:`, data);
    // Simulate API call: PUT /api/summaries/{id}
    // In a real app:
    /*
       const response = await fetch(`/api/summaries/${id}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${accessToken}`,
            },
            body: JSON.stringify(data),
       });

       if (!response.ok) {
            const errorBody = await response.json();
            throw new Error(errorBody.message || `API Error: ${response.status}`);
       }
        // Assuming successful PUT returns the updated object or just status 200/204
        // If it returns the object:
       const updatedSummary: MeetingSummaryDetailsDto = await response.json();
       return updatedSummary;
       // If 204 No Content, just return a success indicator or void.
       // For mocking, let's return a simulated updated object.
       */

    // Mock implementation
    const mockExisting = await apiClient.getSummaryDetails(id, accessToken).catch(() => ({})); // Try fetching existing or return empty
    const mockResponse: MeetingSummaryDetailsDto = {
      ...(mockExisting as MeetingSummaryDetailsDto), // Spread existing data
      id: id, // Ensure correct ID
      ...data, // Apply updates from payload
      // Handle optional updates and fallback to existing data if not provided in payload
      file_name: data.file_name === undefined ? mockExisting.file_name : data.file_name,
      transcription: data.transcription === undefined ? mockExisting.transcription : data.transcription,
      summary: data.summary === undefined ? mockExisting.summary : data.summary,
      llm_generated: data.llm_generated === undefined ? mockExisting.llm_generated : data.llm_generated,
      notes: data.notes === undefined ? mockExisting.notes : data.notes, // Notes can be null
      // title, created_at, user_id are typically not updated via this endpoint DTO
      updated_at: new Date().toISOString(), // Simulate update timestamp
    };

    await new Promise((resolve) => setTimeout(resolve, 1000));
    if (Math.random() < 0.15) {
      // Simulate occasional error (15% chance)
      console.error("Simulating Save Error (Update)");
      throw new Error(`Failed to update summary ${id}.`);
    }
    return mockResponse;
  },

  getSummaryDetails: async (id: string, accessToken?: string): Promise<MeetingSummaryDetailsDto> => {
    console.log("Fetching summary details for ID:", id);
    // Simulate API call
    // In a real app:
    /*
       const response = await fetch(`/api/summaries/${id}`, {
            headers: {
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json',
            },
       });

       if (!response.ok) {
            const errorBody = await response.json();
            throw new Error(errorBody.message || `API Error: ${response.status}`);
       }

       const summaryDetails: MeetingSummaryDetailsDto = await response.json();
       return summaryDetails;
      */

    // Mock implementation
    await new Promise((resolve) => setTimeout(resolve, 1000));
    if (Math.random() < 0.15) {
      // Simulate occasional error (15% chance)
      console.error("Simulating Load Error (Edit)");
      throw new Error(`Symulowany błąd ładowania podsumowania ${id}`);
    }
    // Simulate data based on the ID
    return {
      id,
      title: `Podsumowanie ID ${id}`, // Simulate title
      file_name: `file_${id}.txt`,
      created_at: "2023-11-01T10:00:00Z",
      updated_at: "2023-11-01T10:30:00Z",
      transcription: `To jest przykładowa transkrypcja dla podsumowania o ID ${id}. \n\nDłuższy tekst do edycji...`,
      summary: `To jest przykładowe podsumowanie dla podsumowania o ID ${id}. Krótszy tekst wygenerowany LLM. [LLM Generated]`,
      llm_generated: true, // Example value
      notes: `Przykładowe notatki dla ${id}.`, // Example notes
      user_id: "mock-user-id", // User ID would be included in DB row
    };
  },
};

interface SummaryFormProps {
  mode: "create" | "edit";
  summaryId?: string; // Required in 'edit' mode
}

const SummaryForm: React.FC<SummaryFormProps> = ({ mode, summaryId }) => {
  const [transcription, setTranscription] = useState("");
  const [summary, setSummary] = useState("");
  const [fileName, setFileName] = useState<string | null>(null);
  const [isSummarizing, setIsSummarizing] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [loadError, setLoadError] = useState<string | null>(null); // For edit mode initial load error
  const [actionError, setActionError] = useState<string | null>(null); // For summarize/save errors
  const [isLLMGenerated, setIsLLMGenerated] = useState(false); // Track if current summary was LLM generated
  const [isInitialLoading, setIsInitialLoading] = useState(mode === "edit"); // Loading state for initial fetch in edit mode

  const fileInputRef = useRef<HTMLInputElement>(null);

  // Effect to load data in edit mode
  useEffect(() => {
    if (mode === "edit" && summaryId) {
      const fetchSummary = async () => {
        setIsInitialLoading(true);
        setLoadError(null); // Clear previous load errors
        try {
          const {
            data: { session },
          } = await supabase.auth.getSession();
          const accessToken = session?.access_token;

          if (!accessToken) {
            setLoadError("Brak autoryzacji. Zaloguj się ponownie.");
            setIsInitialLoading(false);
            return;
          }

          const data = await apiClient.getSummaryDetails(summaryId, accessToken);
          setTranscription(data.transcription || ""); // Ensure not undefined
          setSummary(data.summary || ""); // Ensure not undefined
          setFileName(data.file_name || data.title || `Podsumowanie ${summaryId}`); // Display file name or title
          setIsLLMGenerated(data.llm_generated);
          setIsInitialLoading(false);
        } catch (err: any) {
          console.error("Failed to fetch summary details:", err);
          setLoadError(
            "Nie udało się załadować podsumowania do edycji. Spróbuj ponownie. Szczegóły: " + (err.message || "")
          );
          setIsInitialLoading(false);
        }
      };
      fetchSummary();
    } else if (mode === "create") {
      // Clear states for create mode
      setTranscription("");
      setSummary("");
      setFileName(null);
      setIsLLMGenerated(false);
      setIsInitialLoading(false); // No initial loading in create mode
      setLoadError(null);
      setActionError(null);
      // Clear file input value as well
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    }
  }, [mode, summaryId]); // Depend on mode and summaryId

  // Clear action error when user starts typing in transcription or summary
  const handleTranscriptionChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setTranscription(e.target.value);
    setActionError(null); // Clear error when transcription changes
    // Decide if manual edit means it's no longer LLM generated?
    // Let's keep isLLMGenerated based on whether 'Podsumuj' was the *last* action populating summary.
  };

  const handleSummaryChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setSummary(e.target.value);
    setActionError(null); // Clear error when summary changes
    setIsLLMGenerated(false); // If user manually edits summary, it's not purely LLM generated anymore
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    setActionError(null); // Clear action errors on new file upload

    if (file) {
      if (file.size > 1024 * 1024) {
        // 1MB limit
        toast({
          description: "Plik jest za duży (max 1 MB).",
          variant: "destructive",
        });
        // Reset file input value to allow selecting the same file again after error
        if (fileInputRef.current) {
          fileInputRef.current.value = "";
        }
        setFileName(null);
        setTranscription(""); // Clear transcription as file is invalid
        setSummary(""); // Clear summary as transcription changed/failed
        setIsLLMGenerated(false);
        return;
      }

      setFileName(file.name);
      setSummary(""); // Clear summary when a new transcription is loaded
      setIsLLMGenerated(false); // Clear LLM status

      const reader = new FileReader();
      reader.onload = (e) => {
        const text = e.target?.result as string;
        setTranscription(text);
        toast({
          description: `Plik "${file.name}" wczytany.`,
          // variant: "success" // Add success variant if available/needed
        });
      };
      reader.onerror = () => {
        setActionError("Nie udało się odczytać pliku.");
        setFileName(null);
        setTranscription("");
        setSummary("");
        setIsLLMGenerated(false);
        toast({
          description: `Błąd odczytu pliku "${file?.name}".`,
          variant: "destructive",
        });
      };
      reader.readAsText(file);
    } else {
      // File input was cancelled or cleared
      setFileName(null);
      setTranscription("");
      setSummary("");
      setIsLLMGenerated(false);
      setActionError(null); // Clear error if file input is cancelled/cleared
    }
    // Reset file input value when done processing (success or error)
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  const handleSummarize = async () => {
    // Basic validation before calling API
    if (!transcription || isSummarizing || isSaving || isInitialLoading) return;

    setIsSummarizing(true);
    setActionError(null); // Clear previous action errors

    try {
      const {
        data: { session },
      } = await supabase.auth.getSession();
      const accessToken = session?.access_token;

      if (!accessToken) {
        setActionError("Brak autoryzacji. Zaloguj się ponownie.");
        setIsSummarizing(false);
        return;
      }

      const result = await apiClient.generateSummary({ transcription }, accessToken);
      setSummary(result.summary);
      setIsLLMGenerated(true); // Mark as LLM generated
      toast({
        description: "Podsumowanie wygenerowane pomyślnie.",
        // variant: "success"
      });
    } catch (err: any) {
      console.error("Summarize error:", err);
      setActionError(`Błąd generowania podsumowania: ${err.message || "Nieznany błąd"}`);
      setSummary(""); // Clear summary on error
      setIsLLMGenerated(false); // Ensure flag is false on error
    } finally {
      setIsSummarizing(false);
    }
  };

  const handleSave = async () => {
    // Basic validation before calling API
    if (!summary || isSaving || isSummarizing || isInitialLoading) return;

    setIsSaving(true);
    setActionError(null); // Clear previous action errors

    try {
      const {
        data: { session },
      } = await supabase.auth.getSession();
      const accessToken = session?.access_token;

      if (!accessToken) {
        setActionError("Brak autoryzacji. Zaloguj się ponownie.");
        setIsSaving(false);
        return;
      }

      if (mode === "create") {
        const payload: CreateSummaryRequestDTO = {
          // title is NOT in CreateSummaryRequestDTO based on types.ts
          file_name: fileName, // Include file name from state
          transcription: transcription, // Required
          summary: summary, // Required
          llm_generated: isLLMGenerated, // Use tracked status
          notes: "", // Assuming no notes field for now, send empty string or null
        };
        await apiClient.createSummary(payload, accessToken); // POST /api/summaries
        toast({
          description: "Podsumowanie zapisane.",
        });
        window.location.href = "/summaries"; // Redirect after save
      } else if (mode === "edit" && summaryId) {
        const payload: UpdateSummaryRequestDTO = {
          // title is NOT directly updatable via this payload DTO structure
          file_name: fileName, // Include file name - if editable via PUT
          transcription: transcription, // Include transcription for update
          summary: summary, // Include summary for update
          llm_generated: isLLMGenerated, // Include status in update
          notes: "", // Assuming no notes field for now, send empty string or null
        };
        await apiClient.updateSummary(summaryId, payload, accessToken); // PUT /api/summaries/{id}

        toast({
          description: "Zmiany zapisane.",
        });
        window.location.href = "/summaries"; // Redirect after save
      }
    } catch (err: any) {
      console.error("Save error:", err);
      setActionError(`Błąd zapisu: ${err.message || "Nieznany błąd"}`);
    } finally {
      setIsSaving(false);
    }
  };

  const handleCancel = () => {
    window.location.href = "/summaries"; // Navigate back
  };

  // Determine if any major operation is in progress to disable controls
  const isBusy = isInitialLoading || isSummarizing || isSaving;

  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold">{mode === "create" ? "Nowe podsumowanie" : `Edytuj podsumowanie`}</h1>
      {/* Display title/file name in edit mode if available */}
      {mode === "edit" &&
        !isInitialLoading &&
        (fileName || summaryId) && ( // Only show if not initially loading
          <div className="text-lg font-semibold text-muted-foreground -mt-4 mb-4">
            {" "}
            {/* Adjust spacing */}
            {fileName || `ID: ${summaryId}`} {/* Display file name or ID if name is null */}
          </div>
        )}

      {/* Display initial load error in edit mode */}
      {loadError && mode === "edit" && <p className="text-sm font-medium text-red-500">{loadError}</p>}

      {/* Display spinner for initial load in edit mode */}
      {isInitialLoading ? (
        <div className="flex flex-col justify-center items-center h-64">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
          <span className="mt-2 text-muted-foreground">Ładowanie podsumowania...</span>
        </div>
      ) : (
        <>
          {" "}
          {/* Wrap content in fragment if not loading initially */}
          {/* File Upload Section (only in create mode) */}
          {mode === "create" && (
            <div className="flex flex-col sm:flex-row items-start sm:items-center space-y-2 sm:space-y-0 sm:space-x-4">
              <input
                id="file-upload"
                type="file"
                accept=".txt"
                ref={fileInputRef}
                onChange={handleFileChange}
                className="hidden" // Hide the default input
                disabled={isBusy} // Disable file input while busy
              />
              <Label
                htmlFor="file-upload"
                className="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 h-10 px-4 py-2 bg-primary text-primary-foreground hover:bg-primary/90 cursor-pointer"
                data-disabled={isBusy}
              >
                {" "}
                {/* Use data-disabled for styling */}
                Wczytaj plik TXT (max 1 MB)
              </Label>
              {fileName && <span className="text-sm text-muted-foreground">{fileName}</span>}
            </div>
          )}
          <div>
            <Label htmlFor="transcription">Transkrypcja</Label>
            <Textarea
              id="transcription"
              value={transcription}
              onChange={handleTranscriptionChange} // Use refined handler
              placeholder="Wklej lub wczytaj tekst transkrypcji tutaj..."
              rows={10} // Adjust rows as needed
              className="mt-1"
              disabled={isBusy} // Disable while any operation is busy
            />
          </div>
          <div>
            <Label htmlFor="summary">Podsumowanie</Label>
            <Textarea
              id="summary"
              value={summary}
              onChange={handleSummaryChange} // Use refined handler
              placeholder="Wygeneruj lub wpisz podsumowanie tutaj..."
              rows={6} // Adjust rows as needed
              className="mt-1"
              disabled={isBusy} // Disable while any operation is busy
            />
          </div>
          {/* Display action-specific errors */}
          {actionError && <p className="text-sm font-medium text-red-500">{actionError}</p>}
          <div className="flex flex-col sm:flex-row justify-end gap-2 pt-4">
            <Button variant="outline" onClick={handleCancel} disabled={isBusy}>
              Anuluj
            </Button>
            <Button onClick={handleSummarize} disabled={!transcription || isBusy}>
              {isSummarizing && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Podsumuj
            </Button>
            <Button onClick={handleSave} disabled={!summary || isBusy}>
              {isSaving && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Zapisz
            </Button>
          </div>
          {mode === "edit" &&
            summaryId &&
            !isInitialLoading && ( // Only show if in edit mode and not initially loading
              <div className="text-sm text-muted-foreground mt-4 border-t pt-4">
                ID Podsumowania: {summaryId}
                {/* fileName is displayed at the top in edit mode */}
              </div>
            )}
        </>
      )}
    </div>
  );
};

export default SummaryForm;



================================================
File: .history/src/components/views/SummaryForm_20250421134808.tsx
================================================
// src/components/views/SummaryForm.tsx
import * as React from "react";
import { useState, useRef, useEffect, useCallback } from "react";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { toast } from "sonner";
import { Loader2 } from "lucide-react";
import type {
  GenerateSummaryCommand,
  GenerateSummaryResponseDto,
  CreateSummaryRequestDTO,
  MeetingSummaryDetailsDto,
  UpdateSummaryRequestDTO,
} from "@/types";
// import { supabase } from "@/auth"; // No longer needed directly for API calls needing auth token
import { apiService } from "@/lib/apiService"; // Import the apiService

interface SummaryFormProps {
  mode: "create" | "edit";
  summaryId?: string; // Required in 'edit' mode
}

const SummaryForm: React.FC<SummaryFormProps> = ({ mode, summaryId }) => {
  const [transcription, setTranscription] = useState("");
  const [summary, setSummary] = useState("");
  const [notes, setNotes] = useState<string | null>(""); // Initialize as empty string or null
  const [fileName, setFileName] = useState<string | null>(null); // For display in edit mode / payload in create
  const [isSummarizing, setIsSummarizing] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [loadError, setLoadError] = useState<string | null>(null); // For edit mode initial load error
  const [actionError, setActionError] = useState<string | null>(null); // For summarize/save errors
  const [isLLMGenerated, setIsLLMGenerated] = useState(false); // Track if current summary was LLM generated
  const [isInitialLoading, setIsInitialLoading] = useState(mode === "edit"); // Loading state for initial fetch in edit mode

  const fileInputRef = useRef<HTMLInputElement>(null);

  // Fetch summary details in edit mode
  const fetchSummary = useCallback(async (id: string) => {
    setIsInitialLoading(true);
    setLoadError(null); // Clear previous load errors
    try {
      // Use the apiService to fetch data
      const data = await apiService.getSummaryDetails(id);
      setTranscription(data.transcription || "");
      setSummary(data.summary || "");
      setNotes(data.notes || ""); // Initialize with empty string if notes is null
      setFileName(data.file_name || data.title || `Podsumowanie ${id}`); // Display file name or title
      setIsLLMGenerated(data.llm_generated);
      setIsInitialLoading(false);
    } catch (err: any) {
      console.error("Failed to fetch summary details:", err);
      // Display inline load error for edit mode
      setLoadError(
        "Nie udało się załadować podsumowania do edycji. Spróbuj ponownie. Szczegóły: " + (err.message || "")
      );
      setIsInitialLoading(false);
    }
  }, []);

  // Effect to load data in edit mode
  useEffect(() => {
    if (mode === "edit" && summaryId) {
      fetchSummary(summaryId);
    } else if (mode === "create") {
      // Clear states for create mode
      setTranscription("");
      setSummary("");
      setNotes(""); // Clear notes to empty string for new entry
      setFileName(null);
      setIsLLMGenerated(false);
      setIsInitialLoading(false); // No initial loading in create mode
      setLoadError(null);
      setActionError(null);
      // Clear file input value as well
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    }
  }, [mode, summaryId, fetchSummary]); // Depend on mode, summaryId, and memoized fetchSummary

  // Clear action error when user starts typing in transcription or summary or notes
  const handleTranscriptionChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setTranscription(e.target.value);
    setActionError(null); // Clear error when transcription changes
    // Decide if manual edit means it's no longer LLM generated?
    // Let's keep isLLMGenerated based on whether 'Podsumuj' was the *last* action populating summary.
  };

  const handleSummaryChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setSummary(e.target.value);
    setActionError(null); // Clear error when summary changes
    setIsLLMGenerated(false); // If user manually edits summary, it's not purely LLM generated anymore
  };

  const handleNotesChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setNotes(e.target.value);
    setActionError(null); // Clear error when notes change
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    setActionError(null); // Clear action errors on new file upload

    if (file) {
      if (file.size > 1024 * 1024) {
        // 1MB limit
        toast({
          description: "Plik jest za duży (max 1 MB).",
          variant: "destructive",
        });
        // Reset file input value to allow selecting the same file again after error
        if (fileInputRef.current) {
          fileInputRef.current.value = "";
        }
        setFileName(null);
        setTranscription(""); // Clear transcription as file is invalid
        setSummary(""); // Clear summary as transcription changed/failed
        setNotes(""); // Clear notes
        setIsLLMGenerated(false);
        return;
      }

      setFileName(file.name);
      setTranscription(""); // Clear old transcription
      setSummary(""); // Clear summary when a new transcription is loaded
      setNotes(""); // Clear notes
      setIsLLMGenerated(false); // Clear LLM status

      const reader = new FileReader();
      reader.onload = (e) => {
        const text = e.target?.result as string;
        setTranscription(text);
        toast({
          description: `Plik "${file.name}" wczytany.`,
          // variant: "success" // Add success variant styling
        });
      };
      reader.onerror = () => {
        setActionError("Nie udało się odczytać pliku.");
        setFileName(null);
        setTranscription("");
        setSummary("");
        setNotes("");
        setIsLLMGenerated(false);
        toast({
          description: `Błąd odczytu pliku "${file?.name}".`,
          variant: "destructive",
        });
      };
      reader.readAsText(file);
    } else {
      // File input was cancelled or cleared
      setFileName(null);
      setTranscription("");
      setSummary("");
      setNotes("");
      setIsLLMGenerated(false);
      setActionError(null); // Clear error if file input is cancelled/cleared
    }
    // Reset file input value when done processing (success or error)
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  const handleSummarize = async () => {
    // Basic validation before calling API
    if (!transcription.trim() || isBusy) return; // Check if transcription is empty or only whitespace

    setIsSummarizing(true);
    setActionError(null); // Clear previous action errors

    try {
      // apiService is updated to handle/skip auth based on MVP rules
      const result = await apiService.generateSummary({ transcription });
      setSummary(result.summary);
      setIsLLMGenerated(true); // Mark as LLM generated
      toast({
        description: "Podsumowanie wygenerowane pomyślnie.",
        // variant: "success" // Requires success variant styling
      });
    } catch (err: any) {
      // Explicitly type as any if error object structure is unknown
      console.error("Summarize error:", err);
      setActionError(`Błąd generowania podsumowania: ${err.message || "Nieznany błąd"}`);
      setSummary(""); // Clear summary on error
      setIsLLMGenerated(false); // Ensure flag is false on error
    } finally {
      setIsSummarizing(false);
    }
  };

  const handleSave = async () => {
    // Basic validation before calling API
    if (!summary.trim() || isBusy) return; // Check if summary is empty or only whitespace

    setIsSaving(true);
    setActionError(null); // Clear previous action errors

    try {
      if (mode === "create") {
        const payload: CreateSummaryRequestDTO = {
          file_name: fileName, // Include file name from state
          transcription: transcription, // Required
          summary: summary, // Required
          llm_generated: isLLMGenerated, // Use tracked status
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to create summary
        await apiService.createSummary(payload); // POST /api/summaries
        toast({
          description: "Podsumowanie zapisane.",
          // variant: "success" // Requires success variant styling
        });
        window.location.href = "/summaries"; // Redirect after create save
      } else if (mode === "edit" && summaryId) {
        const payload: UpdateSummaryRequestDTO = {
          // file_name is not typically updated in edit mode based on plan display
          // If file_name should be updatable, add: file_name: fileName,
          transcription: transcription, // Include transcription for update
          summary: summary, // Include summary for update
          llm_generated: isLLMGenerated, // Include status in update
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to update summary
        await apiService.updateSummary(summaryId, payload); // PUT /api/summaries/{id}

        toast({
          description: "Zmiany zapisane.",
          // variant: "success" // Requires success variant styling
        });
        // No redirect after edit save as per plan (user can click cancel/nav)
        setIsSaving(false); // Reset saving state on success if not redirecting
      }
    } catch (err: any) {
      // Explicitly type as any if error object structure is unknown
      console.error("Save error:", err);
      // Display inline save error
      setActionError(`Błąd zapisu: ${err.message || "Nieznany błąd"}`);
      setIsSaving(false); // Reset saving state on error
    }
  };

  const handleCancel = () => {
    // Simple redirect, no confirmation needed as per plan
    window.location.href = "/summaries"; // Navigate back
  };

  // Determine if any major operation is in progress to disable controls
  const isBusy = isInitialLoading || isSummarizing || isSaving;
  // Determine if save button should be disabled (requires non-empty summary AND not busy)
  const isSaveDisabled = !summary.trim() || isBusy;
  // Determine if summarize button should be disabled (requires non-empty transcription AND not busy)
  const isSummarizeDisabled = !transcription.trim() || isBusy;

  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold">{mode === "create" ? "Nowe podsumowanie" : `Edytuj podsumowanie`}</h1>
      {/* Display title/file name in edit mode if available */}
      {mode === "edit" &&
        !isInitialLoading &&
        (fileName || summaryId) && ( // Only show if not initially loading
          // Added margin-bottom to separate from fields below
          <div className="text-lg font-semibold text-muted-foreground -mt-4 mb-4">{fileName || `ID: ${summaryId}`}</div>
        )}

      {/* Display initial load error in edit mode */}
      {loadError && mode === "edit" && <p className="text-sm font-medium text-red-500">{loadError}</p>}

      {/* Display spinner for initial load in edit mode */}
      {isInitialLoading ? (
        <div className="flex flex-col justify-center items-center h-64">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
          <span className="mt-2 text-muted-foreground">Ładowanie podsumowania...</span>
        </div>
      ) : (
        <>
          {/* File Upload Section (only in create mode) */}
          {mode === "create" && (
            // Added margin-bottom to separate from transcription field
            <div className="flex flex-col sm:flex-row items-start sm:items-center space-y-2 sm:space-y-0 sm:space-x-4 mb-4">
              <input
                id="file-upload"
                type="file"
                accept=".txt"
                ref={fileInputRef}
                onChange={handleFileChange}
                className="hidden" // Hide the default input
                disabled={isBusy} // Disable file input while busy
              />
              {/* Style label to look like a button */}
              <Label
                htmlFor="file-upload"
                className="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 h-10 px-4 py-2 bg-primary text-primary-foreground hover:bg-primary/90 cursor-pointer"
                data-disabled={isBusy} // Use data-disabled for styling based on isBusy
              >
                Wczytaj plik TXT (max 1 MB)
              </Label>
              {fileName && <span className="text-sm text-muted-foreground">{fileName}</span>}
            </div>
          )}

          <div>
            <Label htmlFor="transcription">Transkrypcja</Label>
            <Textarea
              id="transcription"
              value={transcription}
              onChange={handleTranscriptionChange} // Use refined handler
              placeholder="Wklej lub wczytaj tekst transkrypcji tutaj..."
              rows={10}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          <div>
            <Label htmlFor="summary">Podsumowanie</Label>
            <Textarea
              id="summary"
              value={summary}
              onChange={handleSummaryChange}
              placeholder="Wygeneruj lub wpisz podsumowanie tutaj..."
              rows={6}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Notes field - Add this field */}
          <div>
            <Label htmlFor="notes">Notatki (opcjonalnie)</Label>
            <Textarea
              id="notes"
              value={notes || ""} // Use empty string for controlled component if notes is null
              onChange={handleNotesChange}
              placeholder="Dodaj dodatkowe notatki..."
              rows={3}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Display action-specific errors (e.g., LLM error, save error) */}
          {actionError && (
            // Added margin-top and positioned above action buttons
            <p className="text-sm font-medium text-red-500 mt-4 text-center">{actionError}</p>
          )}

          {/* Action Buttons */}
          <div className="flex flex-col sm:flex-row justify-end gap-2 pt-4">
            <Button variant="outline" onClick={handleCancel} disabled={isBusy}>
              Anuluj
            </Button>
            <Button onClick={handleSummarize} disabled={isSummarizeDisabled}>
              {isSummarizing && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Podsumuj
            </Button>
            <Button onClick={handleSave} disabled={isSaveDisabled}>
              {isSaving && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Zapisz
            </Button>
          </div>

          {/* Footer displaying ID in edit mode */}
          {mode === "edit" &&
            summaryId &&
            !isInitialLoading && ( // Only show if in edit mode and not initially loading
              <div className="text-sm text-muted-foreground mt-4 border-t pt-4 text-center">
                {" "}
                {/* Added border and padding top */}
                ID Podsumowania: {summaryId}
              </div>
            )}
        </>
      )}
    </div>
  );
};

export default SummaryForm;



================================================
File: .history/src/components/views/SummaryForm_20250421134811.tsx
================================================
// src/components/views/SummaryForm.tsx
import * as React from "react";
import { useState, useRef, useEffect, useCallback } from "react";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { toast } from "sonner";
import { Loader2 } from "lucide-react";
import type {
  GenerateSummaryCommand,
  GenerateSummaryResponseDto,
  CreateSummaryRequestDTO,
  MeetingSummaryDetailsDto,
  UpdateSummaryRequestDTO,
} from "@/types";
// import { supabase } from "@/auth"; // No longer needed directly for API calls needing auth token
import { apiService } from "@/lib/apiService"; // Import the apiService

interface SummaryFormProps {
  mode: "create" | "edit";
  summaryId?: string; // Required in 'edit' mode
}

const SummaryForm: React.FC<SummaryFormProps> = ({ mode, summaryId }) => {
  const [transcription, setTranscription] = useState("");
  const [summary, setSummary] = useState("");
  const [notes, setNotes] = useState<string | null>(""); // Initialize as empty string or null
  const [fileName, setFileName] = useState<string | null>(null); // For display in edit mode / payload in create
  const [isSummarizing, setIsSummarizing] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [loadError, setLoadError] = useState<string | null>(null); // For edit mode initial load error
  const [actionError, setActionError] = useState<string | null>(null); // For summarize/save errors
  const [isLLMGenerated, setIsLLMGenerated] = useState(false); // Track if current summary was LLM generated
  const [isInitialLoading, setIsInitialLoading] = useState(mode === "edit"); // Loading state for initial fetch in edit mode

  const fileInputRef = useRef<HTMLInputElement>(null);

  // Fetch summary details in edit mode
  const fetchSummary = useCallback(async (id: string) => {
    setIsInitialLoading(true);
    setLoadError(null); // Clear previous load errors
    try {
      // Use the apiService to fetch data
      const data = await apiService.getSummaryDetails(id);
      setTranscription(data.transcription || "");
      setSummary(data.summary || "");
      setNotes(data.notes || ""); // Initialize with empty string if notes is null
      setFileName(data.file_name || data.title || `Podsumowanie ${id}`); // Display file name or title
      setIsLLMGenerated(data.llm_generated);
      setIsInitialLoading(false);
    } catch (err: any) {
      console.error("Failed to fetch summary details:", err);
      // Display inline load error for edit mode
      setLoadError(
        "Nie udało się załadować podsumowania do edycji. Spróbuj ponownie. Szczegóły: " + (err.message || "")
      );
      setIsInitialLoading(false);
    }
  }, []);

  // Effect to load data in edit mode
  useEffect(() => {
    if (mode === "edit" && summaryId) {
      fetchSummary(summaryId);
    } else if (mode === "create") {
      // Clear states for create mode
      setTranscription("");
      setSummary("");
      setNotes(""); // Clear notes to empty string for new entry
      setFileName(null);
      setIsLLMGenerated(false);
      setIsInitialLoading(false); // No initial loading in create mode
      setLoadError(null);
      setActionError(null);
      // Clear file input value as well
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    }
  }, [mode, summaryId, fetchSummary]); // Depend on mode, summaryId, and memoized fetchSummary

  // Clear action error when user starts typing in transcription or summary or notes
  const handleTranscriptionChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setTranscription(e.target.value);
    setActionError(null); // Clear error when transcription changes
    // Decide if manual edit means it's no longer LLM generated?
    // Let's keep isLLMGenerated based on whether 'Podsumuj' was the *last* action populating summary.
  };

  const handleSummaryChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setSummary(e.target.value);
    setActionError(null); // Clear error when summary changes
    setIsLLMGenerated(false); // If user manually edits summary, it's not purely LLM generated anymore
  };

  const handleNotesChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setNotes(e.target.value);
    setActionError(null); // Clear error when notes change
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    setActionError(null); // Clear action errors on new file upload

    if (file) {
      if (file.size > 1024 * 1024) {
        // 1MB limit
        toast({
          description: "Plik jest za duży (max 1 MB).",
          variant: "destructive",
        });
        // Reset file input value to allow selecting the same file again after error
        if (fileInputRef.current) {
          fileInputRef.current.value = "";
        }
        setFileName(null);
        setTranscription(""); // Clear transcription as file is invalid
        setSummary(""); // Clear summary as transcription changed/failed
        setNotes(""); // Clear notes
        setIsLLMGenerated(false);
        return;
      }

      setFileName(file.name);
      setTranscription(""); // Clear old transcription
      setSummary(""); // Clear summary when a new transcription is loaded
      setNotes(""); // Clear notes
      setIsLLMGenerated(false); // Clear LLM status

      const reader = new FileReader();
      reader.onload = (e) => {
        const text = e.target?.result as string;
        setTranscription(text);
        toast({
          description: `Plik "${file.name}" wczytany.`,
          // variant: "success" // Add success variant styling
        });
      };
      reader.onerror = () => {
        setActionError("Nie udało się odczytać pliku.");
        setFileName(null);
        setTranscription("");
        setSummary("");
        setNotes("");
        setIsLLMGenerated(false);
        toast({
          description: `Błąd odczytu pliku "${file?.name}".`,
          variant: "destructive",
        });
      };
      reader.readAsText(file);
    } else {
      // File input was cancelled or cleared
      setFileName(null);
      setTranscription("");
      setSummary("");
      setNotes("");
      setIsLLMGenerated(false);
      setActionError(null); // Clear error if file input is cancelled/cleared
    }
    // Reset file input value when done processing (success or error)
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  const handleSummarize = async () => {
    // Basic validation before calling API
    if (!transcription.trim() || isBusy) return; // Check if transcription is empty or only whitespace

    setIsSummarizing(true);
    setActionError(null); // Clear previous action errors

    try {
      // apiService is updated to handle/skip auth based on MVP rules
      const result = await apiService.generateSummary({ transcription });
      setSummary(result.summary);
      setIsLLMGenerated(true); // Mark as LLM generated
      toast({
        description: "Podsumowanie wygenerowane pomyślnie.",
        // variant: "success" // Requires success variant styling
      });
    } catch (err: any) {
      // Explicitly type as any if error object structure is unknown
      console.error("Summarize error:", err);
      setActionError(`Błąd generowania podsumowania: ${err.message || "Nieznany błąd"}`);
      setSummary(""); // Clear summary on error
      setIsLLMGenerated(false); // Ensure flag is false on error
    } finally {
      setIsSummarizing(false);
    }
  };

  const handleSave = async () => {
    // Basic validation before calling API
    if (!summary.trim() || isBusy) return; // Check if summary is empty or only whitespace

    setIsSaving(true);
    setActionError(null); // Clear previous action errors

    try {
      if (mode === "create") {
        const payload: CreateSummaryRequestDTO = {
          file_name: fileName, // Include file name from state
          transcription: transcription, // Required
          summary: summary, // Required
          llm_generated: isLLMGenerated, // Use tracked status
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to create summary
        await apiService.createSummary(payload); // POST /api/summaries
        toast({
          description: "Podsumowanie zapisane.",
          // variant: "success" // Requires success variant styling
        });
        window.location.href = "/summaries"; // Redirect after create save
      } else if (mode === "edit" && summaryId) {
        const payload: UpdateSummaryRequestDTO = {
          // file_name is not typically updated in edit mode based on plan display
          // If file_name should be updatable, add: file_name: fileName,
          transcription: transcription, // Include transcription for update
          summary: summary, // Include summary for update
          llm_generated: isLLMGenerated, // Include status in update
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to update summary
        await apiService.updateSummary(summaryId, payload); // PUT /api/summaries/{id}

        toast({
          description: "Zmiany zapisane.",
          // variant: "success" // Requires success variant styling
        });
        // No redirect after edit save as per plan (user can click cancel/nav)
        setIsSaving(false); // Reset saving state on success if not redirecting
      }
    } catch (err: any) {
      // Explicitly type as any if error object structure is unknown
      console.error("Save error:", err);
      // Display inline save error
      setActionError(`Błąd zapisu: ${err.message || "Nieznany błąd"}`);
      setIsSaving(false); // Reset saving state on error
    }
  };

  const handleCancel = () => {
    // Simple redirect, no confirmation needed as per plan
    window.location.href = "/summaries"; // Navigate back
  };

  // Determine if any major operation is in progress to disable controls
  const isBusy = isInitialLoading || isSummarizing || isSaving;
  // Determine if save button should be disabled (requires non-empty summary AND not busy)
  const isSaveDisabled = !summary.trim() || isBusy;
  // Determine if summarize button should be disabled (requires non-empty transcription AND not busy)
  const isSummarizeDisabled = !transcription.trim() || isBusy;

  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold">{mode === "create" ? "Nowe podsumowanie" : `Edytuj podsumowanie`}</h1>
      {/* Display title/file name in edit mode if available */}
      {mode === "edit" &&
        !isInitialLoading &&
        (fileName || summaryId) && ( // Only show if not initially loading
          // Added margin-bottom to separate from fields below
          <div className="text-lg font-semibold text-muted-foreground -mt-4 mb-4">{fileName || `ID: ${summaryId}`}</div>
        )}

      {/* Display initial load error in edit mode */}
      {loadError && mode === "edit" && <p className="text-sm font-medium text-red-500">{loadError}</p>}

      {/* Display spinner for initial load in edit mode */}
      {isInitialLoading ? (
        <div className="flex flex-col justify-center items-center h-64">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
          <span className="mt-2 text-muted-foreground">Ładowanie podsumowania...</span>
        </div>
      ) : (
        <>
          {/* File Upload Section (only in create mode) */}
          {mode === "create" && (
            // Added margin-bottom to separate from transcription field
            <div className="flex flex-col sm:flex-row items-start sm:items-center space-y-2 sm:space-y-0 sm:space-x-4 mb-4">
              <input
                id="file-upload"
                type="file"
                accept=".txt"
                ref={fileInputRef}
                onChange={handleFileChange}
                className="hidden" // Hide the default input
                disabled={isBusy} // Disable file input while busy
              />
              {/* Style label to look like a button */}
              <Label
                htmlFor="file-upload"
                className="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 h-10 px-4 py-2 bg-primary text-primary-foreground hover:bg-primary/90 cursor-pointer"
                data-disabled={isBusy} // Use data-disabled for styling based on isBusy
              >
                Wczytaj plik TXT (max 1 MB)
              </Label>
              {fileName && <span className="text-sm text-muted-foreground">{fileName}</span>}
            </div>
          )}

          <div>
            <Label htmlFor="transcription">Transkrypcja</Label>
            <Textarea
              id="transcription"
              value={transcription}
              onChange={handleTranscriptionChange} // Use refined handler
              placeholder="Wklej lub wczytaj tekst transkrypcji tutaj..."
              rows={10}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          <div>
            <Label htmlFor="summary">Podsumowanie</Label>
            <Textarea
              id="summary"
              value={summary}
              onChange={handleSummaryChange}
              placeholder="Wygeneruj lub wpisz podsumowanie tutaj..."
              rows={6}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Notes field - Add this field */}
          <div>
            <Label htmlFor="notes">Notatki (opcjonalnie)</Label>
            <Textarea
              id="notes"
              value={notes || ""} // Use empty string for controlled component if notes is null
              onChange={handleNotesChange}
              placeholder="Dodaj dodatkowe notatki..."
              rows={3}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Display action-specific errors (e.g., LLM error, save error) */}
          {actionError && (
            // Added margin-top and positioned above action buttons
            <p className="text-sm font-medium text-red-500 mt-4 text-center">{actionError}</p>
          )}

          {/* Action Buttons */}
          <div className="flex flex-col sm:flex-row justify-end gap-2 pt-4">
            <Button variant="outline" onClick={handleCancel} disabled={isBusy}>
              Anuluj
            </Button>
            <Button onClick={handleSummarize} disabled={isSummarizeDisabled}>
              {isSummarizing && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Podsumuj
            </Button>
            <Button onClick={handleSave} disabled={isSaveDisabled}>
              {isSaving && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Zapisz
            </Button>
          </div>

          {/* Footer displaying ID in edit mode */}
          {mode === "edit" &&
            summaryId &&
            !isInitialLoading && ( // Only show if in edit mode and not initially loading
              <div className="text-sm text-muted-foreground mt-4 border-t pt-4 text-center">
                {" "}
                {/* Added border and padding top */}
                ID Podsumowania: {summaryId}
              </div>
            )}
        </>
      )}
    </div>
  );
};

export default SummaryForm;



================================================
File: .history/src/components/views/SummaryForm_20250421135309.tsx
================================================
// src/components/views/SummaryForm.tsx
import * as React from "react";
import { useState, useRef, useEffect, useCallback } from "react";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { toast } from "sonner";
import { Loader2 } from "lucide-react";
import type {
  GenerateSummaryCommand,
  GenerateSummaryResponseDto,
  CreateSummaryRequestDTO,
  MeetingSummaryDetailsDto,
  UpdateSummaryRequestDTO,
} from "@/types";
// import { supabase } from "@/auth"; // No longer needed directly for API calls needing auth token
import { apiService } from "@/lib/apiService"; // Import the apiService

interface SummaryFormProps {
  mode: "create" | "edit";
  summaryId?: string; // Required in 'edit' mode
}

const SummaryForm: React.FC<SummaryFormProps> = ({ mode, summaryId }) => {
  const [transcription, setTranscription] = useState("");
  const [summary, setSummary] = useState("");
  const [notes, setNotes] = useState<string | null>(""); // Initialize as empty string or null
  const [fileName, setFileName] = useState<string | null>(null); // For display in edit mode / payload in create
  const [isSummarizing, setIsSummarizing] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [loadError, setLoadError] = useState<string | null>(null); // For edit mode initial load error
  const [actionError, setActionError] = useState<string | null>(null); // For summarize/save errors
  const [isLLMGenerated, setIsLLMGenerated] = useState(false); // Track if current summary was LLM generated
  const [isInitialLoading, setIsInitialLoading] = useState(mode === "edit"); // Loading state for initial fetch in edit mode

  const fileInputRef = useRef<HTMLInputElement>(null);

  // Fetch summary details in edit mode
  const fetchSummary = useCallback(async (id: string) => {
    setIsInitialLoading(true);
    setLoadError(null); // Clear previous load errors
    try {
      // Use the apiService to fetch data
      const data = await apiService.getSummaryDetails(id);
      setTranscription(data.transcription || "");
      setSummary(data.summary || "");
      setNotes(data.notes || ""); // Initialize with empty string if notes is null
      setFileName(data.file_name || data.title || `Podsumowanie ${id}`); // Display file name or title
      setIsLLMGenerated(data.llm_generated);
      setIsInitialLoading(false);
    } catch (err: any) {
      console.error("Failed to fetch summary details:", err);
      // Display inline load error for edit mode
      setLoadError(
        "Nie udało się załadować podsumowania do edycji. Spróbuj ponownie. Szczegóły: " + (err.message || "")
      );
      setIsInitialLoading(false);
    }
  }, []);

  // Effect to load data in edit mode
  useEffect(() => {
    if (mode === "edit" && summaryId) {
      fetchSummary(summaryId);
    } else if (mode === "create") {
      // Clear states for create mode
      setTranscription("");
      setSummary("");
      setNotes(""); // Clear notes to empty string for new entry
      setFileName(null);
      setIsLLMGenerated(false);
      setIsInitialLoading(false); // No initial loading in create mode
      setLoadError(null);
      setActionError(null);
      // Clear file input value as well
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    }
  }, [mode, summaryId, fetchSummary]); // Depend on mode, summaryId, and memoized fetchSummary

  // Clear action error when user starts typing in transcription or summary or notes
  const handleTranscriptionChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setTranscription(e.target.value);
    setActionError(null); // Clear error when transcription changes
    // Decide if manual edit means it's no longer LLM generated?
    // Let's keep isLLMGenerated based on whether 'Podsumuj' was the *last* action populating summary.
  };

  const handleSummaryChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setSummary(e.target.value);
    setActionError(null); // Clear error when summary changes
    setIsLLMGenerated(false); // If user manually edits summary, it's not purely LLM generated anymore
  };

  const handleNotesChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setNotes(e.target.value);
    setActionError(null); // Clear error when notes change
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    setActionError(null); // Clear action errors on new file upload

    if (file) {
      if (file.size > 1024 * 1024) {
        // 1MB limit
        toast({
          description: "Plik jest za duży (max 1 MB).",
          variant: "destructive",
        });
        // Reset file input value to allow selecting the same file again after error
        if (fileInputRef.current) {
          fileInputRef.current.value = "";
        }
        setFileName(null);
        setTranscription(""); // Clear transcription as file is invalid
        setSummary(""); // Clear summary as transcription changed/failed
        setNotes(""); // Clear notes
        setIsLLMGenerated(false);
        return;
      }

      setFileName(file.name);
      setTranscription(""); // Clear old transcription
      setSummary(""); // Clear summary when a new transcription is loaded
      setNotes(""); // Clear notes
      setIsLLMGenerated(false); // Clear LLM status

      const reader = new FileReader();
      reader.onload = (e) => {
        const text = e.target?.result as string;
        setTranscription(text);
        toast({
          description: `Plik "${file.name}" wczytany.`,
          // variant: "success" // Add success variant styling
        });
      };
      reader.onerror = () => {
        setActionError("Nie udało się odczytać pliku.");
        setFileName(null);
        setTranscription("");
        setSummary("");
        setNotes("");
        setIsLLMGenerated(false);
        toast({
          description: `Błąd odczytu pliku "${file?.name}".`,
          variant: "destructive",
        });
      };
      reader.readAsText(file);
    } else {
      // File input was cancelled or cleared
      setFileName(null);
      setTranscription("");
      setSummary("");
      setNotes("");
      setIsLLMGenerated(false);
      setActionError(null); // Clear error if file input is cancelled/cleared
    }
    // Reset file input value when done processing (success or error)
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  const handleSummarize = async () => {
    // Basic validation before calling API
    if (!transcription.trim() || isBusy) return; // Check if transcription is empty or only whitespace

    setIsSummarizing(true);
    setActionError(null); // Clear previous action errors

    try {
      // apiService is updated to handle/skip auth based on MVP rules
      const result = await apiService.generateSummary({ transcription });
      setSummary(result.summary);
      setIsLLMGenerated(true); // Mark as LLM generated
      toast({
        description: "Podsumowanie wygenerowane pomyślnie.",
        // variant: "success" // Requires success variant styling
      });
    } catch (err: any) {
      // Explicitly type as any if error object structure is unknown
      console.error("Summarize error:", err);
      setActionError(`Błąd generowania podsumowania: ${err.message || "Nieznany błąd"}`);
      setSummary(""); // Clear summary on error
      setIsLLMGenerated(false); // Ensure flag is false on error
    } finally {
      setIsSummarizing(false);
    }
  };

  const handleSave = async () => {
    // Basic validation before calling API
    if (!summary.trim() || isBusy) return; // Check if summary is empty or only whitespace

    setIsSaving(true);
    setActionError(null); // Clear previous action errors

    try {
      if (mode === "create") {
        const payload: CreateSummaryRequestDTO = {
          file_name: fileName, // Include file name from state
          transcription: transcription, // Required
          summary: summary, // Required
          llm_generated: isLLMGenerated, // Use tracked status
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to create summary
        await apiService.createSummary(payload); // POST /api/summaries
        toast({
          description: "Podsumowanie zapisane.",
          // variant: "success" // Requires success variant styling
        });
        window.location.href = "/summaries"; // Redirect after create save
      } else if (mode === "edit" && summaryId) {
        const payload: UpdateSummaryRequestDTO = {
          // file_name is not typically updated in edit mode based on plan display
          // If file_name should be updatable, add: file_name: fileName,
          transcription: transcription, // Include transcription for update
          summary: summary, // Include summary for update
          llm_generated: isLLMGenerated, // Include status in update
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to update summary
        await apiService.updateSummary(summaryId, payload); // PUT /api/summaries/{id}

        toast({
          description: "Zmiany zapisane.",
          // variant: "success" // Requires success variant styling
        });
        // No redirect after edit save as per plan (user can click cancel/nav)
        setIsSaving(false); // Reset saving state on success if not redirecting
      }
    } catch (err: any) {
      // Explicitly type as any if error object structure is unknown
      console.error("Save error:", err);
      // Display inline save error
      setActionError(`Błąd zapisu: ${err.message || "Nieznany błąd"}`);
      setIsSaving(false); // Reset saving state on error
    }
  };

  const handleCancel = () => {
    // Simple redirect, no confirmation needed as per plan
    window.location.href = "/summaries"; // Navigate back
  };

  // Determine if any major operation is in progress to disable controls
  const isBusy = isInitialLoading || isSummarizing || isSaving;
  // Determine if save button should be disabled (requires non-empty summary AND not busy)
  const isSaveDisabled = !summary.trim() || isBusy;
  // Determine if summarize button should be disabled (requires non-empty transcription AND not busy)
  const isSummarizeDisabled = !transcription.trim() || isBusy;

  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold">{mode === "create" ? "Nowe podsumowanie" : `Edytuj podsumowanie`}</h1>
      {/* Display title/file name in edit mode if available */}
      {mode === "edit" &&
        !isInitialLoading &&
        (fileName || summaryId) && ( // Only show if not initially loading
          // Added margin-bottom to separate from fields below
          <div className="text-lg font-semibold text-muted-foreground -mt-4 mb-4">{fileName || `ID: ${summaryId}`}</div>
        )}

      {/* Display initial load error in edit mode */}
      {loadError && mode === "edit" && <p className="text-sm font-medium text-red-500">{loadError}</p>}

      {/* Display spinner for initial load in edit mode */}
      {isInitialLoading ? (
        <div className="flex flex-col justify-center items-center h-64">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
          <span className="mt-2 text-muted-foreground">Ładowanie podsumowania...</span>
        </div>
      ) : (
        <>
          {/* File Upload Section (only in create mode) */}
          {mode === "create" && (
            // Added margin-bottom to separate from transcription field
            <div className="flex flex-col sm:flex-row items-start sm:items-center space-y-2 sm:space-y-0 sm:space-x-4 mb-4">
              <input
                id="file-upload"
                type="file"
                accept=".txt"
                ref={fileInputRef}
                onChange={handleFileChange}
                className="hidden" // Hide the default input
                disabled={isBusy} // Disable file input while busy
              />
              {/* Style label to look like a button */}
              <Label
                htmlFor="file-upload"
                className="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 h-10 px-4 py-2 bg-primary text-primary-foreground hover:bg-primary/90 cursor-pointer"
                data-disabled={isBusy} // Use data-disabled for styling based on isBusy
              >
                Wczytaj plik TXT (max 1 MB)
              </Label>
              {fileName && <span className="text-sm text-muted-foreground">{fileName}</span>}
            </div>
          )}

          <div>
            <Label htmlFor="transcription">Transkrypcja</Label>
            <Textarea
              id="transcription"
              value={transcription}
              onChange={handleTranscriptionChange} // Use refined handler
              placeholder="Wklej lub wczytaj tekst transkrypcji tutaj..."
              rows={10}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          <div>
            <Label htmlFor="summary">Podsumowanie</Label>
            <Textarea
              id="summary"
              value={summary}
              onChange={handleSummaryChange}
              placeholder="Wygeneruj lub wpisz podsumowanie tutaj..."
              rows={6}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Notes field - Add this field */}
          <div>
            <Label htmlFor="notes">Notatki (opcjonalnie)</Label>
            <Textarea
              id="notes"
              value={notes || ""} // Use empty string for controlled component if notes is null
              onChange={handleNotesChange}
              placeholder="Dodaj dodatkowe notatki..."
              rows={3}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Display action-specific errors (e.g., LLM error, save error) */}
          {actionError && (
            // Added margin-top and positioned above action buttons
            <p className="text-sm font-medium text-red-500 mt-4 text-center">{actionError}</p>
          )}

          {/* Action Buttons */}
          <div className="flex flex-col sm:flex-row justify-end gap-2 pt-4">
            <Button variant="outline" onClick={handleCancel} disabled={isBusy}>
              Anuluj
            </Button>
            <Button onClick={handleSummarize} disabled={isSummarizeDisabled}>
              {isSummarizing && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Podsumuj
            </Button>
            <Button onClick={handleSave} disabled={isSaveDisabled}>
              {isSaving && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Zapisz
            </Button>
          </div>

          {/* Footer displaying ID in edit mode */}
          {mode === "edit" &&
            summaryId &&
            !isInitialLoading && ( // Only show if in edit mode and not initially loading
              <div className="text-sm text-muted-foreground mt-4 border-t pt-4 text-center">
                {" "}
                {/* Added border and padding top */}
                ID Podsumowania: {summaryId}
              </div>
            )}
        </>
      )}
    </div>
  );
};

export default SummaryForm;



================================================
File: .history/src/components/views/SummaryForm_20250421135358.tsx
================================================
// src/components/views/SummaryForm.tsx
import * as React from "react";
import { useState, useRef, useEffect, useCallback } from "react";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { toast } from "sonner";
import { Loader2 } from "lucide-react";
import type { CreateSummaryRequestDTO, UpdateSummaryRequestDTO } from "@/types";
// import { supabase } from "@/auth"; // No longer needed directly for API calls needing auth token
import { apiService } from "@/lib/apiService"; // Import the apiService

interface SummaryFormProps {
  mode: "create" | "edit";
  summaryId?: string; // Required in 'edit' mode
}

const SummaryForm: React.FC<SummaryFormProps> = ({ mode, summaryId }) => {
  const [transcription, setTranscription] = useState("");
  const [summary, setSummary] = useState("");
  const [notes, setNotes] = useState<string | null>(""); // Initialize as empty string or null
  const [fileName, setFileName] = useState<string | null>(null); // For display in edit mode / payload in create
  const [isSummarizing, setIsSummarizing] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [loadError, setLoadError] = useState<string | null>(null); // For edit mode initial load error
  const [actionError, setActionError] = useState<string | null>(null); // For summarize/save errors
  const [isLLMGenerated, setIsLLMGenerated] = useState(false); // Track if current summary was LLM generated
  const [isInitialLoading, setIsInitialLoading] = useState(mode === "edit"); // Loading state for initial fetch in edit mode

  const fileInputRef = useRef<HTMLInputElement>(null);

  // Fetch summary details in edit mode
  const fetchSummary = useCallback(async (id: string) => {
    setIsInitialLoading(true);
    setLoadError(null); // Clear previous load errors
    try {
      // Use the apiService to fetch data
      const data = await apiService.getSummaryDetails(id);
      setTranscription(data.transcription || "");
      setSummary(data.summary || "");
      setNotes(data.notes || ""); // Initialize with empty string if notes is null
      setFileName(data.file_name || data.title || `Podsumowanie ${id}`); // Display file name or title
      setIsLLMGenerated(data.llm_generated);
      setIsInitialLoading(false);
    } catch (err: any) {
      console.error("Failed to fetch summary details:", err);
      // Display inline load error for edit mode
      setLoadError(
        "Nie udało się załadować podsumowania do edycji. Spróbuj ponownie. Szczegóły: " + (err.message || "")
      );
      setIsInitialLoading(false);
    }
  }, []);

  // Effect to load data in edit mode
  useEffect(() => {
    if (mode === "edit" && summaryId) {
      fetchSummary(summaryId);
    } else if (mode === "create") {
      // Clear states for create mode
      setTranscription("");
      setSummary("");
      setNotes(""); // Clear notes to empty string for new entry
      setFileName(null);
      setIsLLMGenerated(false);
      setIsInitialLoading(false); // No initial loading in create mode
      setLoadError(null);
      setActionError(null);
      // Clear file input value as well
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    }
  }, [mode, summaryId, fetchSummary]); // Depend on mode, summaryId, and memoized fetchSummary

  // Clear action error when user starts typing in transcription or summary or notes
  const handleTranscriptionChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setTranscription(e.target.value);
    setActionError(null); // Clear error when transcription changes
    // Decide if manual edit means it's no longer LLM generated?
    // Let's keep isLLMGenerated based on whether 'Podsumuj' was the *last* action populating summary.
  };

  const handleSummaryChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setSummary(e.target.value);
    setActionError(null); // Clear error when summary changes
    setIsLLMGenerated(false); // If user manually edits summary, it's not purely LLM generated anymore
  };

  const handleNotesChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setNotes(e.target.value);
    setActionError(null); // Clear error when notes change
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    setActionError(null); // Clear action errors on new file upload

    if (file) {
      if (file.size > 1024 * 1024) {
        // 1MB limit
        toast({
          description: "Plik jest za duży (max 1 MB).",
          variant: "destructive",
        });
        // Reset file input value to allow selecting the same file again after error
        if (fileInputRef.current) {
          fileInputRef.current.value = "";
        }
        setFileName(null);
        setTranscription(""); // Clear transcription as file is invalid
        setSummary(""); // Clear summary as transcription changed/failed
        setNotes(""); // Clear notes
        setIsLLMGenerated(false);
        return;
      }

      setFileName(file.name);
      setTranscription(""); // Clear old transcription
      setSummary(""); // Clear summary when a new transcription is loaded
      setNotes(""); // Clear notes
      setIsLLMGenerated(false); // Clear LLM status

      const reader = new FileReader();
      reader.onload = (e) => {
        const text = e.target?.result as string;
        setTranscription(text);
        toast({
          description: `Plik "${file.name}" wczytany.`,
          // variant: "success" // Add success variant styling
        });
      };
      reader.onerror = () => {
        setActionError("Nie udało się odczytać pliku.");
        setFileName(null);
        setTranscription("");
        setSummary("");
        setNotes("");
        setIsLLMGenerated(false);
        toast({
          description: `Błąd odczytu pliku "${file?.name}".`,
          variant: "destructive",
        });
      };
      reader.readAsText(file);
    } else {
      // File input was cancelled or cleared
      setFileName(null);
      setTranscription("");
      setSummary("");
      setNotes("");
      setIsLLMGenerated(false);
      setActionError(null); // Clear error if file input is cancelled/cleared
    }
    // Reset file input value when done processing (success or error)
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  const handleSummarize = async () => {
    // Basic validation before calling API
    if (!transcription.trim() || isBusy) return; // Check if transcription is empty or only whitespace

    setIsSummarizing(true);
    setActionError(null); // Clear previous action errors

    try {
      // apiService is updated to handle/skip auth based on MVP rules
      const result = await apiService.generateSummary({ transcription });
      setSummary(result.summary);
      setIsLLMGenerated(true); // Mark as LLM generated
      toast({
        description: "Podsumowanie wygenerowane pomyślnie.",
        // variant: "success" // Requires success variant styling
      });
    } catch (err: any) {
      // Explicitly type as any if error object structure is unknown
      console.error("Summarize error:", err);
      setActionError(`Błąd generowania podsumowania: ${err.message || "Nieznany błąd"}`);
      setSummary(""); // Clear summary on error
      setIsLLMGenerated(false); // Ensure flag is false on error
    } finally {
      setIsSummarizing(false);
    }
  };

  const handleSave = async () => {
    // Basic validation before calling API
    if (!summary.trim() || isBusy) return; // Check if summary is empty or only whitespace

    setIsSaving(true);
    setActionError(null); // Clear previous action errors

    try {
      if (mode === "create") {
        const payload: CreateSummaryRequestDTO = {
          file_name: fileName, // Include file name from state
          transcription: transcription, // Required
          summary: summary, // Required
          llm_generated: isLLMGenerated, // Use tracked status
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to create summary
        await apiService.createSummary(payload); // POST /api/summaries
        toast({
          description: "Podsumowanie zapisane.",
          // variant: "success" // Requires success variant styling
        });
        window.location.href = "/summaries"; // Redirect after create save
      } else if (mode === "edit" && summaryId) {
        const payload: UpdateSummaryRequestDTO = {
          // file_name is not typically updated in edit mode based on plan display
          // If file_name should be updatable, add: file_name: fileName,
          transcription: transcription, // Include transcription for update
          summary: summary, // Include summary for update
          llm_generated: isLLMGenerated, // Include status in update
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to update summary
        await apiService.updateSummary(summaryId, payload); // PUT /api/summaries/{id}

        toast({
          description: "Zmiany zapisane.",
          // variant: "success" // Requires success variant styling
        });
        // No redirect after edit save as per plan (user can click cancel/nav)
        setIsSaving(false); // Reset saving state on success if not redirecting
      }
    } catch (err: any) {
      // Explicitly type as any if error object structure is unknown
      console.error("Save error:", err);
      // Display inline save error
      setActionError(`Błąd zapisu: ${err.message || "Nieznany błąd"}`);
      setIsSaving(false); // Reset saving state on error
    }
  };

  const handleCancel = () => {
    // Simple redirect, no confirmation needed as per plan
    window.location.href = "/summaries"; // Navigate back
  };

  // Determine if any major operation is in progress to disable controls
  const isBusy = isInitialLoading || isSummarizing || isSaving;
  // Determine if save button should be disabled (requires non-empty summary AND not busy)
  const isSaveDisabled = !summary.trim() || isBusy;
  // Determine if summarize button should be disabled (requires non-empty transcription AND not busy)
  const isSummarizeDisabled = !transcription.trim() || isBusy;

  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold">{mode === "create" ? "Nowe podsumowanie" : `Edytuj podsumowanie`}</h1>
      {/* Display title/file name in edit mode if available */}
      {mode === "edit" &&
        !isInitialLoading &&
        (fileName || summaryId) && ( // Only show if not initially loading
          // Added margin-bottom to separate from fields below
          <div className="text-lg font-semibold text-muted-foreground -mt-4 mb-4">{fileName || `ID: ${summaryId}`}</div>
        )}

      {/* Display initial load error in edit mode */}
      {loadError && mode === "edit" && <p className="text-sm font-medium text-red-500">{loadError}</p>}

      {/* Display spinner for initial load in edit mode */}
      {isInitialLoading ? (
        <div className="flex flex-col justify-center items-center h-64">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
          <span className="mt-2 text-muted-foreground">Ładowanie podsumowania...</span>
        </div>
      ) : (
        <>
          {/* File Upload Section (only in create mode) */}
          {mode === "create" && (
            // Added margin-bottom to separate from transcription field
            <div className="flex flex-col sm:flex-row items-start sm:items-center space-y-2 sm:space-y-0 sm:space-x-4 mb-4">
              <input
                id="file-upload"
                type="file"
                accept=".txt"
                ref={fileInputRef}
                onChange={handleFileChange}
                className="hidden" // Hide the default input
                disabled={isBusy} // Disable file input while busy
              />
              {/* Style label to look like a button */}
              <Label
                htmlFor="file-upload"
                className="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 h-10 px-4 py-2 bg-primary text-primary-foreground hover:bg-primary/90 cursor-pointer"
                data-disabled={isBusy} // Use data-disabled for styling based on isBusy
              >
                Wczytaj plik TXT (max 1 MB)
              </Label>
              {fileName && <span className="text-sm text-muted-foreground">{fileName}</span>}
            </div>
          )}

          <div>
            <Label htmlFor="transcription">Transkrypcja</Label>
            <Textarea
              id="transcription"
              value={transcription}
              onChange={handleTranscriptionChange} // Use refined handler
              placeholder="Wklej lub wczytaj tekst transkrypcji tutaj..."
              rows={10}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          <div>
            <Label htmlFor="summary">Podsumowanie</Label>
            <Textarea
              id="summary"
              value={summary}
              onChange={handleSummaryChange}
              placeholder="Wygeneruj lub wpisz podsumowanie tutaj..."
              rows={6}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Notes field - Add this field */}
          <div>
            <Label htmlFor="notes">Notatki (opcjonalnie)</Label>
            <Textarea
              id="notes"
              value={notes || ""} // Use empty string for controlled component if notes is null
              onChange={handleNotesChange}
              placeholder="Dodaj dodatkowe notatki..."
              rows={3}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Display action-specific errors (e.g., LLM error, save error) */}
          {actionError && (
            // Added margin-top and positioned above action buttons
            <p className="text-sm font-medium text-red-500 mt-4 text-center">{actionError}</p>
          )}

          {/* Action Buttons */}
          <div className="flex flex-col sm:flex-row justify-end gap-2 pt-4">
            <Button variant="outline" onClick={handleCancel} disabled={isBusy}>
              Anuluj
            </Button>
            <Button onClick={handleSummarize} disabled={isSummarizeDisabled}>
              {isSummarizing && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Podsumuj
            </Button>
            <Button onClick={handleSave} disabled={isSaveDisabled}>
              {isSaving && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Zapisz
            </Button>
          </div>

          {/* Footer displaying ID in edit mode */}
          {mode === "edit" &&
            summaryId &&
            !isInitialLoading && ( // Only show if in edit mode and not initially loading
              <div className="text-sm text-muted-foreground mt-4 border-t pt-4 text-center">
                {" "}
                {/* Added border and padding top */}
                ID Podsumowania: {summaryId}
              </div>
            )}
        </>
      )}
    </div>
  );
};

export default SummaryForm;



================================================
File: .history/src/components/views/SummaryForm_20250421135359.tsx
================================================
// src/components/views/SummaryForm.tsx
import * as React from "react";
import { useState, useRef, useEffect, useCallback } from "react";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { toast } from "sonner";
import { Loader2 } from "lucide-react";
import type { CreateSummaryRequestDTO, UpdateSummaryRequestDTO } from "@/types";
// import { supabase } from "@/auth"; // No longer needed directly for API calls needing auth token
import { apiService } from "@/lib/apiService"; // Import the apiService

interface SummaryFormProps {
  mode: "create" | "edit";
  summaryId?: string; // Required in 'edit' mode
}

const SummaryForm: React.FC<SummaryFormProps> = ({ mode, summaryId }) => {
  const [transcription, setTranscription] = useState("");
  const [summary, setSummary] = useState("");
  const [notes, setNotes] = useState<string | null>(""); // Initialize as empty string or null
  const [fileName, setFileName] = useState<string | null>(null); // For display in edit mode / payload in create
  const [isSummarizing, setIsSummarizing] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [loadError, setLoadError] = useState<string | null>(null); // For edit mode initial load error
  const [actionError, setActionError] = useState<string | null>(null); // For summarize/save errors
  const [isLLMGenerated, setIsLLMGenerated] = useState(false); // Track if current summary was LLM generated
  const [isInitialLoading, setIsInitialLoading] = useState(mode === "edit"); // Loading state for initial fetch in edit mode

  const fileInputRef = useRef<HTMLInputElement>(null);

  // Fetch summary details in edit mode
  const fetchSummary = useCallback(async (id: string) => {
    setIsInitialLoading(true);
    setLoadError(null); // Clear previous load errors
    try {
      // Use the apiService to fetch data
      const data = await apiService.getSummaryDetails(id);
      setTranscription(data.transcription || "");
      setSummary(data.summary || "");
      setNotes(data.notes || ""); // Initialize with empty string if notes is null
      setFileName(data.file_name || data.title || `Podsumowanie ${id}`); // Display file name or title
      setIsLLMGenerated(data.llm_generated);
      setIsInitialLoading(false);
    } catch (err: any) {
      console.error("Failed to fetch summary details:", err);
      // Display inline load error for edit mode
      setLoadError(
        "Nie udało się załadować podsumowania do edycji. Spróbuj ponownie. Szczegóły: " + (err.message || "")
      );
      setIsInitialLoading(false);
    }
  }, []);

  // Effect to load data in edit mode
  useEffect(() => {
    if (mode === "edit" && summaryId) {
      fetchSummary(summaryId);
    } else if (mode === "create") {
      // Clear states for create mode
      setTranscription("");
      setSummary("");
      setNotes(""); // Clear notes to empty string for new entry
      setFileName(null);
      setIsLLMGenerated(false);
      setIsInitialLoading(false); // No initial loading in create mode
      setLoadError(null);
      setActionError(null);
      // Clear file input value as well
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    }
  }, [mode, summaryId, fetchSummary]); // Depend on mode, summaryId, and memoized fetchSummary

  // Clear action error when user starts typing in transcription or summary or notes
  const handleTranscriptionChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setTranscription(e.target.value);
    setActionError(null); // Clear error when transcription changes
    // Decide if manual edit means it's no longer LLM generated?
    // Let's keep isLLMGenerated based on whether 'Podsumuj' was the *last* action populating summary.
  };

  const handleSummaryChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setSummary(e.target.value);
    setActionError(null); // Clear error when summary changes
    setIsLLMGenerated(false); // If user manually edits summary, it's not purely LLM generated anymore
  };

  const handleNotesChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setNotes(e.target.value);
    setActionError(null); // Clear error when notes change
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    setActionError(null); // Clear action errors on new file upload

    if (file) {
      if (file.size > 1024 * 1024) {
        // 1MB limit
        toast({
          description: "Plik jest za duży (max 1 MB).",
          variant: "destructive",
        });
        // Reset file input value to allow selecting the same file again after error
        if (fileInputRef.current) {
          fileInputRef.current.value = "";
        }
        setFileName(null);
        setTranscription(""); // Clear transcription as file is invalid
        setSummary(""); // Clear summary as transcription changed/failed
        setNotes(""); // Clear notes
        setIsLLMGenerated(false);
        return;
      }

      setFileName(file.name);
      setTranscription(""); // Clear old transcription
      setSummary(""); // Clear summary when a new transcription is loaded
      setNotes(""); // Clear notes
      setIsLLMGenerated(false); // Clear LLM status

      const reader = new FileReader();
      reader.onload = (e) => {
        const text = e.target?.result as string;
        setTranscription(text);
        toast({
          description: `Plik "${file.name}" wczytany.`,
          // variant: "success" // Add success variant styling
        });
      };
      reader.onerror = () => {
        setActionError("Nie udało się odczytać pliku.");
        setFileName(null);
        setTranscription("");
        setSummary("");
        setNotes("");
        setIsLLMGenerated(false);
        toast({
          description: `Błąd odczytu pliku "${file?.name}".`,
          variant: "destructive",
        });
      };
      reader.readAsText(file);
    } else {
      // File input was cancelled or cleared
      setFileName(null);
      setTranscription("");
      setSummary("");
      setNotes("");
      setIsLLMGenerated(false);
      setActionError(null); // Clear error if file input is cancelled/cleared
    }
    // Reset file input value when done processing (success or error)
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  const handleSummarize = async () => {
    // Basic validation before calling API
    if (!transcription.trim() || isBusy) return; // Check if transcription is empty or only whitespace

    setIsSummarizing(true);
    setActionError(null); // Clear previous action errors

    try {
      // apiService is updated to handle/skip auth based on MVP rules
      const result = await apiService.generateSummary({ transcription });
      setSummary(result.summary);
      setIsLLMGenerated(true); // Mark as LLM generated
      toast({
        description: "Podsumowanie wygenerowane pomyślnie.",
        // variant: "success" // Requires success variant styling
      });
    } catch (err: any) {
      // Explicitly type as any if error object structure is unknown
      console.error("Summarize error:", err);
      setActionError(`Błąd generowania podsumowania: ${err.message || "Nieznany błąd"}`);
      setSummary(""); // Clear summary on error
      setIsLLMGenerated(false); // Ensure flag is false on error
    } finally {
      setIsSummarizing(false);
    }
  };

  const handleSave = async () => {
    // Basic validation before calling API
    if (!summary.trim() || isBusy) return; // Check if summary is empty or only whitespace

    setIsSaving(true);
    setActionError(null); // Clear previous action errors

    try {
      if (mode === "create") {
        const payload: CreateSummaryRequestDTO = {
          file_name: fileName, // Include file name from state
          transcription: transcription, // Required
          summary: summary, // Required
          llm_generated: isLLMGenerated, // Use tracked status
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to create summary
        await apiService.createSummary(payload); // POST /api/summaries
        toast({
          description: "Podsumowanie zapisane.",
          // variant: "success" // Requires success variant styling
        });
        window.location.href = "/summaries"; // Redirect after create save
      } else if (mode === "edit" && summaryId) {
        const payload: UpdateSummaryRequestDTO = {
          // file_name is not typically updated in edit mode based on plan display
          // If file_name should be updatable, add: file_name: fileName,
          transcription: transcription, // Include transcription for update
          summary: summary, // Include summary for update
          llm_generated: isLLMGenerated, // Include status in update
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to update summary
        await apiService.updateSummary(summaryId, payload); // PUT /api/summaries/{id}

        toast({
          description: "Zmiany zapisane.",
          // variant: "success" // Requires success variant styling
        });
        // No redirect after edit save as per plan (user can click cancel/nav)
        setIsSaving(false); // Reset saving state on success if not redirecting
      }
    } catch (err: any) {
      // Explicitly type as any if error object structure is unknown
      console.error("Save error:", err);
      // Display inline save error
      setActionError(`Błąd zapisu: ${err.message || "Nieznany błąd"}`);
      setIsSaving(false); // Reset saving state on error
    }
  };

  const handleCancel = () => {
    // Simple redirect, no confirmation needed as per plan
    window.location.href = "/summaries"; // Navigate back
  };

  // Determine if any major operation is in progress to disable controls
  const isBusy = isInitialLoading || isSummarizing || isSaving;
  // Determine if save button should be disabled (requires non-empty summary AND not busy)
  const isSaveDisabled = !summary.trim() || isBusy;
  // Determine if summarize button should be disabled (requires non-empty transcription AND not busy)
  const isSummarizeDisabled = !transcription.trim() || isBusy;

  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold">{mode === "create" ? "Nowe podsumowanie" : `Edytuj podsumowanie`}</h1>
      {/* Display title/file name in edit mode if available */}
      {mode === "edit" &&
        !isInitialLoading &&
        (fileName || summaryId) && ( // Only show if not initially loading
          // Added margin-bottom to separate from fields below
          <div className="text-lg font-semibold text-muted-foreground -mt-4 mb-4">{fileName || `ID: ${summaryId}`}</div>
        )}

      {/* Display initial load error in edit mode */}
      {loadError && mode === "edit" && <p className="text-sm font-medium text-red-500">{loadError}</p>}

      {/* Display spinner for initial load in edit mode */}
      {isInitialLoading ? (
        <div className="flex flex-col justify-center items-center h-64">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
          <span className="mt-2 text-muted-foreground">Ładowanie podsumowania...</span>
        </div>
      ) : (
        <>
          {/* File Upload Section (only in create mode) */}
          {mode === "create" && (
            // Added margin-bottom to separate from transcription field
            <div className="flex flex-col sm:flex-row items-start sm:items-center space-y-2 sm:space-y-0 sm:space-x-4 mb-4">
              <input
                id="file-upload"
                type="file"
                accept=".txt"
                ref={fileInputRef}
                onChange={handleFileChange}
                className="hidden" // Hide the default input
                disabled={isBusy} // Disable file input while busy
              />
              {/* Style label to look like a button */}
              <Label
                htmlFor="file-upload"
                className="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 h-10 px-4 py-2 bg-primary text-primary-foreground hover:bg-primary/90 cursor-pointer"
                data-disabled={isBusy} // Use data-disabled for styling based on isBusy
              >
                Wczytaj plik TXT (max 1 MB)
              </Label>
              {fileName && <span className="text-sm text-muted-foreground">{fileName}</span>}
            </div>
          )}

          <div>
            <Label htmlFor="transcription">Transkrypcja</Label>
            <Textarea
              id="transcription"
              value={transcription}
              onChange={handleTranscriptionChange} // Use refined handler
              placeholder="Wklej lub wczytaj tekst transkrypcji tutaj..."
              rows={10}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          <div>
            <Label htmlFor="summary">Podsumowanie</Label>
            <Textarea
              id="summary"
              value={summary}
              onChange={handleSummaryChange}
              placeholder="Wygeneruj lub wpisz podsumowanie tutaj..."
              rows={6}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Notes field - Add this field */}
          <div>
            <Label htmlFor="notes">Notatki (opcjonalnie)</Label>
            <Textarea
              id="notes"
              value={notes || ""} // Use empty string for controlled component if notes is null
              onChange={handleNotesChange}
              placeholder="Dodaj dodatkowe notatki..."
              rows={3}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Display action-specific errors (e.g., LLM error, save error) */}
          {actionError && (
            // Added margin-top and positioned above action buttons
            <p className="text-sm font-medium text-red-500 mt-4 text-center">{actionError}</p>
          )}

          {/* Action Buttons */}
          <div className="flex flex-col sm:flex-row justify-end gap-2 pt-4">
            <Button variant="outline" onClick={handleCancel} disabled={isBusy}>
              Anuluj
            </Button>
            <Button onClick={handleSummarize} disabled={isSummarizeDisabled}>
              {isSummarizing && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Podsumuj
            </Button>
            <Button onClick={handleSave} disabled={isSaveDisabled}>
              {isSaving && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Zapisz
            </Button>
          </div>

          {/* Footer displaying ID in edit mode */}
          {mode === "edit" &&
            summaryId &&
            !isInitialLoading && ( // Only show if in edit mode and not initially loading
              <div className="text-sm text-muted-foreground mt-4 border-t pt-4 text-center">
                {" "}
                {/* Added border and padding top */}
                ID Podsumowania: {summaryId}
              </div>
            )}
        </>
      )}
    </div>
  );
};

export default SummaryForm;



================================================
File: .history/src/components/views/SummaryForm_20250421135453.tsx
================================================
// src/components/views/SummaryForm.tsx
import * as React from "react";
import { useState, useRef, useEffect, useCallback } from "react";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea"; // Corrected the path to match the project structure
import { toast } from "sonner";
import { Loader2 } from "lucide-react";
import type { CreateSummaryRequestDTO, UpdateSummaryRequestDTO } from "@/types";
// import { supabase } from "@/auth"; // No longer needed directly for API calls needing auth token
import { apiService } from "@/lib/apiService"; // Import the apiService

interface SummaryFormProps {
  mode: "create" | "edit";
  summaryId?: string; // Required in 'edit' mode
}

const SummaryForm: React.FC<SummaryFormProps> = ({ mode, summaryId }) => {
  const [transcription, setTranscription] = useState("");
  const [summary, setSummary] = useState("");
  const [notes, setNotes] = useState<string | null>(""); // Initialize as empty string or null
  const [fileName, setFileName] = useState<string | null>(null); // For display in edit mode / payload in create
  const [isSummarizing, setIsSummarizing] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [loadError, setLoadError] = useState<string | null>(null); // For edit mode initial load error
  const [actionError, setActionError] = useState<string | null>(null); // For summarize/save errors
  const [isLLMGenerated, setIsLLMGenerated] = useState(false); // Track if current summary was LLM generated
  const [isInitialLoading, setIsInitialLoading] = useState(mode === "edit"); // Loading state for initial fetch in edit mode

  const fileInputRef = useRef<HTMLInputElement>(null);

  // Fetch summary details in edit mode
  const fetchSummary = useCallback(async (id: string) => {
    setIsInitialLoading(true);
    setLoadError(null); // Clear previous load errors
    try {
      // Use the apiService to fetch data
      const data = await apiService.getSummaryDetails(id);
      setTranscription(data.transcription || "");
      setSummary(data.summary || "");
      setNotes(data.notes || ""); // Initialize with empty string if notes is null
      setFileName(data.file_name || data.title || `Podsumowanie ${id}`); // Display file name or title
      setIsLLMGenerated(data.llm_generated);
      setIsInitialLoading(false);
    } catch (err: any) {
      console.error("Failed to fetch summary details:", err);
      // Display inline load error for edit mode
      setLoadError(
        "Nie udało się załadować podsumowania do edycji. Spróbuj ponownie. Szczegóły: " + (err.message || "")
      );
      setIsInitialLoading(false);
    }
  }, []);

  // Effect to load data in edit mode
  useEffect(() => {
    if (mode === "edit" && summaryId) {
      fetchSummary(summaryId);
    } else if (mode === "create") {
      // Clear states for create mode
      setTranscription("");
      setSummary("");
      setNotes(""); // Clear notes to empty string for new entry
      setFileName(null);
      setIsLLMGenerated(false);
      setIsInitialLoading(false); // No initial loading in create mode
      setLoadError(null);
      setActionError(null);
      // Clear file input value as well
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    }
  }, [mode, summaryId, fetchSummary]); // Depend on mode, summaryId, and memoized fetchSummary

  // Clear action error when user starts typing in transcription or summary or notes
  const handleTranscriptionChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setTranscription(e.target.value);
    setActionError(null); // Clear error when transcription changes
    // Decide if manual edit means it's no longer LLM generated?
    // Let's keep isLLMGenerated based on whether 'Podsumuj' was the *last* action populating summary.
  };

  const handleSummaryChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setSummary(e.target.value);
    setActionError(null); // Clear error when summary changes
    setIsLLMGenerated(false); // If user manually edits summary, it's not purely LLM generated anymore
  };

  const handleNotesChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setNotes(e.target.value);
    setActionError(null); // Clear error when notes change
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    setActionError(null); // Clear action errors on new file upload

    if (file) {
      if (file.size > 1024 * 1024) {
        // 1MB limit
        toast({
          description: "Plik jest za duży (max 1 MB).",
          variant: "destructive",
        });
        // Reset file input value to allow selecting the same file again after error
        if (fileInputRef.current) {
          fileInputRef.current.value = "";
        }
        setFileName(null);
        setTranscription(""); // Clear transcription as file is invalid
        setSummary(""); // Clear summary as transcription changed/failed
        setNotes(""); // Clear notes
        setIsLLMGenerated(false);
        return;
      }

      setFileName(file.name);
      setTranscription(""); // Clear old transcription
      setSummary(""); // Clear summary when a new transcription is loaded
      setNotes(""); // Clear notes
      setIsLLMGenerated(false); // Clear LLM status

      const reader = new FileReader();
      reader.onload = (e) => {
        const text = e.target?.result as string;
        setTranscription(text);
        toast({
          description: `Plik "${file.name}" wczytany.`,
          // variant: "success" // Add success variant styling
        });
      };
      reader.onerror = () => {
        setActionError("Nie udało się odczytać pliku.");
        setFileName(null);
        setTranscription("");
        setSummary("");
        setNotes("");
        setIsLLMGenerated(false);
        toast({
          description: `Błąd odczytu pliku "${file?.name}".`,
          variant: "destructive",
        });
      };
      reader.readAsText(file);
    } else {
      // File input was cancelled or cleared
      setFileName(null);
      setTranscription("");
      setSummary("");
      setNotes("");
      setIsLLMGenerated(false);
      setActionError(null); // Clear error if file input is cancelled/cleared
    }
    // Reset file input value when done processing (success or error)
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  const handleSummarize = async () => {
    // Basic validation before calling API
    if (!transcription.trim() || isBusy) return; // Check if transcription is empty or only whitespace

    setIsSummarizing(true);
    setActionError(null); // Clear previous action errors

    try {
      // apiService is updated to handle/skip auth based on MVP rules
      const result = await apiService.generateSummary({ transcription });
      setSummary(result.summary);
      setIsLLMGenerated(true); // Mark as LLM generated
      toast({
        description: "Podsumowanie wygenerowane pomyślnie.",
        // variant: "success" // Requires success variant styling
      });
    } catch (err: any) {
      // Explicitly type as any if error object structure is unknown
      console.error("Summarize error:", err);
      setActionError(`Błąd generowania podsumowania: ${err.message || "Nieznany błąd"}`);
      setSummary(""); // Clear summary on error
      setIsLLMGenerated(false); // Ensure flag is false on error
    } finally {
      setIsSummarizing(false);
    }
  };

  const handleSave = async () => {
    // Basic validation before calling API
    if (!summary.trim() || isBusy) return; // Check if summary is empty or only whitespace

    setIsSaving(true);
    setActionError(null); // Clear previous action errors

    try {
      if (mode === "create") {
        const payload: CreateSummaryRequestDTO = {
          file_name: fileName, // Include file name from state
          transcription: transcription, // Required
          summary: summary, // Required
          llm_generated: isLLMGenerated, // Use tracked status
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to create summary
        await apiService.createSummary(payload); // POST /api/summaries
        toast({
          description: "Podsumowanie zapisane.",
          // variant: "success" // Requires success variant styling
        });
        window.location.href = "/summaries"; // Redirect after create save
      } else if (mode === "edit" && summaryId) {
        const payload: UpdateSummaryRequestDTO = {
          // file_name is not typically updated in edit mode based on plan display
          // If file_name should be updatable, add: file_name: fileName,
          transcription: transcription, // Include transcription for update
          summary: summary, // Include summary for update
          llm_generated: isLLMGenerated, // Include status in update
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to update summary
        await apiService.updateSummary(summaryId, payload); // PUT /api/summaries/{id}

        toast({
          description: "Zmiany zapisane.",
          // variant: "success" // Requires success variant styling
        });
        // No redirect after edit save as per plan (user can click cancel/nav)
        setIsSaving(false); // Reset saving state on success if not redirecting
      }
    } catch (err: any) {
      // Explicitly type as any if error object structure is unknown
      console.error("Save error:", err);
      // Display inline save error
      setActionError(`Błąd zapisu: ${err.message || "Nieznany błąd"}`);
      setIsSaving(false); // Reset saving state on error
    }
  };

  const handleCancel = () => {
    // Simple redirect, no confirmation needed as per plan
    window.location.href = "/summaries"; // Navigate back
  };

  // Determine if any major operation is in progress to disable controls
  const isBusy = isInitialLoading || isSummarizing || isSaving;
  // Determine if save button should be disabled (requires non-empty summary AND not busy)
  const isSaveDisabled = !summary.trim() || isBusy;
  // Determine if summarize button should be disabled (requires non-empty transcription AND not busy)
  const isSummarizeDisabled = !transcription.trim() || isBusy;

  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold">{mode === "create" ? "Nowe podsumowanie" : `Edytuj podsumowanie`}</h1>
      {/* Display title/file name in edit mode if available */}
      {mode === "edit" &&
        !isInitialLoading &&
        (fileName || summaryId) && ( // Only show if not initially loading
          // Added margin-bottom to separate from fields below
          <div className="text-lg font-semibold text-muted-foreground -mt-4 mb-4">{fileName || `ID: ${summaryId}`}</div>
        )}

      {/* Display initial load error in edit mode */}
      {loadError && mode === "edit" && <p className="text-sm font-medium text-red-500">{loadError}</p>}

      {/* Display spinner for initial load in edit mode */}
      {isInitialLoading ? (
        <div className="flex flex-col justify-center items-center h-64">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
          <span className="mt-2 text-muted-foreground">Ładowanie podsumowania...</span>
        </div>
      ) : (
        <>
          {/* File Upload Section (only in create mode) */}
          {mode === "create" && (
            // Added margin-bottom to separate from transcription field
            <div className="flex flex-col sm:flex-row items-start sm:items-center space-y-2 sm:space-y-0 sm:space-x-4 mb-4">
              <input
                id="file-upload"
                type="file"
                accept=".txt"
                ref={fileInputRef}
                onChange={handleFileChange}
                className="hidden" // Hide the default input
                disabled={isBusy} // Disable file input while busy
              />
              {/* Style label to look like a button */}
              <Label
                htmlFor="file-upload"
                className="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 h-10 px-4 py-2 bg-primary text-primary-foreground hover:bg-primary/90 cursor-pointer"
                data-disabled={isBusy} // Use data-disabled for styling based on isBusy
              >
                Wczytaj plik TXT (max 1 MB)
              </Label>
              {fileName && <span className="text-sm text-muted-foreground">{fileName}</span>}
            </div>
          )}

          <div>
            <Label htmlFor="transcription">Transkrypcja</Label>
            <Textarea
              id="transcription"
              value={transcription}
              onChange={handleTranscriptionChange} // Use refined handler
              placeholder="Wklej lub wczytaj tekst transkrypcji tutaj..."
              rows={10}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          <div>
            <Label htmlFor="summary">Podsumowanie</Label>
            <Textarea
              id="summary"
              value={summary}
              onChange={handleSummaryChange}
              placeholder="Wygeneruj lub wpisz podsumowanie tutaj..."
              rows={6}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Notes field - Add this field */}
          <div>
            <Label htmlFor="notes">Notatki (opcjonalnie)</Label>
            <Textarea
              id="notes"
              value={notes || ""} // Use empty string for controlled component if notes is null
              onChange={handleNotesChange}
              placeholder="Dodaj dodatkowe notatki..."
              rows={3}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Display action-specific errors (e.g., LLM error, save error) */}
          {actionError && (
            // Added margin-top and positioned above action buttons
            <p className="text-sm font-medium text-red-500 mt-4 text-center">{actionError}</p>
          )}

          {/* Action Buttons */}
          <div className="flex flex-col sm:flex-row justify-end gap-2 pt-4">
            <Button variant="outline" onClick={handleCancel} disabled={isBusy}>
              Anuluj
            </Button>
            <Button onClick={handleSummarize} disabled={isSummarizeDisabled}>
              {isSummarizing && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Podsumuj
            </Button>
            <Button onClick={handleSave} disabled={isSaveDisabled}>
              {isSaving && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Zapisz
            </Button>
          </div>

          {/* Footer displaying ID in edit mode */}
          {mode === "edit" &&
            summaryId &&
            !isInitialLoading && ( // Only show if in edit mode and not initially loading
              <div className="text-sm text-muted-foreground mt-4 border-t pt-4 text-center">
                {" "}
                {/* Added border and padding top */}
                ID Podsumowania: {summaryId}
              </div>
            )}
        </>
      )}
    </div>
  );
};

export default SummaryForm;



================================================
File: .history/src/components/views/SummaryForm_20250421135539.tsx
================================================
// src/components/views/SummaryForm.tsx
import * as React from "react";
import { useState, useRef, useEffect, useCallback } from "react";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea"; // Corrected the path to match the project structure
import { toast } from "sonner";
import { Loader2 } from "lucide-react";
import type { CreateSummaryRequestDTO, UpdateSummaryRequestDTO } from "@/types";
// import { supabase } from "@/auth"; // No longer needed directly for API calls needing auth token
import { apiService } from "@/lib/apiService"; // Import the apiService

interface SummaryFormProps {
  mode: "create" | "edit";
  summaryId?: string; // Required in 'edit' mode
}

const SummaryForm: React.FC<SummaryFormProps> = ({ mode, summaryId }) => {
  const [transcription, setTranscription] = useState("");
  const [summary, setSummary] = useState("");
  const [notes, setNotes] = useState<string | null>(""); // Initialize as empty string or null
  const [fileName, setFileName] = useState<string | null>(null); // For display in edit mode / payload in create
  const [isSummarizing, setIsSummarizing] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [loadError, setLoadError] = useState<string | null>(null); // For edit mode initial load error
  const [actionError, setActionError] = useState<string | null>(null); // For summarize/save errors
  const [isLLMGenerated, setIsLLMGenerated] = useState(false); // Track if current summary was LLM generated
  const [isInitialLoading, setIsInitialLoading] = useState(mode === "edit"); // Loading state for initial fetch in edit mode

  const fileInputRef = useRef<HTMLInputElement>(null);

  // Fetch summary details in edit mode
  const fetchSummary = useCallback(async (id: string) => {
    setIsInitialLoading(true);
    setLoadError(null); // Clear previous load errors
    try {
      // Use the apiService to fetch data
      const data = await apiService.getSummaryDetails(id);
      setTranscription(data.transcription || "");
      setSummary(data.summary || "");
      setNotes(data.notes || ""); // Initialize with empty string if notes is null
      setFileName(data.file_name || data.title || `Podsumowanie ${id}`); // Display file name or title
      setIsLLMGenerated(data.llm_generated);
      setIsInitialLoading(false);
    } catch (err: any) {
      console.error("Failed to fetch summary details:", err);
      // Display inline load error for edit mode
      setLoadError(
        "Nie udało się załadować podsumowania do edycji. Spróbuj ponownie. Szczegóły: " + (err.message || "")
      );
      setIsInitialLoading(false);
    }
  }, []);

  // Effect to load data in edit mode
  useEffect(() => {
    if (mode === "edit" && summaryId) {
      fetchSummary(summaryId);
    } else if (mode === "create") {
      // Clear states for create mode
      setTranscription("");
      setSummary("");
      setNotes(""); // Clear notes to empty string for new entry
      setFileName(null);
      setIsLLMGenerated(false);
      setIsInitialLoading(false); // No initial loading in create mode
      setLoadError(null);
      setActionError(null);
      // Clear file input value as well
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    }
  }, [mode, summaryId, fetchSummary]); // Depend on mode, summaryId, and memoized fetchSummary

  // Clear action error when user starts typing in transcription or summary or notes
  const handleTranscriptionChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setTranscription(e.target.value);
    setActionError(null); // Clear error when transcription changes
    // Decide if manual edit means it's no longer LLM generated?
    // Let's keep isLLMGenerated based on whether 'Podsumuj' was the *last* action populating summary.
  };

  const handleSummaryChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setSummary(e.target.value);
    setActionError(null); // Clear error when summary changes
    setIsLLMGenerated(false); // If user manually edits summary, it's not purely LLM generated anymore
  };

  const handleNotesChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setNotes(e.target.value);
    setActionError(null); // Clear error when notes change
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    setActionError(null); // Clear action errors on new file upload

    if (file) {
      if (file.size > 1024 * 1024) {
        // 1MB limit
        toast({
          description: "Plik jest za duży (max 1 MB).", // Changed to string
          variant: "destructive",
        });
        // Reset file input value to allow selecting the same file again after error
        if (fileInputRef.current) {
          fileInputRef.current.value = "";
        }
        setFileName(null);
        setTranscription(""); // Clear transcription as file is invalid
        setSummary(""); // Clear summary as transcription changed/failed
        setNotes(""); // Clear notes
        setIsLLMGenerated(false);
        return;
      }

      setFileName(file.name);
      setTranscription(""); // Clear old transcription
      setSummary(""); // Clear summary when a new transcription is loaded
      setNotes(""); // Clear notes
      setIsLLMGenerated(false); // Clear LLM status

      const reader = new FileReader();
      reader.onload = (e) => {
        const text = e.target?.result as string;
        setTranscription(text);
        toast({
          description: `Plik "${file.name}" wczytany.`, // Changed to string
          // variant: "success" // Add success variant styling
        });
      };
      reader.onerror = () => {
        setActionError("Nie udało się odczytać pliku.");
        setFileName(null);
        setTranscription("");
        setSummary("");
        setNotes("");
        setIsLLMGenerated(false);
        toast({
          description: `Błąd odczytu pliku "${file?.name}".`, // Changed to string
          variant: "destructive",
        });
      };
      reader.readAsText(file);
    } else {
      // File input was cancelled or cleared
      setFileName(null);
      setTranscription("");
      setSummary("");
      setNotes("");
      setIsLLMGenerated(false);
      setActionError(null); // Clear error if file input is cancelled/cleared
    }
    // Reset file input value when done processing (success or error)
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  const handleSummarize = async () => {
    // Basic validation before calling API
    if (!transcription.trim() || isBusy) return; // Check if transcription is empty or only whitespace

    setIsSummarizing(true);
    setActionError(null); // Clear previous action errors

    try {
      // apiService is updated to handle/skip auth based on MVP rules
      const result = await apiService.generateSummary({ transcription });
      setSummary(result.summary);
      setIsLLMGenerated(true); // Mark as LLM generated
      toast({
        description: "Podsumowanie wygenerowane pomyślnie.", // Changed to string
        // variant: "success" // Requires success variant styling
      });
    } catch (err: any) {
      // Explicitly type as any if error object structure is unknown
      console.error("Summarize error:", err);
      setActionError(`Błąd generowania podsumowania: ${err.message || "Nieznany błąd"}`);
      setSummary(""); // Clear summary on error
      setIsLLMGenerated(false); // Ensure flag is false on error
    } finally {
      setIsSummarizing(false);
    }
  };

  const handleSave = async () => {
    // Basic validation before calling API
    if (!summary.trim() || isBusy) return; // Check if summary is empty or only whitespace

    setIsSaving(true);
    setActionError(null); // Clear previous action errors

    try {
      if (mode === "create") {
        const payload: CreateSummaryRequestDTO = {
          file_name: fileName, // Include file name from state
          transcription: transcription, // Required
          summary: summary, // Required
          llm_generated: isLLMGenerated, // Use tracked status
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to create summary
        await apiService.createSummary(payload); // POST /api/summaries
        toast({
          description: "Podsumowanie zapisane.", // Changed to string
          // variant: "success" // Requires success variant styling
        });
        window.location.href = "/summaries"; // Redirect after create save
      } else if (mode === "edit" && summaryId) {
        const payload: UpdateSummaryRequestDTO = {
          // file_name is not typically updated in edit mode based on plan display
          // If file_name should be updatable, add: file_name: fileName,
          transcription: transcription, // Include transcription for update
          summary: summary, // Include summary for update
          llm_generated: isLLMGenerated, // Include status in update
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to update summary
        await apiService.updateSummary(summaryId, payload); // PUT /api/summaries/{id}

        toast({
          description: "Zmiany zapisane.", // Changed to string
          // variant: "success" // Requires success variant styling
        });
        // No redirect after edit save as per plan (user can click cancel/nav)
        setIsSaving(false); // Reset saving state on success if not redirecting
      }
    } catch (err: any) {
      // Explicitly type as any if error object structure is unknown
      console.error("Save error:", err);
      // Display inline save error
      setActionError(`Błąd zapisu: ${err.message || "Nieznany błąd"}`);
      setIsSaving(false); // Reset saving state on error
    }
  };

  const handleCancel = () => {
    // Simple redirect, no confirmation needed as per plan
    window.location.href = "/summaries"; // Navigate back
  };

  // Determine if any major operation is in progress to disable controls
  const isBusy = isInitialLoading || isSummarizing || isSaving;
  // Determine if save button should be disabled (requires non-empty summary AND not busy)
  const isSaveDisabled = !summary.trim() || isBusy;
  // Determine if summarize button should be disabled (requires non-empty transcription AND not busy)
  const isSummarizeDisabled = !transcription.trim() || isBusy;

  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold">{mode === "create" ? "Nowe podsumowanie" : `Edytuj podsumowanie`}</h1>
      {/* Display title/file name in edit mode if available */}
      {mode === "edit" &&
        !isInitialLoading &&
        (fileName || summaryId) && ( // Only show if not initially loading
          // Added margin-bottom to separate from fields below
          <div className="text-lg font-semibold text-muted-foreground -mt-4 mb-4">{fileName || `ID: ${summaryId}`}</div>
        )}

      {/* Display initial load error in edit mode */}
      {loadError && mode === "edit" && <p className="text-sm font-medium text-red-500">{loadError}</p>}

      {/* Display spinner for initial load in edit mode */}
      {isInitialLoading ? (
        <div className="flex flex-col justify-center items-center h-64">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
          <span className="mt-2 text-muted-foreground">Ładowanie podsumowania...</span>
        </div>
      ) : (
        <>
          {/* File Upload Section (only in create mode) */}
          {mode === "create" && (
            // Added margin-bottom to separate from transcription field
            <div className="flex flex-col sm:flex-row items-start sm:items-center space-y-2 sm:space-y-0 sm:space-x-4 mb-4">
              <input
                id="file-upload"
                type="file"
                accept=".txt"
                ref={fileInputRef}
                onChange={handleFileChange}
                className="hidden" // Hide the default input
                disabled={isBusy} // Disable file input while busy
              />
              {/* Style label to look like a button */}
              <Label
                htmlFor="file-upload"
                className="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 h-10 px-4 py-2 bg-primary text-primary-foreground hover:bg-primary/90 cursor-pointer"
                data-disabled={isBusy} // Use data-disabled for styling based on isBusy
              >
                Wczytaj plik TXT (max 1 MB)
              </Label>
              {fileName && <span className="text-sm text-muted-foreground">{fileName}</span>}
            </div>
          )}

          <div>
            <Label htmlFor="transcription">Transkrypcja</Label>
            <Textarea
              id="transcription"
              value={transcription}
              onChange={handleTranscriptionChange} // Use refined handler
              placeholder="Wklej lub wczytaj tekst transkrypcji tutaj..."
              rows={10}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          <div>
            <Label htmlFor="summary">Podsumowanie</Label>
            <Textarea
              id="summary"
              value={summary}
              onChange={handleSummaryChange}
              placeholder="Wygeneruj lub wpisz podsumowanie tutaj..."
              rows={6}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Notes field - Add this field */}
          <div>
            <Label htmlFor="notes">Notatki (opcjonalnie)</Label>
            <Textarea
              id="notes"
              value={notes || ""} // Use empty string for controlled component if notes is null
              onChange={handleNotesChange}
              placeholder="Dodaj dodatkowe notatki..."
              rows={3}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Display action-specific errors (e.g., LLM error, save error) */}
          {actionError && (
            // Added margin-top and positioned above action buttons
            <p className="text-sm font-medium text-red-500 mt-4 text-center">{actionError}</p>
          )}

          {/* Action Buttons */}
          <div className="flex flex-col sm:flex-row justify-end gap-2 pt-4">
            <Button variant="outline" onClick={handleCancel} disabled={isBusy}>
              Anuluj
            </Button>
            <Button onClick={handleSummarize} disabled={isSummarizeDisabled}>
              {isSummarizing && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Podsumuj
            </Button>
            <Button onClick={handleSave} disabled={isSaveDisabled}>
              {isSaving && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Zapisz
            </Button>
          </div>

          {/* Footer displaying ID in edit mode */}
          {mode === "edit" &&
            summaryId &&
            !isInitialLoading && ( // Only show if in edit mode and not initially loading
              <div className="text-sm text-muted-foreground mt-4 border-t pt-4 text-center">
                {" "}
                {/* Added border and padding top */}
                ID Podsumowania: {summaryId}
              </div>
            )}
        </>
      )}
    </div>
  );
};

export default SummaryForm;



================================================
File: .history/src/components/views/SummaryForm_20250421135541.tsx
================================================
// src/components/views/SummaryForm.tsx
import * as React from "react";
import { useState, useRef, useEffect, useCallback } from "react";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea"; // Corrected the path to match the project structure
import { toast } from "sonner";
import { Loader2 } from "lucide-react";
import type { CreateSummaryRequestDTO, UpdateSummaryRequestDTO } from "@/types";
// import { supabase } from "@/auth"; // No longer needed directly for API calls needing auth token
import { apiService } from "@/lib/apiService"; // Import the apiService

interface SummaryFormProps {
  mode: "create" | "edit";
  summaryId?: string; // Required in 'edit' mode
}

const SummaryForm: React.FC<SummaryFormProps> = ({ mode, summaryId }) => {
  const [transcription, setTranscription] = useState("");
  const [summary, setSummary] = useState("");
  const [notes, setNotes] = useState<string | null>(""); // Initialize as empty string or null
  const [fileName, setFileName] = useState<string | null>(null); // For display in edit mode / payload in create
  const [isSummarizing, setIsSummarizing] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [loadError, setLoadError] = useState<string | null>(null); // For edit mode initial load error
  const [actionError, setActionError] = useState<string | null>(null); // For summarize/save errors
  const [isLLMGenerated, setIsLLMGenerated] = useState(false); // Track if current summary was LLM generated
  const [isInitialLoading, setIsInitialLoading] = useState(mode === "edit"); // Loading state for initial fetch in edit mode

  const fileInputRef = useRef<HTMLInputElement>(null);

  // Fetch summary details in edit mode
  const fetchSummary = useCallback(async (id: string) => {
    setIsInitialLoading(true);
    setLoadError(null); // Clear previous load errors
    try {
      // Use the apiService to fetch data
      const data = await apiService.getSummaryDetails(id);
      setTranscription(data.transcription || "");
      setSummary(data.summary || "");
      setNotes(data.notes || ""); // Initialize with empty string if notes is null
      setFileName(data.file_name || data.title || `Podsumowanie ${id}`); // Display file name or title
      setIsLLMGenerated(data.llm_generated);
      setIsInitialLoading(false);
    } catch (err: any) {
      console.error("Failed to fetch summary details:", err);
      // Display inline load error for edit mode
      setLoadError(
        "Nie udało się załadować podsumowania do edycji. Spróbuj ponownie. Szczegóły: " + (err.message || "")
      );
      setIsInitialLoading(false);
    }
  }, []);

  // Effect to load data in edit mode
  useEffect(() => {
    if (mode === "edit" && summaryId) {
      fetchSummary(summaryId);
    } else if (mode === "create") {
      // Clear states for create mode
      setTranscription("");
      setSummary("");
      setNotes(""); // Clear notes to empty string for new entry
      setFileName(null);
      setIsLLMGenerated(false);
      setIsInitialLoading(false); // No initial loading in create mode
      setLoadError(null);
      setActionError(null);
      // Clear file input value as well
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    }
  }, [mode, summaryId, fetchSummary]); // Depend on mode, summaryId, and memoized fetchSummary

  // Clear action error when user starts typing in transcription or summary or notes
  const handleTranscriptionChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setTranscription(e.target.value);
    setActionError(null); // Clear error when transcription changes
    // Decide if manual edit means it's no longer LLM generated?
    // Let's keep isLLMGenerated based on whether 'Podsumuj' was the *last* action populating summary.
  };

  const handleSummaryChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setSummary(e.target.value);
    setActionError(null); // Clear error when summary changes
    setIsLLMGenerated(false); // If user manually edits summary, it's not purely LLM generated anymore
  };

  const handleNotesChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setNotes(e.target.value);
    setActionError(null); // Clear error when notes change
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    setActionError(null); // Clear action errors on new file upload

    if (file) {
      if (file.size > 1024 * 1024) {
        // 1MB limit
        toast({
          description: "Plik jest za duży (max 1 MB).", // Changed to string
          variant: "destructive",
        });
        // Reset file input value to allow selecting the same file again after error
        if (fileInputRef.current) {
          fileInputRef.current.value = "";
        }
        setFileName(null);
        setTranscription(""); // Clear transcription as file is invalid
        setSummary(""); // Clear summary as transcription changed/failed
        setNotes(""); // Clear notes
        setIsLLMGenerated(false);
        return;
      }

      setFileName(file.name);
      setTranscription(""); // Clear old transcription
      setSummary(""); // Clear summary when a new transcription is loaded
      setNotes(""); // Clear notes
      setIsLLMGenerated(false); // Clear LLM status

      const reader = new FileReader();
      reader.onload = (e) => {
        const text = e.target?.result as string;
        setTranscription(text);
        toast({
          description: `Plik "${file.name}" wczytany.`, // Changed to string
          // variant: "success" // Add success variant styling
        });
      };
      reader.onerror = () => {
        setActionError("Nie udało się odczytać pliku.");
        setFileName(null);
        setTranscription("");
        setSummary("");
        setNotes("");
        setIsLLMGenerated(false);
        toast({
          description: `Błąd odczytu pliku "${file?.name}".`, // Changed to string
          variant: "destructive",
        });
      };
      reader.readAsText(file);
    } else {
      // File input was cancelled or cleared
      setFileName(null);
      setTranscription("");
      setSummary("");
      setNotes("");
      setIsLLMGenerated(false);
      setActionError(null); // Clear error if file input is cancelled/cleared
    }
    // Reset file input value when done processing (success or error)
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  const handleSummarize = async () => {
    // Basic validation before calling API
    if (!transcription.trim() || isBusy) return; // Check if transcription is empty or only whitespace

    setIsSummarizing(true);
    setActionError(null); // Clear previous action errors

    try {
      // apiService is updated to handle/skip auth based on MVP rules
      const result = await apiService.generateSummary({ transcription });
      setSummary(result.summary);
      setIsLLMGenerated(true); // Mark as LLM generated
      toast({
        description: "Podsumowanie wygenerowane pomyślnie.", // Changed to string
        // variant: "success" // Requires success variant styling
      });
    } catch (err: any) {
      // Explicitly type as any if error object structure is unknown
      console.error("Summarize error:", err);
      setActionError(`Błąd generowania podsumowania: ${err.message || "Nieznany błąd"}`);
      setSummary(""); // Clear summary on error
      setIsLLMGenerated(false); // Ensure flag is false on error
    } finally {
      setIsSummarizing(false);
    }
  };

  const handleSave = async () => {
    // Basic validation before calling API
    if (!summary.trim() || isBusy) return; // Check if summary is empty or only whitespace

    setIsSaving(true);
    setActionError(null); // Clear previous action errors

    try {
      if (mode === "create") {
        const payload: CreateSummaryRequestDTO = {
          file_name: fileName, // Include file name from state
          transcription: transcription, // Required
          summary: summary, // Required
          llm_generated: isLLMGenerated, // Use tracked status
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to create summary
        await apiService.createSummary(payload); // POST /api/summaries
        toast({
          description: "Podsumowanie zapisane.", // Changed to string
          // variant: "success" // Requires success variant styling
        });
        window.location.href = "/summaries"; // Redirect after create save
      } else if (mode === "edit" && summaryId) {
        const payload: UpdateSummaryRequestDTO = {
          // file_name is not typically updated in edit mode based on plan display
          // If file_name should be updatable, add: file_name: fileName,
          transcription: transcription, // Include transcription for update
          summary: summary, // Include summary for update
          llm_generated: isLLMGenerated, // Include status in update
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to update summary
        await apiService.updateSummary(summaryId, payload); // PUT /api/summaries/{id}

        toast({
          description: "Zmiany zapisane.", // Changed to string
          // variant: "success" // Requires success variant styling
        });
        // No redirect after edit save as per plan (user can click cancel/nav)
        setIsSaving(false); // Reset saving state on success if not redirecting
      }
    } catch (err: any) {
      // Explicitly type as any if error object structure is unknown
      console.error("Save error:", err);
      // Display inline save error
      setActionError(`Błąd zapisu: ${err.message || "Nieznany błąd"}`);
      setIsSaving(false); // Reset saving state on error
    }
  };

  const handleCancel = () => {
    // Simple redirect, no confirmation needed as per plan
    window.location.href = "/summaries"; // Navigate back
  };

  // Determine if any major operation is in progress to disable controls
  const isBusy = isInitialLoading || isSummarizing || isSaving;
  // Determine if save button should be disabled (requires non-empty summary AND not busy)
  const isSaveDisabled = !summary.trim() || isBusy;
  // Determine if summarize button should be disabled (requires non-empty transcription AND not busy)
  const isSummarizeDisabled = !transcription.trim() || isBusy;

  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold">{mode === "create" ? "Nowe podsumowanie" : `Edytuj podsumowanie`}</h1>
      {/* Display title/file name in edit mode if available */}
      {mode === "edit" &&
        !isInitialLoading &&
        (fileName || summaryId) && ( // Only show if not initially loading
          // Added margin-bottom to separate from fields below
          <div className="text-lg font-semibold text-muted-foreground -mt-4 mb-4">{fileName || `ID: ${summaryId}`}</div>
        )}

      {/* Display initial load error in edit mode */}
      {loadError && mode === "edit" && <p className="text-sm font-medium text-red-500">{loadError}</p>}

      {/* Display spinner for initial load in edit mode */}
      {isInitialLoading ? (
        <div className="flex flex-col justify-center items-center h-64">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
          <span className="mt-2 text-muted-foreground">Ładowanie podsumowania...</span>
        </div>
      ) : (
        <>
          {/* File Upload Section (only in create mode) */}
          {mode === "create" && (
            // Added margin-bottom to separate from transcription field
            <div className="flex flex-col sm:flex-row items-start sm:items-center space-y-2 sm:space-y-0 sm:space-x-4 mb-4">
              <input
                id="file-upload"
                type="file"
                accept=".txt"
                ref={fileInputRef}
                onChange={handleFileChange}
                className="hidden" // Hide the default input
                disabled={isBusy} // Disable file input while busy
              />
              {/* Style label to look like a button */}
              <Label
                htmlFor="file-upload"
                className="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 h-10 px-4 py-2 bg-primary text-primary-foreground hover:bg-primary/90 cursor-pointer"
                data-disabled={isBusy} // Use data-disabled for styling based on isBusy
              >
                Wczytaj plik TXT (max 1 MB)
              </Label>
              {fileName && <span className="text-sm text-muted-foreground">{fileName}</span>}
            </div>
          )}

          <div>
            <Label htmlFor="transcription">Transkrypcja</Label>
            <Textarea
              id="transcription"
              value={transcription}
              onChange={handleTranscriptionChange} // Use refined handler
              placeholder="Wklej lub wczytaj tekst transkrypcji tutaj..."
              rows={10}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          <div>
            <Label htmlFor="summary">Podsumowanie</Label>
            <Textarea
              id="summary"
              value={summary}
              onChange={handleSummaryChange}
              placeholder="Wygeneruj lub wpisz podsumowanie tutaj..."
              rows={6}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Notes field - Add this field */}
          <div>
            <Label htmlFor="notes">Notatki (opcjonalnie)</Label>
            <Textarea
              id="notes"
              value={notes || ""} // Use empty string for controlled component if notes is null
              onChange={handleNotesChange}
              placeholder="Dodaj dodatkowe notatki..."
              rows={3}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Display action-specific errors (e.g., LLM error, save error) */}
          {actionError && (
            // Added margin-top and positioned above action buttons
            <p className="text-sm font-medium text-red-500 mt-4 text-center">{actionError}</p>
          )}

          {/* Action Buttons */}
          <div className="flex flex-col sm:flex-row justify-end gap-2 pt-4">
            <Button variant="outline" onClick={handleCancel} disabled={isBusy}>
              Anuluj
            </Button>
            <Button onClick={handleSummarize} disabled={isSummarizeDisabled}>
              {isSummarizing && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Podsumuj
            </Button>
            <Button onClick={handleSave} disabled={isSaveDisabled}>
              {isSaving && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Zapisz
            </Button>
          </div>

          {/* Footer displaying ID in edit mode */}
          {mode === "edit" &&
            summaryId &&
            !isInitialLoading && ( // Only show if in edit mode and not initially loading
              <div className="text-sm text-muted-foreground mt-4 border-t pt-4 text-center">
                {" "}
                {/* Added border and padding top */}
                ID Podsumowania: {summaryId}
              </div>
            )}
        </>
      )}
    </div>
  );
};

export default SummaryForm;



================================================
File: .history/src/components/views/SummaryForm_20250421135542.tsx
================================================
// src/components/views/SummaryForm.tsx
import * as React from "react";
import { useState, useRef, useEffect, useCallback } from "react";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea"; // Corrected the path to match the project structure
import { toast } from "sonner";
import { Loader2 } from "lucide-react";
import type { CreateSummaryRequestDTO, UpdateSummaryRequestDTO } from "@/types";
// import { supabase } from "@/auth"; // No longer needed directly for API calls needing auth token
import { apiService } from "@/lib/apiService"; // Import the apiService

interface SummaryFormProps {
  mode: "create" | "edit";
  summaryId?: string; // Required in 'edit' mode
}

const SummaryForm: React.FC<SummaryFormProps> = ({ mode, summaryId }) => {
  const [transcription, setTranscription] = useState("");
  const [summary, setSummary] = useState("");
  const [notes, setNotes] = useState<string | null>(""); // Initialize as empty string or null
  const [fileName, setFileName] = useState<string | null>(null); // For display in edit mode / payload in create
  const [isSummarizing, setIsSummarizing] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [loadError, setLoadError] = useState<string | null>(null); // For edit mode initial load error
  const [actionError, setActionError] = useState<string | null>(null); // For summarize/save errors
  const [isLLMGenerated, setIsLLMGenerated] = useState(false); // Track if current summary was LLM generated
  const [isInitialLoading, setIsInitialLoading] = useState(mode === "edit"); // Loading state for initial fetch in edit mode

  const fileInputRef = useRef<HTMLInputElement>(null);

  // Fetch summary details in edit mode
  const fetchSummary = useCallback(async (id: string) => {
    setIsInitialLoading(true);
    setLoadError(null); // Clear previous load errors
    try {
      // Use the apiService to fetch data
      const data = await apiService.getSummaryDetails(id);
      setTranscription(data.transcription || "");
      setSummary(data.summary || "");
      setNotes(data.notes || ""); // Initialize with empty string if notes is null
      setFileName(data.file_name || data.title || `Podsumowanie ${id}`); // Display file name or title
      setIsLLMGenerated(data.llm_generated);
      setIsInitialLoading(false);
    } catch (err: any) {
      console.error("Failed to fetch summary details:", err);
      // Display inline load error for edit mode
      setLoadError(
        "Nie udało się załadować podsumowania do edycji. Spróbuj ponownie. Szczegóły: " + (err.message || "")
      );
      setIsInitialLoading(false);
    }
  }, []);

  // Effect to load data in edit mode
  useEffect(() => {
    if (mode === "edit" && summaryId) {
      fetchSummary(summaryId);
    } else if (mode === "create") {
      // Clear states for create mode
      setTranscription("");
      setSummary("");
      setNotes(""); // Clear notes to empty string for new entry
      setFileName(null);
      setIsLLMGenerated(false);
      setIsInitialLoading(false); // No initial loading in create mode
      setLoadError(null);
      setActionError(null);
      // Clear file input value as well
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    }
  }, [mode, summaryId, fetchSummary]); // Depend on mode, summaryId, and memoized fetchSummary

  // Clear action error when user starts typing in transcription or summary or notes
  const handleTranscriptionChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setTranscription(e.target.value);
    setActionError(null); // Clear error when transcription changes
    // Decide if manual edit means it's no longer LLM generated?
    // Let's keep isLLMGenerated based on whether 'Podsumuj' was the *last* action populating summary.
  };

  const handleSummaryChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setSummary(e.target.value);
    setActionError(null); // Clear error when summary changes
    setIsLLMGenerated(false); // If user manually edits summary, it's not purely LLM generated anymore
  };

  const handleNotesChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setNotes(e.target.value);
    setActionError(null); // Clear error when notes change
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    setActionError(null); // Clear action errors on new file upload

    if (file) {
      if (file.size > 1024 * 1024) {
        // 1MB limit
        toast({
          description: "Plik jest za duży (max 1 MB).", // Changed to string
          variant: "destructive",
        });
        // Reset file input value to allow selecting the same file again after error
        if (fileInputRef.current) {
          fileInputRef.current.value = "";
        }
        setFileName(null);
        setTranscription(""); // Clear transcription as file is invalid
        setSummary(""); // Clear summary as transcription changed/failed
        setNotes(""); // Clear notes
        setIsLLMGenerated(false);
        return;
      }

      setFileName(file.name);
      setTranscription(""); // Clear old transcription
      setSummary(""); // Clear summary when a new transcription is loaded
      setNotes(""); // Clear notes
      setIsLLMGenerated(false); // Clear LLM status

      const reader = new FileReader();
      reader.onload = (e) => {
        const text = e.target?.result as string;
        setTranscription(text);
        toast({
          description: `Plik "${file.name}" wczytany.`, // Changed to string
          // variant: "success" // Add success variant styling
        });
      };
      reader.onerror = () => {
        setActionError("Nie udało się odczytać pliku.");
        setFileName(null);
        setTranscription("");
        setSummary("");
        setNotes("");
        setIsLLMGenerated(false);
        toast({
          description: `Błąd odczytu pliku "${file?.name}".`, // Changed to string
          variant: "destructive",
        });
      };
      reader.readAsText(file);
    } else {
      // File input was cancelled or cleared
      setFileName(null);
      setTranscription("");
      setSummary("");
      setNotes("");
      setIsLLMGenerated(false);
      setActionError(null); // Clear error if file input is cancelled/cleared
    }
    // Reset file input value when done processing (success or error)
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  const handleSummarize = async () => {
    // Basic validation before calling API
    if (!transcription.trim() || isBusy) return; // Check if transcription is empty or only whitespace

    setIsSummarizing(true);
    setActionError(null); // Clear previous action errors

    try {
      // apiService is updated to handle/skip auth based on MVP rules
      const result = await apiService.generateSummary({ transcription });
      setSummary(result.summary);
      setIsLLMGenerated(true); // Mark as LLM generated
      toast({
        description: "Podsumowanie wygenerowane pomyślnie.", // Changed to string
        // variant: "success" // Requires success variant styling
      });
    } catch (err: any) {
      // Explicitly type as any if error object structure is unknown
      console.error("Summarize error:", err);
      setActionError(`Błąd generowania podsumowania: ${err.message || "Nieznany błąd"}`);
      setSummary(""); // Clear summary on error
      setIsLLMGenerated(false); // Ensure flag is false on error
    } finally {
      setIsSummarizing(false);
    }
  };

  const handleSave = async () => {
    // Basic validation before calling API
    if (!summary.trim() || isBusy) return; // Check if summary is empty or only whitespace

    setIsSaving(true);
    setActionError(null); // Clear previous action errors

    try {
      if (mode === "create") {
        const payload: CreateSummaryRequestDTO = {
          file_name: fileName, // Include file name from state
          transcription: transcription, // Required
          summary: summary, // Required
          llm_generated: isLLMGenerated, // Use tracked status
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to create summary
        await apiService.createSummary(payload); // POST /api/summaries
        toast({
          description: "Podsumowanie zapisane.", // Changed to string
          // variant: "success" // Requires success variant styling
        });
        window.location.href = "/summaries"; // Redirect after create save
      } else if (mode === "edit" && summaryId) {
        const payload: UpdateSummaryRequestDTO = {
          // file_name is not typically updated in edit mode based on plan display
          // If file_name should be updatable, add: file_name: fileName,
          transcription: transcription, // Include transcription for update
          summary: summary, // Include summary for update
          llm_generated: isLLMGenerated, // Include status in update
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to update summary
        await apiService.updateSummary(summaryId, payload); // PUT /api/summaries/{id}

        toast({
          description: "Zmiany zapisane.", // Changed to string
          // variant: "success" // Requires success variant styling
        });
        // No redirect after edit save as per plan (user can click cancel/nav)
        setIsSaving(false); // Reset saving state on success if not redirecting
      }
    } catch (err: any) {
      // Explicitly type as any if error object structure is unknown
      console.error("Save error:", err);
      // Display inline save error
      setActionError(`Błąd zapisu: ${err.message || "Nieznany błąd"}`);
      setIsSaving(false); // Reset saving state on error
    }
  };

  const handleCancel = () => {
    // Simple redirect, no confirmation needed as per plan
    window.location.href = "/summaries"; // Navigate back
  };

  // Determine if any major operation is in progress to disable controls
  const isBusy = isInitialLoading || isSummarizing || isSaving;
  // Determine if save button should be disabled (requires non-empty summary AND not busy)
  const isSaveDisabled = !summary.trim() || isBusy;
  // Determine if summarize button should be disabled (requires non-empty transcription AND not busy)
  const isSummarizeDisabled = !transcription.trim() || isBusy;

  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold">{mode === "create" ? "Nowe podsumowanie" : `Edytuj podsumowanie`}</h1>
      {/* Display title/file name in edit mode if available */}
      {mode === "edit" &&
        !isInitialLoading &&
        (fileName || summaryId) && ( // Only show if not initially loading
          // Added margin-bottom to separate from fields below
          <div className="text-lg font-semibold text-muted-foreground -mt-4 mb-4">{fileName || `ID: ${summaryId}`}</div>
        )}

      {/* Display initial load error in edit mode */}
      {loadError && mode === "edit" && <p className="text-sm font-medium text-red-500">{loadError}</p>}

      {/* Display spinner for initial load in edit mode */}
      {isInitialLoading ? (
        <div className="flex flex-col justify-center items-center h-64">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
          <span className="mt-2 text-muted-foreground">Ładowanie podsumowania...</span>
        </div>
      ) : (
        <>
          {/* File Upload Section (only in create mode) */}
          {mode === "create" && (
            // Added margin-bottom to separate from transcription field
            <div className="flex flex-col sm:flex-row items-start sm:items-center space-y-2 sm:space-y-0 sm:space-x-4 mb-4">
              <input
                id="file-upload"
                type="file"
                accept=".txt"
                ref={fileInputRef}
                onChange={handleFileChange}
                className="hidden" // Hide the default input
                disabled={isBusy} // Disable file input while busy
              />
              {/* Style label to look like a button */}
              <Label
                htmlFor="file-upload"
                className="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 h-10 px-4 py-2 bg-primary text-primary-foreground hover:bg-primary/90 cursor-pointer"
                data-disabled={isBusy} // Use data-disabled for styling based on isBusy
              >
                Wczytaj plik TXT (max 1 MB)
              </Label>
              {fileName && <span className="text-sm text-muted-foreground">{fileName}</span>}
            </div>
          )}

          <div>
            <Label htmlFor="transcription">Transkrypcja</Label>
            <Textarea
              id="transcription"
              value={transcription}
              onChange={handleTranscriptionChange} // Use refined handler
              placeholder="Wklej lub wczytaj tekst transkrypcji tutaj..."
              rows={10}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          <div>
            <Label htmlFor="summary">Podsumowanie</Label>
            <Textarea
              id="summary"
              value={summary}
              onChange={handleSummaryChange}
              placeholder="Wygeneruj lub wpisz podsumowanie tutaj..."
              rows={6}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Notes field - Add this field */}
          <div>
            <Label htmlFor="notes">Notatki (opcjonalnie)</Label>
            <Textarea
              id="notes"
              value={notes || ""} // Use empty string for controlled component if notes is null
              onChange={handleNotesChange}
              placeholder="Dodaj dodatkowe notatki..."
              rows={3}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Display action-specific errors (e.g., LLM error, save error) */}
          {actionError && (
            // Added margin-top and positioned above action buttons
            <p className="text-sm font-medium text-red-500 mt-4 text-center">{actionError}</p>
          )}

          {/* Action Buttons */}
          <div className="flex flex-col sm:flex-row justify-end gap-2 pt-4">
            <Button variant="outline" onClick={handleCancel} disabled={isBusy}>
              Anuluj
            </Button>
            <Button onClick={handleSummarize} disabled={isSummarizeDisabled}>
              {isSummarizing && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Podsumuj
            </Button>
            <Button onClick={handleSave} disabled={isSaveDisabled}>
              {isSaving && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Zapisz
            </Button>
          </div>

          {/* Footer displaying ID in edit mode */}
          {mode === "edit" &&
            summaryId &&
            !isInitialLoading && ( // Only show if in edit mode and not initially loading
              <div className="text-sm text-muted-foreground mt-4 border-t pt-4 text-center">
                {" "}
                {/* Added border and padding top */}
                ID Podsumowania: {summaryId}
              </div>
            )}
        </>
      )}
    </div>
  );
};

export default SummaryForm;



================================================
File: .history/src/components/views/SummaryForm_20250421135625.tsx
================================================
// src/components/views/SummaryForm.tsx
import * as React from "react";
import { useState, useRef, useEffect, useCallback } from "react";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea"; // Corrected the path to match the project structure
import { toast } from "sonner";
import { Loader2 } from "lucide-react";
import type { CreateSummaryRequestDTO, UpdateSummaryRequestDTO } from "@/types";
// import { supabase } from "@/auth"; // No longer needed directly for API calls needing auth token
import { apiService } from "@/lib/apiService"; // Import the apiService

interface SummaryFormProps {
  mode: "create" | "edit";
  summaryId?: string; // Required in 'edit' mode
}

const SummaryForm: React.FC<SummaryFormProps> = ({ mode, summaryId }) => {
  const [transcription, setTranscription] = useState("");
  const [summary, setSummary] = useState("");
  const [notes, setNotes] = useState<string | null>(""); // Initialize as empty string or null
  const [fileName, setFileName] = useState<string | null>(null); // For display in edit mode / payload in create
  const [isSummarizing, setIsSummarizing] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [loadError, setLoadError] = useState<string | null>(null); // For edit mode initial load error
  const [actionError, setActionError] = useState<string | null>(null); // For summarize/save errors
  const [isLLMGenerated, setIsLLMGenerated] = useState(false); // Track if current summary was LLM generated
  const [isInitialLoading, setIsInitialLoading] = useState(mode === "edit"); // Loading state for initial fetch in edit mode

  const fileInputRef = useRef<HTMLInputElement>(null);

  // Fetch summary details in edit mode
  const fetchSummary = useCallback(async (id: string) => {
    setIsInitialLoading(true);
    setLoadError(null); // Clear previous load errors
    try {
      // Use the apiService to fetch data
      const data = await apiService.getSummaryDetails(id);
      setTranscription(data.transcription || "");
      setSummary(data.summary || "");
      setNotes(data.notes || ""); // Initialize with empty string if notes is null
      setFileName(data.file_name || data.title || `Podsumowanie ${id}`); // Display file name or title
      setIsLLMGenerated(data.llm_generated);
      setIsInitialLoading(false);
    } catch (err: any) {
      console.error("Failed to fetch summary details:", err);
      // Display inline load error for edit mode
      setLoadError(
        "Nie udało się załadować podsumowania do edycji. Spróbuj ponownie. Szczegóły: " + (err.message || "")
      );
      setIsInitialLoading(false);
    }
  }, []);

  // Effect to load data in edit mode
  useEffect(() => {
    if (mode === "edit" && summaryId) {
      fetchSummary(summaryId);
    } else if (mode === "create") {
      // Clear states for create mode
      setTranscription("");
      setSummary("");
      setNotes(""); // Clear notes to empty string for new entry
      setFileName(null);
      setIsLLMGenerated(false);
      setIsInitialLoading(false); // No initial loading in create mode
      setLoadError(null);
      setActionError(null);
      // Clear file input value as well
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    }
  }, [mode, summaryId, fetchSummary]); // Depend on mode, summaryId, and memoized fetchSummary

  // Clear action error when user starts typing in transcription or summary or notes
  const handleTranscriptionChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setTranscription(e.target.value);
    setActionError(null); // Clear error when transcription changes
    // Decide if manual edit means it's no longer LLM generated?
    // Let's keep isLLMGenerated based on whether 'Podsumuj' was the *last* action populating summary.
  };

  const handleSummaryChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setSummary(e.target.value);
    setActionError(null); // Clear error when summary changes
    setIsLLMGenerated(false); // If user manually edits summary, it's not purely LLM generated anymore
  };

  const handleNotesChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setNotes(e.target.value);
    setActionError(null); // Clear error when notes change
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    setActionError(null); // Clear action errors on new file upload

    if (file) {
      if (file.size > 1024 * 1024) {
        // 1MB limit
        toast({
          description: "Plik jest za duży (max 1 MB).", // Changed to string
          variant: "destructive",
        });
        // Reset file input value to allow selecting the same file again after error
        if (fileInputRef.current) {
          fileInputRef.current.value = "";
        }
        setFileName(null);
        setTranscription(""); // Clear transcription as file is invalid
        setSummary(""); // Clear summary as transcription changed/failed
        setNotes(""); // Clear notes
        setIsLLMGenerated(false);
        return;
      }

      setFileName(file.name);
      setTranscription(""); // Clear old transcription
      setSummary(""); // Clear summary when a new transcription is loaded
      setNotes(""); // Clear notes
      setIsLLMGenerated(false); // Clear LLM status

      const reader = new FileReader();
      reader.onload = (e) => {
        const text = e.target?.result as string;
        setTranscription(text);
        toast({
          description: `Plik "${file.name}" wczytany.`, // Changed to string
          // variant: "success" // Add success variant styling
        });
      };
      reader.onerror = () => {
        setActionError("Nie udało się odczytać pliku.");
        setFileName(null);
        setTranscription("");
        setSummary("");
        setNotes("");
        setIsLLMGenerated(false);
        toast({
          description: `Błąd odczytu pliku "${file?.name}".`, // Changed to string
          variant: "destructive",
        });
      };
      reader.readAsText(file);
    } else {
      // File input was cancelled or cleared
      setFileName(null);
      setTranscription("");
      setSummary("");
      setNotes("");
      setIsLLMGenerated(false);
      setActionError(null); // Clear error if file input is cancelled/cleared
    }
    // Reset file input value when done processing (success or error)
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  const handleSummarize = async () => {
    // Basic validation before calling API
    if (!transcription.trim() || isBusy) return; // Check if transcription is empty or only whitespace

    setIsSummarizing(true);
    setActionError(null); // Clear previous action errors

    try {
      // apiService is updated to handle/skip auth based on MVP rules
      const result = await apiService.generateSummary({ transcription });
      setSummary(result.summary);
      setIsLLMGenerated(true); // Mark as LLM generated
      toast({
        description: "Podsumowanie wygenerowane pomyślnie.", // Changed to string
        // variant: "success" // Requires success variant styling
      });
    } catch (err: any) {
      // Explicitly type as any if error object structure is unknown
      console.error("Summarize error:", err);
      setActionError(`Błąd generowania podsumowania: ${err.message || "Nieznany błąd"}`);
      setSummary(""); // Clear summary on error
      setIsLLMGenerated(false); // Ensure flag is false on error
    } finally {
      setIsSummarizing(false);
    }
  };

  const handleSave = async () => {
    // Basic validation before calling API
    if (!summary.trim() || isBusy) return; // Check if summary is empty or only whitespace

    setIsSaving(true);
    setActionError(null); // Clear previous action errors

    try {
      if (mode === "create") {
        const payload: CreateSummaryRequestDTO = {
          file_name: fileName, // Include file name from state
          transcription: transcription, // Required
          summary: summary, // Required
          llm_generated: isLLMGenerated, // Use tracked status
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to create summary
        await apiService.createSummary(payload); // POST /api/summaries
        toast({
          description: "Podsumowanie zapisane.", // Changed to string
          // variant: "success" // Requires success variant styling
        });
        window.location.href = "/summaries"; // Redirect after create save
      } else if (mode === "edit" && summaryId) {
        const payload: UpdateSummaryRequestDTO = {
          // file_name is not typically updated in edit mode based on plan display
          // If file_name should be updatable, add: file_name: fileName,
          transcription: transcription, // Include transcription for update
          summary: summary, // Include summary for update
          llm_generated: isLLMGenerated, // Include status in update
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to update summary
        await apiService.updateSummary(summaryId, payload); // PUT /api/summaries/{id}

        toast({
          description: "Zmiany zapisane.", // Changed to string
          // variant: "success" // Requires success variant styling
        });
        // No redirect after edit save as per plan (user can click cancel/nav)
        setIsSaving(false); // Reset saving state on success if not redirecting
      }
    } catch (err: any) {
      // Explicitly type as any if error object structure is unknown
      console.error("Save error:", err);
      // Display inline save error
      setActionError(`Błąd zapisu: ${err.message || "Nieznany błąd"}`);
      setIsSaving(false); // Reset saving state on error
    }
  };

  const handleCancel = () => {
    // Simple redirect, no confirmation needed as per plan
    window.location.href = "/summaries"; // Navigate back
  };

  // Determine if any major operation is in progress to disable controls
  const isBusy = isInitialLoading || isSummarizing || isSaving;
  // Determine if save button should be disabled (requires non-empty summary AND not busy)
  const isSaveDisabled = !summary.trim() || isBusy;
  // Determine if summarize button should be disabled (requires non-empty transcription AND not busy)
  const isSummarizeDisabled = !transcription.trim() || isBusy;

  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold">{mode === "create" ? "Nowe podsumowanie" : `Edytuj podsumowanie`}</h1>
      {/* Display title/file name in edit mode if available */}
      {mode === "edit" &&
        !isInitialLoading &&
        (fileName || summaryId) && ( // Only show if not initially loading
          // Added margin-bottom to separate from fields below
          <div className="text-lg font-semibold text-muted-foreground -mt-4 mb-4">{fileName || `ID: ${summaryId}`}</div>
        )}

      {/* Display initial load error in edit mode */}
      {loadError && mode === "edit" && <p className="text-sm font-medium text-red-500">{loadError}</p>}

      {/* Display spinner for initial load in edit mode */}
      {isInitialLoading ? (
        <div className="flex flex-col justify-center items-center h-64">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
          <span className="mt-2 text-muted-foreground">Ładowanie podsumowania...</span>
        </div>
      ) : (
        <>
          {/* File Upload Section (only in create mode) */}
          {mode === "create" && (
            // Added margin-bottom to separate from transcription field
            <div className="flex flex-col sm:flex-row items-start sm:items-center space-y-2 sm:space-y-0 sm:space-x-4 mb-4">
              <input
                id="file-upload"
                type="file"
                accept=".txt"
                ref={fileInputRef}
                onChange={handleFileChange}
                className="hidden" // Hide the default input
                disabled={isBusy} // Disable file input while busy
              />
              {/* Style label to look like a button */}
              <Label
                htmlFor="file-upload"
                className="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 h-10 px-4 py-2 bg-primary text-primary-foreground hover:bg-primary/90 cursor-pointer"
                data-disabled={isBusy} // Use data-disabled for styling based on isBusy
              >
                Wczytaj plik TXT (max 1 MB)
              </Label>
              {fileName && <span className="text-sm text-muted-foreground">{fileName}</span>}
            </div>
          )}

          <div>
            <Label htmlFor="transcription">Transkrypcja</Label>
            <Textarea
              id="transcription"
              value={transcription}
              onChange={handleTranscriptionChange} // Use refined handler
              placeholder="Wklej lub wczytaj tekst transkrypcji tutaj..."
              rows={10}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          <div>
            <Label htmlFor="summary">Podsumowanie</Label>
            <Textarea
              id="summary"
              value={summary}
              onChange={handleSummaryChange}
              placeholder="Wygeneruj lub wpisz podsumowanie tutaj..."
              rows={6}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Notes field - Add this field */}
          <div>
            <Label htmlFor="notes">Notatki (opcjonalnie)</Label>
            <Textarea
              id="notes"
              value={notes || ""} // Use empty string for controlled component if notes is null
              onChange={handleNotesChange}
              placeholder="Dodaj dodatkowe notatki..."
              rows={3}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Display action-specific errors (e.g., LLM error, save error) */}
          {actionError && (
            // Added margin-top and positioned above action buttons
            <p className="text-sm font-medium text-red-500 mt-4 text-center">{actionError}</p>
          )}

          {/* Action Buttons */}
          <div className="flex flex-col sm:flex-row justify-end gap-2 pt-4">
            <Button variant="outline" onClick={handleCancel} disabled={isBusy}>
              Anuluj
            </Button>
            <Button onClick={handleSummarize} disabled={isSummarizeDisabled}>
              {isSummarizing && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Podsumuj
            </Button>
            <Button onClick={handleSave} disabled={isSaveDisabled}>
              {isSaving && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Zapisz
            </Button>
          </div>

          {/* Footer displaying ID in edit mode */}
          {mode === "edit" &&
            summaryId &&
            !isInitialLoading && ( // Only show if in edit mode and not initially loading
              <div className="text-sm text-muted-foreground mt-4 border-t pt-4 text-center">
                {" "}
                {/* Added border and padding top */}
                ID Podsumowania: {summaryId}
              </div>
            )}
        </>
      )}
    </div>
  );
};

export default SummaryForm;



================================================
File: .history/src/components/views/SummaryForm_20250421135627.tsx
================================================
// src/components/views/SummaryForm.tsx
import * as React from "react";
import { useState, useRef, useEffect, useCallback } from "react";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea"; // Corrected the path to match the project structure
import { toast } from "sonner";
import { Loader2 } from "lucide-react";
import type { CreateSummaryRequestDTO, UpdateSummaryRequestDTO } from "@/types";
// import { supabase } from "@/auth"; // No longer needed directly for API calls needing auth token
import { apiService } from "@/lib/apiService"; // Import the apiService

interface SummaryFormProps {
  mode: "create" | "edit";
  summaryId?: string; // Required in 'edit' mode
}

const SummaryForm: React.FC<SummaryFormProps> = ({ mode, summaryId }) => {
  const [transcription, setTranscription] = useState("");
  const [summary, setSummary] = useState("");
  const [notes, setNotes] = useState<string | null>(""); // Initialize as empty string or null
  const [fileName, setFileName] = useState<string | null>(null); // For display in edit mode / payload in create
  const [isSummarizing, setIsSummarizing] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [loadError, setLoadError] = useState<string | null>(null); // For edit mode initial load error
  const [actionError, setActionError] = useState<string | null>(null); // For summarize/save errors
  const [isLLMGenerated, setIsLLMGenerated] = useState(false); // Track if current summary was LLM generated
  const [isInitialLoading, setIsInitialLoading] = useState(mode === "edit"); // Loading state for initial fetch in edit mode

  const fileInputRef = useRef<HTMLInputElement>(null);

  // Fetch summary details in edit mode
  const fetchSummary = useCallback(async (id: string) => {
    setIsInitialLoading(true);
    setLoadError(null); // Clear previous load errors
    try {
      // Use the apiService to fetch data
      const data = await apiService.getSummaryDetails(id);
      setTranscription(data.transcription || "");
      setSummary(data.summary || "");
      setNotes(data.notes || ""); // Initialize with empty string if notes is null
      setFileName(data.file_name || data.title || `Podsumowanie ${id}`); // Display file name or title
      setIsLLMGenerated(data.llm_generated);
      setIsInitialLoading(false);
    } catch (err: any) {
      console.error("Failed to fetch summary details:", err);
      // Display inline load error for edit mode
      setLoadError(
        "Nie udało się załadować podsumowania do edycji. Spróbuj ponownie. Szczegóły: " + (err.message || "")
      );
      setIsInitialLoading(false);
    }
  }, []);

  // Effect to load data in edit mode
  useEffect(() => {
    if (mode === "edit" && summaryId) {
      fetchSummary(summaryId);
    } else if (mode === "create") {
      // Clear states for create mode
      setTranscription("");
      setSummary("");
      setNotes(""); // Clear notes to empty string for new entry
      setFileName(null);
      setIsLLMGenerated(false);
      setIsInitialLoading(false); // No initial loading in create mode
      setLoadError(null);
      setActionError(null);
      // Clear file input value as well
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    }
  }, [mode, summaryId, fetchSummary]); // Depend on mode, summaryId, and memoized fetchSummary

  // Clear action error when user starts typing in transcription or summary or notes
  const handleTranscriptionChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setTranscription(e.target.value);
    setActionError(null); // Clear error when transcription changes
    // Decide if manual edit means it's no longer LLM generated?
    // Let's keep isLLMGenerated based on whether 'Podsumuj' was the *last* action populating summary.
  };

  const handleSummaryChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setSummary(e.target.value);
    setActionError(null); // Clear error when summary changes
    setIsLLMGenerated(false); // If user manually edits summary, it's not purely LLM generated anymore
  };

  const handleNotesChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setNotes(e.target.value);
    setActionError(null); // Clear error when notes change
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    setActionError(null); // Clear action errors on new file upload

    if (file) {
      if (file.size > 1024 * 1024) {
        // 1MB limit
        toast({
          description: "Plik jest za duży (max 1 MB).", // Changed to string
          variant: "destructive",
        });
        // Reset file input value to allow selecting the same file again after error
        if (fileInputRef.current) {
          fileInputRef.current.value = "";
        }
        setFileName(null);
        setTranscription(""); // Clear transcription as file is invalid
        setSummary(""); // Clear summary as transcription changed/failed
        setNotes(""); // Clear notes
        setIsLLMGenerated(false);
        return;
      }

      setFileName(file.name);
      setTranscription(""); // Clear old transcription
      setSummary(""); // Clear summary when a new transcription is loaded
      setNotes(""); // Clear notes
      setIsLLMGenerated(false); // Clear LLM status

      const reader = new FileReader();
      reader.onload = (e) => {
        const text = e.target?.result as string;
        setTranscription(text);
        toast({
          description: `Plik "${file.name}" wczytany.`, // Changed to string
          // variant: "success" // Add success variant styling
        });
      };
      reader.onerror = () => {
        setActionError("Nie udało się odczytać pliku.");
        setFileName(null);
        setTranscription("");
        setSummary("");
        setNotes("");
        setIsLLMGenerated(false);
        toast({
          description: `Błąd odczytu pliku "${file?.name}".`, // Changed to string
          variant: "destructive",
        });
      };
      reader.readAsText(file);
    } else {
      // File input was cancelled or cleared
      setFileName(null);
      setTranscription("");
      setSummary("");
      setNotes("");
      setIsLLMGenerated(false);
      setActionError(null); // Clear error if file input is cancelled/cleared
    }
    // Reset file input value when done processing (success or error)
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  const handleSummarize = async () => {
    // Basic validation before calling API
    if (!transcription.trim() || isBusy) return; // Check if transcription is empty or only whitespace

    setIsSummarizing(true);
    setActionError(null); // Clear previous action errors

    try {
      // apiService is updated to handle/skip auth based on MVP rules
      const result = await apiService.generateSummary({ transcription });
      setSummary(result.summary);
      setIsLLMGenerated(true); // Mark as LLM generated
      toast({
        description: "Podsumowanie wygenerowane pomyślnie.", // Changed to string
        // variant: "success" // Requires success variant styling
      });
    } catch (err: any) {
      // Explicitly type as any if error object structure is unknown
      console.error("Summarize error:", err);
      setActionError(`Błąd generowania podsumowania: ${err.message || "Nieznany błąd"}`);
      setSummary(""); // Clear summary on error
      setIsLLMGenerated(false); // Ensure flag is false on error
    } finally {
      setIsSummarizing(false);
    }
  };

  const handleSave = async () => {
    // Basic validation before calling API
    if (!summary.trim() || isBusy) return; // Check if summary is empty or only whitespace

    setIsSaving(true);
    setActionError(null); // Clear previous action errors

    try {
      if (mode === "create") {
        const payload: CreateSummaryRequestDTO = {
          file_name: fileName, // Include file name from state
          transcription: transcription, // Required
          summary: summary, // Required
          llm_generated: isLLMGenerated, // Use tracked status
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to create summary
        await apiService.createSummary(payload); // POST /api/summaries
        toast({
          description: "Podsumowanie zapisane.", // Changed to string
          // variant: "success" // Requires success variant styling
        });
        window.location.href = "/summaries"; // Redirect after create save
      } else if (mode === "edit" && summaryId) {
        const payload: UpdateSummaryRequestDTO = {
          // file_name is not typically updated in edit mode based on plan display
          // If file_name should be updatable, add: file_name: fileName,
          transcription: transcription, // Include transcription for update
          summary: summary, // Include summary for update
          llm_generated: isLLMGenerated, // Include status in update
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to update summary
        await apiService.updateSummary(summaryId, payload); // PUT /api/summaries/{id}

        toast({
          description: "Zmiany zapisane.", // Changed to string
          // variant: "success" // Requires success variant styling
        });
        // No redirect after edit save as per plan (user can click cancel/nav)
        setIsSaving(false); // Reset saving state on success if not redirecting
      }
    } catch (err: any) {
      // Explicitly type as any if error object structure is unknown
      console.error("Save error:", err);
      // Display inline save error
      setActionError(`Błąd zapisu: ${err.message || "Nieznany błąd"}`);
      setIsSaving(false); // Reset saving state on error
    }
  };

  const handleCancel = () => {
    // Simple redirect, no confirmation needed as per plan
    window.location.href = "/summaries"; // Navigate back
  };

  // Determine if any major operation is in progress to disable controls
  const isBusy = isInitialLoading || isSummarizing || isSaving;
  // Determine if save button should be disabled (requires non-empty summary AND not busy)
  const isSaveDisabled = !summary.trim() || isBusy;
  // Determine if summarize button should be disabled (requires non-empty transcription AND not busy)
  const isSummarizeDisabled = !transcription.trim() || isBusy;

  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold">{mode === "create" ? "Nowe podsumowanie" : `Edytuj podsumowanie`}</h1>
      {/* Display title/file name in edit mode if available */}
      {mode === "edit" &&
        !isInitialLoading &&
        (fileName || summaryId) && ( // Only show if not initially loading
          // Added margin-bottom to separate from fields below
          <div className="text-lg font-semibold text-muted-foreground -mt-4 mb-4">{fileName || `ID: ${summaryId}`}</div>
        )}

      {/* Display initial load error in edit mode */}
      {loadError && mode === "edit" && <p className="text-sm font-medium text-red-500">{loadError}</p>}

      {/* Display spinner for initial load in edit mode */}
      {isInitialLoading ? (
        <div className="flex flex-col justify-center items-center h-64">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
          <span className="mt-2 text-muted-foreground">Ładowanie podsumowania...</span>
        </div>
      ) : (
        <>
          {/* File Upload Section (only in create mode) */}
          {mode === "create" && (
            // Added margin-bottom to separate from transcription field
            <div className="flex flex-col sm:flex-row items-start sm:items-center space-y-2 sm:space-y-0 sm:space-x-4 mb-4">
              <input
                id="file-upload"
                type="file"
                accept=".txt"
                ref={fileInputRef}
                onChange={handleFileChange}
                className="hidden" // Hide the default input
                disabled={isBusy} // Disable file input while busy
              />
              {/* Style label to look like a button */}
              <Label
                htmlFor="file-upload"
                className="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 h-10 px-4 py-2 bg-primary text-primary-foreground hover:bg-primary/90 cursor-pointer"
                data-disabled={isBusy} // Use data-disabled for styling based on isBusy
              >
                Wczytaj plik TXT (max 1 MB)
              </Label>
              {fileName && <span className="text-sm text-muted-foreground">{fileName}</span>}
            </div>
          )}

          <div>
            <Label htmlFor="transcription">Transkrypcja</Label>
            <Textarea
              id="transcription"
              value={transcription}
              onChange={handleTranscriptionChange} // Use refined handler
              placeholder="Wklej lub wczytaj tekst transkrypcji tutaj..."
              rows={10}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          <div>
            <Label htmlFor="summary">Podsumowanie</Label>
            <Textarea
              id="summary"
              value={summary}
              onChange={handleSummaryChange}
              placeholder="Wygeneruj lub wpisz podsumowanie tutaj..."
              rows={6}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Notes field - Add this field */}
          <div>
            <Label htmlFor="notes">Notatki (opcjonalnie)</Label>
            <Textarea
              id="notes"
              value={notes || ""} // Use empty string for controlled component if notes is null
              onChange={handleNotesChange}
              placeholder="Dodaj dodatkowe notatki..."
              rows={3}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Display action-specific errors (e.g., LLM error, save error) */}
          {actionError && (
            // Added margin-top and positioned above action buttons
            <p className="text-sm font-medium text-red-500 mt-4 text-center">{actionError}</p>
          )}

          {/* Action Buttons */}
          <div className="flex flex-col sm:flex-row justify-end gap-2 pt-4">
            <Button variant="outline" onClick={handleCancel} disabled={isBusy}>
              Anuluj
            </Button>
            <Button onClick={handleSummarize} disabled={isSummarizeDisabled}>
              {isSummarizing && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Podsumuj
            </Button>
            <Button onClick={handleSave} disabled={isSaveDisabled}>
              {isSaving && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Zapisz
            </Button>
          </div>

          {/* Footer displaying ID in edit mode */}
          {mode === "edit" &&
            summaryId &&
            !isInitialLoading && ( // Only show if in edit mode and not initially loading
              <div className="text-sm text-muted-foreground mt-4 border-t pt-4 text-center">
                {" "}
                {/* Added border and padding top */}
                ID Podsumowania: {summaryId}
              </div>
            )}
        </>
      )}
    </div>
  );
};

export default SummaryForm;



================================================
File: .history/src/components/views/SummaryForm_20250421135657.tsx
================================================
// src/components/views/SummaryForm.tsx
import * as React from "react";
import { useState, useRef, useEffect, useCallback } from "react";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea"; // Corrected the path to match the project structure
import { toast } from "sonner";
import { Loader2 } from "lucide-react";
import type { CreateSummaryRequestDTO, UpdateSummaryRequestDTO } from "@/types";
// import { supabase } from "@/auth"; // No longer needed directly for API calls needing auth token
import { apiService } from "@/lib/apiService"; // Import the apiService

interface SummaryFormProps {
  mode: "create" | "edit";
  summaryId?: string; // Required in 'edit' mode
}

const SummaryForm: React.FC<SummaryFormProps> = ({ mode, summaryId }) => {
  const [transcription, setTranscription] = useState("");
  const [summary, setSummary] = useState("");
  const [notes, setNotes] = useState<string | null>(""); // Initialize as empty string or null
  const [fileName, setFileName] = useState<string | null>(null); // For display in edit mode / payload in create
  const [isSummarizing, setIsSummarizing] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [loadError, setLoadError] = useState<string | null>(null); // For edit mode initial load error
  const [actionError, setActionError] = useState<string | null>(null); // For summarize/save errors
  const [isLLMGenerated, setIsLLMGenerated] = useState(false); // Track if current summary was LLM generated
  const [isInitialLoading, setIsInitialLoading] = useState(mode === "edit"); // Loading state for initial fetch in edit mode

  const fileInputRef = useRef<HTMLInputElement>(null);

  // Fetch summary details in edit mode
  const fetchSummary = useCallback(async (id: string) => {
    setIsInitialLoading(true);
    setLoadError(null); // Clear previous load errors
    try {
      // Use the apiService to fetch data
      const data = await apiService.getSummaryDetails(id);
      setTranscription(data.transcription || "");
      setSummary(data.summary || "");
      setNotes(data.notes || ""); // Initialize with empty string if notes is null
      setFileName(data.file_name || data.title || `Podsumowanie ${id}`); // Display file name or title
      setIsLLMGenerated(data.llm_generated);
      setIsInitialLoading(false);
    } catch (err: any) {
      console.error("Failed to fetch summary details:", err);
      // Display inline load error for edit mode
      setLoadError(
        "Nie udało się załadować podsumowania do edycji. Spróbuj ponownie. Szczegóły: " + (err.message || "")
      );
      setIsInitialLoading(false);
    }
  }, []);

  // Effect to load data in edit mode
  useEffect(() => {
    if (mode === "edit" && summaryId) {
      fetchSummary(summaryId);
    } else if (mode === "create") {
      // Clear states for create mode
      setTranscription("");
      setSummary("");
      setNotes(""); // Clear notes to empty string for new entry
      setFileName(null);
      setIsLLMGenerated(false);
      setIsInitialLoading(false); // No initial loading in create mode
      setLoadError(null);
      setActionError(null);
      // Clear file input value as well
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    }
  }, [mode, summaryId, fetchSummary]); // Depend on mode, summaryId, and memoized fetchSummary

  // Clear action error when user starts typing in transcription or summary or notes
  const handleTranscriptionChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setTranscription(e.target.value);
    setActionError(null); // Clear error when transcription changes
    // Decide if manual edit means it's no longer LLM generated?
    // Let's keep isLLMGenerated based on whether 'Podsumuj' was the *last* action populating summary.
  };

  const handleSummaryChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setSummary(e.target.value);
    setActionError(null); // Clear error when summary changes
    setIsLLMGenerated(false); // If user manually edits summary, it's not purely LLM generated anymore
  };

  const handleNotesChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setNotes(e.target.value);
    setActionError(null); // Clear error when notes change
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    setActionError(null); // Clear action errors on new file upload

    if (file) {
      if (file.size > 1024 * 1024) {
        // 1MB limit
        toast({
          description: "Plik jest za duży (max 1 MB).", // Changed to string
          variant: "destructive",
        });
        // Reset file input value to allow selecting the same file again after error
        if (fileInputRef.current) {
          fileInputRef.current.value = "";
        }
        setFileName(null);
        setTranscription(""); // Clear transcription as file is invalid
        setSummary(""); // Clear summary as transcription changed/failed
        setNotes(""); // Clear notes
        setIsLLMGenerated(false);
        return;
      }

      setFileName(file.name);
      setTranscription(""); // Clear old transcription
      setSummary(""); // Clear summary when a new transcription is loaded
      setNotes(""); // Clear notes
      setIsLLMGenerated(false); // Clear LLM status

      const reader = new FileReader();
      reader.onload = (e) => {
        const text = e.target?.result as string;
        setTranscription(text);
        toast({
          description: `Plik "${file.name}" wczytany.`, // Changed to string
          // variant: "success" // Add success variant styling
        });
      };
      reader.onerror = () => {
        setActionError("Nie udało się odczytać pliku.");
        setFileName(null);
        setTranscription("");
        setSummary("");
        setNotes("");
        setIsLLMGenerated(false);
        toast({
          description: `Błąd odczytu pliku "${file?.name}".`, // Changed to string
          variant: "destructive",
        });
      };
      reader.readAsText(file);
    } else {
      // File input was cancelled or cleared
      setFileName(null);
      setTranscription("");
      setSummary("");
      setNotes("");
      setIsLLMGenerated(false);
      setActionError(null); // Clear error if file input is cancelled/cleared
    }
    // Reset file input value when done processing (success or error)
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  const handleSummarize = async () => {
    // Basic validation before calling API
    if (!transcription.trim() || isBusy) return; // Check if transcription is empty or only whitespace

    setIsSummarizing(true);
    setActionError(null); // Clear previous action errors

    try {
      // apiService is updated to handle/skip auth based on MVP rules
      const result = await apiService.generateSummary({ transcription });
      setSummary(result.summary);
      setIsLLMGenerated(true); // Mark as LLM generated
      toast({
        description: "Podsumowanie wygenerowane pomyślnie.", // Changed to string
        // variant: "success" // Requires success variant styling
      });
    } catch (err: any) {
      // Explicitly type as any if error object structure is unknown
      console.error("Summarize error:", err);
      setActionError(`Błąd generowania podsumowania: ${err.message || "Nieznany błąd"}`);
      setSummary(""); // Clear summary on error
      setIsLLMGenerated(false); // Ensure flag is false on error
    } finally {
      setIsSummarizing(false);
    }
  };

  const handleSave = async () => {
    // Basic validation before calling API
    if (!summary.trim() || isBusy) return; // Check if summary is empty or only whitespace

    setIsSaving(true);
    setActionError(null); // Clear previous action errors

    try {
      if (mode === "create") {
        const payload: CreateSummaryRequestDTO = {
          file_name: fileName, // Include file name from state
          transcription: transcription, // Required
          summary: summary, // Required
          llm_generated: isLLMGenerated, // Use tracked status
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to create summary
        await apiService.createSummary(payload); // POST /api/summaries
        toast({
          description: "Podsumowanie zapisane.", // Changed to string
          // variant: "success" // Requires success variant styling
        });
        window.location.href = "/summaries"; // Redirect after create save
      } else if (mode === "edit" && summaryId) {
        const payload: UpdateSummaryRequestDTO = {
          // file_name is not typically updated in edit mode based on plan display
          // If file_name should be updatable, add: file_name: fileName,
          transcription: transcription, // Include transcription for update
          summary: summary, // Include summary for update
          llm_generated: isLLMGenerated, // Include status in update
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to update summary
        await apiService.updateSummary(summaryId, payload); // PUT /api/summaries/{id}

        toast({
          description: "Zmiany zapisane.", // Changed to string
          // variant: "success" // Requires success variant styling
        });
        // No redirect after edit save as per plan (user can click cancel/nav)
        setIsSaving(false); // Reset saving state on success if not redirecting
      }
    } catch (err: any) {
      // Explicitly type as any if error object structure is unknown
      console.error("Save error:", err);
      // Display inline save error
      setActionError(`Błąd zapisu: ${err.message || "Nieznany błąd"}`);
      setIsSaving(false); // Reset saving state on error
    }
  };

  const handleCancel = () => {
    // Simple redirect, no confirmation needed as per plan
    window.location.href = "/summaries"; // Navigate back
  };

  // Determine if any major operation is in progress to disable controls
  const isBusy = isInitialLoading || isSummarizing || isSaving;
  // Determine if save button should be disabled (requires non-empty summary AND not busy)
  const isSaveDisabled = !summary.trim() || isBusy;
  // Determine if summarize button should be disabled (requires non-empty transcription AND not busy)
  const isSummarizeDisabled = !transcription.trim() || isBusy;

  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold">{mode === "create" ? "Nowe podsumowanie" : `Edytuj podsumowanie`}</h1>
      {/* Display title/file name in edit mode if available */}
      {mode === "edit" &&
        !isInitialLoading &&
        (fileName || summaryId) && ( // Only show if not initially loading
          // Added margin-bottom to separate from fields below
          <div className="text-lg font-semibold text-muted-foreground -mt-4 mb-4">{fileName || `ID: ${summaryId}`}</div>
        )}

      {/* Display initial load error in edit mode */}
      {loadError && mode === "edit" && <p className="text-sm font-medium text-red-500">{loadError}</p>}

      {/* Display spinner for initial load in edit mode */}
      {isInitialLoading ? (
        <div className="flex flex-col justify-center items-center h-64">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
          <span className="mt-2 text-muted-foreground">Ładowanie podsumowania...</span>
        </div>
      ) : (
        <>
          {/* File Upload Section (only in create mode) */}
          {mode === "create" && (
            // Added margin-bottom to separate from transcription field
            <div className="flex flex-col sm:flex-row items-start sm:items-center space-y-2 sm:space-y-0 sm:space-x-4 mb-4">
              <input
                id="file-upload"
                type="file"
                accept=".txt"
                ref={fileInputRef}
                onChange={handleFileChange}
                className="hidden" // Hide the default input
                disabled={isBusy} // Disable file input while busy
              />
              {/* Style label to look like a button */}
              <Label
                htmlFor="file-upload"
                className="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 h-10 px-4 py-2 bg-primary text-primary-foreground hover:bg-primary/90 cursor-pointer"
                data-disabled={isBusy} // Use data-disabled for styling based on isBusy
              >
                Wczytaj plik TXT (max 1 MB)
              </Label>
              {fileName && <span className="text-sm text-muted-foreground">{fileName}</span>}
            </div>
          )}

          <div>
            <Label htmlFor="transcription">Transkrypcja</Label>
            <Textarea
              id="transcription"
              value={transcription}
              onChange={handleTranscriptionChange} // Use refined handler
              placeholder="Wklej lub wczytaj tekst transkrypcji tutaj..."
              rows={10}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          <div>
            <Label htmlFor="summary">Podsumowanie</Label>
            <Textarea
              id="summary"
              value={summary}
              onChange={handleSummaryChange}
              placeholder="Wygeneruj lub wpisz podsumowanie tutaj..."
              rows={6}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Notes field - Add this field */}
          <div>
            <Label htmlFor="notes">Notatki (opcjonalnie)</Label>
            <Textarea
              id="notes"
              value={notes || ""} // Use empty string for controlled component if notes is null
              onChange={handleNotesChange}
              placeholder="Dodaj dodatkowe notatki..."
              rows={3}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Display action-specific errors (e.g., LLM error, save error) */}
          {actionError && (
            // Added margin-top and positioned above action buttons
            <p className="text-sm font-medium text-red-500 mt-4 text-center">{actionError}</p>
          )}

          {/* Action Buttons */}
          <div className="flex flex-col sm:flex-row justify-end gap-2 pt-4">
            <Button variant="outline" onClick={handleCancel} disabled={isBusy}>
              Anuluj
            </Button>
            <Button onClick={handleSummarize} disabled={isSummarizeDisabled}>
              {isSummarizing && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Podsumuj
            </Button>
            <Button onClick={handleSave} disabled={isSaveDisabled}>
              {isSaving && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Zapisz
            </Button>
          </div>

          {/* Footer displaying ID in edit mode */}
          {mode === "edit" &&
            summaryId &&
            !isInitialLoading && ( // Only show if in edit mode and not initially loading
              <div className="text-sm text-muted-foreground mt-4 border-t pt-4 text-center">
                {" "}
                {/* Added border and padding top */}
                ID Podsumowania: {summaryId}
              </div>
            )}
        </>
      )}
    </div>
  );
};

export default SummaryForm;



================================================
File: .history/src/components/views/SummaryForm_20250421141210.tsx
================================================
// src/components/views/SummaryForm.tsx
import * as React from "react";
import { useState, useRef, useEffect, useCallback } from "react";
// Assuming '@/components/ui/label' and '@/components/ui/textarea' resolve correctly after checking filesystem and tsconfig.json
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea"; // Corrected the path to match the project structure
import { toast } from "sonner";
import { Loader2 } from "lucide-react";
import type { CreateSummaryRequestDTO, UpdateSummaryRequestDTO } from "@/types";
// import { supabase } from "@/auth"; // No longer needed directly for API calls needing auth token
import { apiService } from "@/lib/apiService"; // Import the apiService

interface SummaryFormProps {
  mode: "create" | "edit";
  summaryId?: string; // Required in 'edit' mode
}

const SummaryForm: React.FC<SummaryFormProps> = ({ mode, summaryId }) => {
  const [transcription, setTranscription] = useState("");
  const [summary, setSummary] = useState("");
  const [notes, setNotes] = useState<string | null>(""); // Initialize as empty string or null
  const [fileName, setFileName] = useState<string | null>(null); // For display in edit mode / payload in create
  const [isSummarizing, setIsSummarizing] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [loadError, setLoadError] = useState<string | null>(null); // For edit mode initial load error
  const [actionError, setActionError] = useState<string | null>(null); // For summarize/save errors
  const [isLLMGenerated, setIsLLMGenerated] = useState(false); // Track if current summary was LLM generated
  const [isInitialLoading, setIsInitialLoading] = useState(mode === "edit"); // Loading state for initial fetch in edit mode

  const fileInputRef = useRef<HTMLInputElement>(null);

  // Fetch summary details in edit mode
  const fetchSummary = useCallback(async (id: string) => {
    setIsInitialLoading(true);
    setLoadError(null); // Clear previous load errors
    try {
      // Use the apiService to fetch data
      const data = await apiService.getSummaryDetails(id);
      setTranscription(data.transcription || "");
      setSummary(data.summary || "");
      setNotes(data.notes || ""); // Initialize with empty string if notes is null
      setFileName(data.file_name || data.title || `Podsumowanie ${id}`); // Display file name or title
      setIsLLMGenerated(data.llm_generated);
      setIsInitialLoading(false);
    } catch (err: unknown) {
      // Changed err: any to err: unknown
      console.error("Failed to fetch summary details:", err);
      // Display inline load error for edit mode
      // Use type guard to safely access message property
      const errorMessage = err instanceof Error ? err.message : String(err);
      setLoadError("Nie udało się załadować podsumowania do edycji. Spróbuj ponownie. Szczegóły: " + errorMessage);
      setIsInitialLoading(false);
    }
  }, []);

  // Effect to load data in edit mode
  useEffect(() => {
    if (mode === "edit" && summaryId) {
      fetchSummary(summaryId);
    } else if (mode === "create") {
      // Clear states for create mode
      setTranscription("");
      setSummary("");
      setNotes(""); // Clear notes to empty string for new entry
      setFileName(null);
      setIsLLMGenerated(false);
      setIsInitialLoading(false); // No initial loading in create mode
      setLoadError(null);
      setActionError(null);
      // Clear file input value as well
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    }
  }, [mode, summaryId, fetchSummary]); // Depend on mode, summaryId, and memoized fetchSummary

  // Clear action error when user starts typing in transcription or summary or notes
  const handleTranscriptionChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setTranscription(e.target.value);
    setActionError(null); // Clear error when transcription changes
    // Decide if manual edit means it's no longer LLM generated?
    // Let's keep isLLMGenerated based on whether 'Podsumuj' was the *last* action populating summary.
  };

  const handleSummaryChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setSummary(e.target.value);
    setActionError(null); // Clear error when summary changes
    setIsLLMGenerated(false); // If user manually edits summary, it's not purely LLM generated anymore
  };

  const handleNotesChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setNotes(e.target.value);
    setActionError(null); // Clear error when notes change
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    setActionError(null); // Clear action errors on new file upload

    if (file) {
      if (file.size > 1024 * 1024) {
        // 1MB limit
        // Correct toast usage: message as first argument, options as second
        toast("Plik jest za duży (max 1 MB).", {
          variant: "destructive",
        });
        // Reset file input value to allow selecting the same file again after error
        if (fileInputRef.current) {
          fileInputRef.current.value = "";
        }
        setFileName(null);
        setTranscription(""); // Clear transcription as file is invalid
        setSummary(""); // Clear summary as transcription changed/failed
        setNotes(""); // Clear notes
        setIsLLMGenerated(false);
        return;
      }

      setFileName(file.name);
      setTranscription(""); // Clear old transcription
      setSummary(""); // Clear summary when a new transcription is loaded
      setNotes(""); // Clear notes
      setIsLLMGenerated(false); // Clear LLM status

      const reader = new FileReader();
      reader.onload = (e) => {
        const text = e.target?.result as string;
        setTranscription(text);
        // Correct toast usage
        toast(`Plik "${file.name}" wczytany.`);
      };
      reader.onerror = () => {
        setActionError("Nie udało się odczytać pliku.");
        setFileName(null);
        setTranscription("");
        setSummary("");
        setNotes("");
        setIsLLMGenerated(false);
        // Correct toast usage
        toast(`Błąd odczytu pliku "${file?.name}".`, {
          variant: "destructive",
        });
      };
      reader.readAsText(file);
    } else {
      // File input was cancelled or cleared
      setFileName(null);
      setTranscription("");
      setSummary("");
      setNotes("");
      setIsLLMGenerated(false);
      setActionError(null); // Clear error if file input is cancelled/cleared
    }
    // Reset file input value when done processing (success or error)
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  const handleSummarize = async () => {
    // Basic validation before calling API
    const isBusy = isInitialLoading || isSummarizing || isSaving; // Recalculate locally
    if (!transcription.trim() || isBusy) return; // Check if transcription is empty or only whitespace

    setIsSummarizing(true);
    setActionError(null); // Clear previous action errors

    try {
      // apiService is updated to handle/skip auth based on MVP rules
      const result = await apiService.generateSummary({ transcription });
      setSummary(result.summary);
      setIsLLMGenerated(true); // Mark as LLM generated
      // Correct toast usage
      toast("Podsumowanie wygenerowane pomyślnie.");
    } catch (err: unknown) {
      // Changed err: any to err: unknown
      // Explicitly type as any if error object structure is unknown
      console.error("Summarize error:", err);
      // Use type guard to safely access message property
      const errorMessage = err instanceof Error ? err.message : String(err);
      setActionError(`Błąd generowania podsumowania: ${errorMessage || "Nieznany błąd"}`);
      setSummary(""); // Clear summary on error
      setIsLLMGenerated(false); // Ensure flag is false on error
    } finally {
      setIsSummarizing(false);
    }
  };

  const handleSave = async () => {
    // Basic validation before calling API
    const isBusy = isInitialLoading || isSummarizing || isSaving; // Recalculate locally
    if (!summary.trim() || isBusy) return; // Check if summary is empty or only whitespace

    setIsSaving(true);
    setActionError(null); // Clear previous action errors

    try {
      if (mode === "create") {
        const payload: CreateSummaryRequestDTO = {
          file_name: fileName, // Include file name from state
          transcription: transcription, // Required
          summary: summary, // Required
          llm_generated: isLLMGenerated, // Use tracked status
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to create summary
        await apiService.createSummary(payload); // POST /api/summaries
        // Correct toast usage
        toast("Podsumowanie zapisane.");
        window.location.href = "/summaries"; // Redirect after create save
      } else if (mode === "edit" && summaryId) {
        const payload: UpdateSummaryRequestDTO = {
          // file_name is not typically updated in edit mode based on plan display
          // If file_name should be updatable, add: file_name: fileName,
          transcription: transcription, // Include transcription for update
          summary: summary, // Include summary for update
          llm_generated: isLLMGenerated, // Include status in update
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to update summary
        await apiService.updateSummary(summaryId, payload); // PUT /api/summaries/{id}

        // Correct toast usage
        toast("Zmiany zapisane.");
        // No redirect after edit save as per plan (user can click cancel/nav)
        setIsSaving(false); // Reset saving state on success if not redirecting
      }
    } catch (err: unknown) {
      // Changed err: any to err: unknown
      // Explicitly type as any if error object structure is unknown
      console.error("Save error:", err);
      // Display inline save error
      // Use type guard to safely access message property
      const errorMessage = err instanceof Error ? err.message : String(err);
      setActionError(`Błąd zapisu: ${errorMessage || "Nieznany błąd"}`);
      setIsSaving(false); // Reset saving state on error
    }
  };

  const handleCancel = () => {
    // Simple redirect, no confirmation needed as per plan
    window.location.href = "/summaries"; // Navigate back
  };

  // Determine if any major operation is in progress to disable controls
  const isBusy = isInitialLoading || isSummarizing || isSaving;
  // Determine if save button should be disabled (requires non-empty summary AND not busy)
  const isSaveDisabled = !summary.trim() || isBusy;
  // Determine if summarize button should be disabled (requires non-empty transcription AND not busy)
  const isSummarizeDisabled = !transcription.trim() || isBusy;

  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold">{mode === "create" ? "Nowe podsumowanie" : `Edytuj podsumowanie`}</h1>
      {/* Display title/file name in edit mode if available */}
      {mode === "edit" &&
        !isInitialLoading &&
        (fileName || summaryId) && ( // Only show if not initially loading
          // Added margin-bottom to separate from fields below
          <div className="text-lg font-semibold text-muted-foreground -mt-4 mb-4">{fileName || `ID: ${summaryId}`}</div>
        )}

      {/* Display initial load error in edit mode */}
      {loadError && mode === "edit" && <p className="text-sm font-medium text-red-500">{loadError}</p>}

      {/* Display spinner for initial load in edit mode */}
      {isInitialLoading ? (
        <div className="flex flex-col justify-center items-center h-64">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
          <span className="mt-2 text-muted-foreground">Ładowanie podsumowania...</span>
        </div>
      ) : (
        <>
          {/* File Upload Section (only in create mode) */}
          {mode === "create" && (
            // Added margin-bottom to separate from transcription field
            <div className="flex flex-col sm:flex-row items-start sm:items-center space-y-2 sm:space-y-0 sm:space-x-4 mb-4">
              <input
                id="file-upload"
                type="file"
                accept=".txt"
                ref={fileInputRef}
                onChange={handleFileChange}
                className="hidden" // Hide the default input
                disabled={isBusy} // Disable file input while busy
              />
              {/* Style label to look like a button */}
              <Label
                htmlFor="file-upload"
                className="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 h-10 px-4 py-2 bg-primary text-primary-foreground hover:bg-primary/90 cursor-pointer"
                data-disabled={isBusy} // Use data-disabled for styling based on isBusy
              >
                Wczytaj plik TXT (max 1 MB)
              </Label>
              {fileName && <span className="text-sm text-muted-foreground">{fileName}</span>}
            </div>
          )}

          <div>
            <Label htmlFor="transcription">Transkrypcja</Label>
            <Textarea
              id="transcription"
              value={transcription}
              onChange={handleTranscriptionChange} // Use refined handler
              placeholder="Wklej lub wczytaj tekst transkrypcji tutaj..."
              rows={10}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          <div>
            <Label htmlFor="summary">Podsumowanie</Label>
            <Textarea
              id="summary"
              value={summary}
              onChange={handleSummaryChange}
              placeholder="Wygeneruj lub wpisz podsumowanie tutaj..."
              rows={6}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Notes field - Add this field */}
          <div>
            <Label htmlFor="notes">Notatki (opcjonalnie)</Label>
            <Textarea
              id="notes"
              value={notes || ""} // Use empty string for controlled component if notes is null
              onChange={handleNotesChange}
              placeholder="Dodaj dodatkowe notatki..."
              rows={3}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Display action-specific errors (e.g., LLM error, save error) */}
          {actionError && (
            // Added margin-top and positioned above action buttons
            <p className="text-sm font-medium text-red-500 mt-4 text-center">{actionError}</p>
          )}

          {/* Action Buttons */}
          <div className="flex flex-col sm:flex-row justify-end gap-2 pt-4">
            <Button variant="outline" onClick={handleCancel} disabled={isBusy}>
              Anuluj
            </Button>
            <Button onClick={handleSummarize} disabled={isSummarizeDisabled}>
              {isSummarizing && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Podsumuj
            </Button>
            <Button onClick={handleSave} disabled={isSaveDisabled}>
              {isSaving && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Zapisz
            </Button>
          </div>

          {/* Footer displaying ID in edit mode */}
          {mode === "edit" &&
            summaryId &&
            !isInitialLoading && ( // Only show if in edit mode and not initially loading
              <div className="text-sm text-muted-foreground mt-4 border-t pt-4 text-center">
                {" "}
                {/* Added border and padding top */}
                ID Podsumowania: {summaryId}
              </div>
            )}
        </>
      )}
    </div>
  );
};

export default SummaryForm;



================================================
File: .history/src/components/views/SummaryForm_20250421141439.tsx
================================================
// src/components/views/SummaryForm.tsx
import * as React from "react";
import { useState, useRef, useEffect, useCallback } from "react";
// Assuming '@/components/ui/label' and '@/components/ui/textarea' resolve correctly after checking filesystem and tsconfig.json
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea"; // Corrected the path to match the project structure
import { toast } from "sonner";
import { Loader2 } from "lucide-react";
import type { CreateSummaryRequestDTO, UpdateSummaryRequestDTO } from "@/types";
// import { supabase } from "@/auth"; // No longer needed directly for API calls needing auth token
import { apiService } from "@/lib/apiService"; // Import the apiService

interface SummaryFormProps {
  mode: "create" | "edit";
  summaryId?: string; // Required in 'edit' mode
}

const SummaryForm: React.FC<SummaryFormProps> = ({ mode, summaryId }) => {
  const [transcription, setTranscription] = useState("");
  const [summary, setSummary] = useState("");
  const [notes, setNotes] = useState<string | null>(""); // Initialize as empty string or null
  const [fileName, setFileName] = useState<string | null>(null); // For display in edit mode / payload in create
  const [isSummarizing, setIsSummarizing] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [loadError, setLoadError] = useState<string | null>(null); // For edit mode initial load error
  const [actionError, setActionError] = useState<string | null>(null); // For summarize/save errors
  const [isLLMGenerated, setIsLLMGenerated] = useState(false); // Track if current summary was LLM generated
  const [isInitialLoading, setIsInitialLoading] = useState(mode === "edit"); // Loading state for initial fetch in edit mode

  const fileInputRef = useRef<HTMLInputElement>(null);

  // Fetch summary details in edit mode
  const fetchSummary = useCallback(async (id: string) => {
    setIsInitialLoading(true);
    setLoadError(null); // Clear previous load errors
    try {
      // Use the apiService to fetch data
      const data = await apiService.getSummaryDetails(id);
      setTranscription(data.transcription || "");
      setSummary(data.summary || "");
      setNotes(data.notes || ""); // Initialize with empty string if notes is null
      setFileName(data.file_name || data.title || `Podsumowanie ${id}`); // Display file name or title
      setIsLLMGenerated(data.llm_generated);
      setIsInitialLoading(false);
    } catch (err: unknown) {
      // Changed err: any to err: unknown
      console.error("Failed to fetch summary details:", err);
      // Display inline load error for edit mode
      // Use type guard to safely access message property
      const errorMessage = err instanceof Error ? err.message : String(err);
      setLoadError("Nie udało się załadować podsumowania do edycji. Spróbuj ponownie. Szczegóły: " + errorMessage);
      setIsInitialLoading(false);
    }
  }, []);

  // Effect to load data in edit mode
  useEffect(() => {
    if (mode === "edit" && summaryId) {
      fetchSummary(summaryId);
    } else if (mode === "create") {
      // Clear states for create mode
      setTranscription("");
      setSummary("");
      setNotes(""); // Clear notes to empty string for new entry
      setFileName(null);
      setIsLLMGenerated(false);
      setIsInitialLoading(false); // No initial loading in create mode
      setLoadError(null);
      setActionError(null);
      // Clear file input value as well
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    }
  }, [mode, summaryId, fetchSummary]); // Depend on mode, summaryId, and memoized fetchSummary

  // Clear action error when user starts typing in transcription or summary or notes
  const handleTranscriptionChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setTranscription(e.target.value);
    setActionError(null); // Clear error when transcription changes
    // Decide if manual edit means it's no longer LLM generated?
    // Let's keep isLLMGenerated based on whether 'Podsumuj' was the *last* action populating summary.
  };

  const handleSummaryChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setSummary(e.target.value);
    setActionError(null); // Clear error when summary changes
    setIsLLMGenerated(false); // If user manually edits summary, it's not purely LLM generated anymore
  };

  const handleNotesChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setNotes(e.target.value);
    setActionError(null); // Clear error when notes change
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    setActionError(null); // Clear action errors on new file upload

    if (file) {
      if (file.size > 1024 * 1024) {
        // 1MB limit
        // Correct toast usage: message as first argument, options as second
        toast("Plik jest za duży (max 1 MB).", {
          variant: "destructive",
        });
        // Reset file input value to allow selecting the same file again after error
        if (fileInputRef.current) {
          fileInputRef.current.value = "";
        }
        setFileName(null);
        setTranscription(""); // Clear transcription as file is invalid
        setSummary(""); // Clear summary as transcription changed/failed
        setNotes(""); // Clear notes
        setIsLLMGenerated(false);
        return;
      }

      setFileName(file.name);
      setTranscription(""); // Clear old transcription
      setSummary(""); // Clear summary when a new transcription is loaded
      setNotes(""); // Clear notes
      setIsLLMGenerated(false); // Clear LLM status

      const reader = new FileReader();
      reader.onload = (e) => {
        const text = e.target?.result as string;
        setTranscription(text);
        // Correct toast usage
        toast(`Plik "${file.name}" wczytany.`);
      };
      reader.onerror = () => {
        setActionError("Nie udało się odczytać pliku.");
        setFileName(null);
        setTranscription("");
        setSummary("");
        setNotes("");
        setIsLLMGenerated(false);
        // Correct toast usage
        toast(`Błąd odczytu pliku "${file?.name}".`, {
          variant: "destructive",
        });
      };
      reader.readAsText(file);
    } else {
      // File input was cancelled or cleared
      setFileName(null);
      setTranscription("");
      setSummary("");
      setNotes("");
      setIsLLMGenerated(false);
      setActionError(null); // Clear error if file input is cancelled/cleared
    }
    // Reset file input value when done processing (success or error)
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  const handleSummarize = async () => {
    // Basic validation before calling API
    const isBusy = isInitialLoading || isSummarizing || isSaving; // Recalculate locally
    if (!transcription.trim() || isBusy) return; // Check if transcription is empty or only whitespace

    setIsSummarizing(true);
    setActionError(null); // Clear previous action errors

    try {
      // apiService is updated to handle/skip auth based on MVP rules
      const result = await apiService.generateSummary({ transcription });
      setSummary(result.summary);
      setIsLLMGenerated(true); // Mark as LLM generated
      // Correct toast usage
      toast("Podsumowanie wygenerowane pomyślnie.");
    } catch (err: unknown) {
      // Changed err: any to err: unknown
      // Explicitly type as any if error object structure is unknown
      console.error("Summarize error:", err);
      // Use type guard to safely access message property
      const errorMessage = err instanceof Error ? err.message : String(err);
      setActionError(`Błąd generowania podsumowania: ${errorMessage || "Nieznany błąd"}`);
      setSummary(""); // Clear summary on error
      setIsLLMGenerated(false); // Ensure flag is false on error
    } finally {
      setIsSummarizing(false);
    }
  };

  const handleSave = async () => {
    // Basic validation before calling API
    const isBusy = isInitialLoading || isSummarizing || isSaving; // Recalculate locally
    if (!summary.trim() || isBusy) return; // Check if summary is empty or only whitespace

    setIsSaving(true);
    setActionError(null); // Clear previous action errors

    try {
      if (mode === "create") {
        const payload: CreateSummaryRequestDTO = {
          file_name: fileName, // Include file name from state
          transcription: transcription, // Required
          summary: summary, // Required
          llm_generated: isLLMGenerated, // Use tracked status
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to create summary
        await apiService.createSummary(payload); // POST /api/summaries
        // Correct toast usage
        toast("Podsumowanie zapisane.");
        window.location.href = "/summaries"; // Redirect after create save
      } else if (mode === "edit" && summaryId) {
        const payload: UpdateSummaryRequestDTO = {
          // file_name is not typically updated in edit mode based on plan display
          // If file_name should be updatable, add: file_name: fileName,
          transcription: transcription, // Include transcription for update
          summary: summary, // Include summary for update
          llm_generated: isLLMGenerated, // Include status in update
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to update summary
        await apiService.updateSummary(summaryId, payload); // PUT /api/summaries/{id}

        // Correct toast usage
        toast("Zmiany zapisane.");
        // No redirect after edit save as per plan (user can click cancel/nav)
        setIsSaving(false); // Reset saving state on success if not redirecting
      }
    } catch (err: unknown) {
      // Changed err: any to err: unknown
      // Explicitly type as any if error object structure is unknown
      console.error("Save error:", err);
      // Display inline save error
      // Use type guard to safely access message property
      const errorMessage = err instanceof Error ? err.message : String(err);
      setActionError(`Błąd zapisu: ${errorMessage || "Nieznany błąd"}`);
      setIsSaving(false); // Reset saving state on error
    }
  };

  const handleCancel = () => {
    // Simple redirect, no confirmation needed as per plan
    window.location.href = "/summaries"; // Navigate back
  };

  // Determine if any major operation is in progress to disable controls
  const isBusy = isInitialLoading || isSummarizing || isSaving;
  // Determine if save button should be disabled (requires non-empty summary AND not busy)
  const isSaveDisabled = !summary.trim() || isBusy;
  // Determine if summarize button should be disabled (requires non-empty transcription AND not busy)
  const isSummarizeDisabled = !transcription.trim() || isBusy;

  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold">{mode === "create" ? "Nowe podsumowanie" : `Edytuj podsumowanie`}</h1>
      {/* Display title/file name in edit mode if available */}
      {mode === "edit" &&
        !isInitialLoading &&
        (fileName || summaryId) && ( // Only show if not initially loading
          // Added margin-bottom to separate from fields below
          <div className="text-lg font-semibold text-muted-foreground -mt-4 mb-4">{fileName || `ID: ${summaryId}`}</div>
        )}

      {/* Display initial load error in edit mode */}
      {loadError && mode === "edit" && <p className="text-sm font-medium text-red-500">{loadError}</p>}

      {/* Display spinner for initial load in edit mode */}
      {isInitialLoading ? (
        <div className="flex flex-col justify-center items-center h-64">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
          <span className="mt-2 text-muted-foreground">Ładowanie podsumowania...</span>
        </div>
      ) : (
        <>
          {/* File Upload Section (only in create mode) */}
          {mode === "create" && (
            // Added margin-bottom to separate from transcription field
            <div className="flex flex-col sm:flex-row items-start sm:items-center space-y-2 sm:space-y-0 sm:space-x-4 mb-4">
              <input
                id="file-upload"
                type="file"
                accept=".txt"
                ref={fileInputRef}
                onChange={handleFileChange}
                className="hidden" // Hide the default input
                disabled={isBusy} // Disable file input while busy
              />
              {/* Style label to look like a button */}
              <Label
                htmlFor="file-upload"
                className="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 h-10 px-4 py-2 bg-primary text-primary-foreground hover:bg-primary/90 cursor-pointer"
                data-disabled={isBusy} // Use data-disabled for styling based on isBusy
              >
                Wczytaj plik TXT (max 1 MB)
              </Label>
              {fileName && <span className="text-sm text-muted-foreground">{fileName}</span>}
            </div>
          )}

          <div>
            <Label htmlFor="transcription">Transkrypcja</Label>
            <Textarea
              id="transcription"
              value={transcription}
              onChange={handleTranscriptionChange} // Use refined handler
              placeholder="Wklej lub wczytaj tekst transkrypcji tutaj..."
              rows={10}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          <div>
            <Label htmlFor="summary">Podsumowanie</Label>
            <Textarea
              id="summary"
              value={summary}
              onChange={handleSummaryChange}
              placeholder="Wygeneruj lub wpisz podsumowanie tutaj..."
              rows={6}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Notes field - Add this field */}
          <div>
            <Label htmlFor="notes">Notatki (opcjonalnie)</Label>
            <Textarea
              id="notes"
              value={notes || ""} // Use empty string for controlled component if notes is null
              onChange={handleNotesChange}
              placeholder="Dodaj dodatkowe notatki..."
              rows={3}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Display action-specific errors (e.g., LLM error, save error) */}
          {actionError && (
            // Added margin-top and positioned above action buttons
            <p className="text-sm font-medium text-red-500 mt-4 text-center">{actionError}</p>
          )}

          {/* Action Buttons */}
          <div className="flex flex-col sm:flex-row justify-end gap-2 pt-4">
            <Button variant="outline" onClick={handleCancel} disabled={isBusy}>
              Anuluj
            </Button>
            <Button onClick={handleSummarize} disabled={isSummarizeDisabled}>
              {isSummarizing && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Podsumuj
            </Button>
            <Button onClick={handleSave} disabled={isSaveDisabled}>
              {isSaving && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Zapisz
            </Button>
          </div>

          {/* Footer displaying ID in edit mode */}
          {mode === "edit" &&
            summaryId &&
            !isInitialLoading && ( // Only show if in edit mode and not initially loading
              <div className="text-sm text-muted-foreground mt-4 border-t pt-4 text-center">
                {" "}
                {/* Added border and padding top */}
                ID Podsumowania: {summaryId}
              </div>
            )}
        </>
      )}
    </div>
  );
};

export default SummaryForm;



================================================
File: .history/src/components/views/SummaryForm_20250421141507.tsx
================================================
// src/components/views/SummaryForm.tsx
import * as React from "react";
import { useState, useRef, useEffect, useCallback } from "react";
// Assuming '@/components/ui/label' and '@/components/ui/textarea' resolve correctly after checking filesystem and tsconfig.json
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea"; // Corrected the path to match the project structure
import { toast } from "sonner";
import { Loader2 } from "lucide-react";
import type { CreateSummaryRequestDTO, UpdateSummaryRequestDTO } from "@/types";
// import { supabase } from "@/auth"; // No longer needed directly for API calls needing auth token
import { apiService } from "@/lib/apiService"; // Import the apiService

interface SummaryFormProps {
  mode: "create" | "edit";
  summaryId?: string; // Required in 'edit' mode
}

const SummaryForm: React.FC<SummaryFormProps> = ({ mode, summaryId }) => {
  const [transcription, setTranscription] = useState("");
  const [summary, setSummary] = useState("");
  const [notes, setNotes] = useState<string | null>(""); // Initialize as empty string or null
  const [fileName, setFileName] = useState<string | null>(null); // For display in edit mode / payload in create
  const [isSummarizing, setIsSummarizing] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [loadError, setLoadError] = useState<string | null>(null); // For edit mode initial load error
  const [actionError, setActionError] = useState<string | null>(null); // For summarize/save errors
  const [isLLMGenerated, setIsLLMGenerated] = useState(false); // Track if current summary was LLM generated
  const [isInitialLoading, setIsInitialLoading] = useState(mode === "edit"); // Loading state for initial fetch in edit mode

  const fileInputRef = useRef<HTMLInputElement>(null);

  // Fetch summary details in edit mode
  const fetchSummary = useCallback(async (id: string) => {
    setIsInitialLoading(true);
    setLoadError(null); // Clear previous load errors
    try {
      // Use the apiService to fetch data
      const data = await apiService.getSummaryDetails(id);
      setTranscription(data.transcription || "");
      setSummary(data.summary || "");
      setNotes(data.notes || ""); // Initialize with empty string if notes is null
      setFileName(data.file_name || data.title || `Podsumowanie ${id}`); // Display file name or title
      setIsLLMGenerated(data.llm_generated);
      setIsInitialLoading(false);
    } catch (err: unknown) {
      // Changed err: any to err: unknown
      console.error("Failed to fetch summary details:", err);
      // Display inline load error for edit mode
      // Use type guard to safely access message property
      const errorMessage = err instanceof Error ? err.message : String(err);
      setLoadError("Nie udało się załadować podsumowania do edycji. Spróbuj ponownie. Szczegóły: " + errorMessage);
      setIsInitialLoading(false);
    }
  }, []);

  // Effect to load data in edit mode
  useEffect(() => {
    if (mode === "edit" && summaryId) {
      fetchSummary(summaryId);
    } else if (mode === "create") {
      // Clear states for create mode
      setTranscription("");
      setSummary("");
      setNotes(""); // Clear notes to empty string for new entry
      setFileName(null);
      setIsLLMGenerated(false);
      setIsInitialLoading(false); // No initial loading in create mode
      setLoadError(null);
      setActionError(null);
      // Clear file input value as well
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    }
  }, [mode, summaryId, fetchSummary]); // Depend on mode, summaryId, and memoized fetchSummary

  // Clear action error when user starts typing in transcription or summary or notes
  const handleTranscriptionChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setTranscription(e.target.value);
    setActionError(null); // Clear error when transcription changes
    // Decide if manual edit means it's no longer LLM generated?
    // Let's keep isLLMGenerated based on whether 'Podsumuj' was the *last* action populating summary.
  };

  const handleSummaryChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setSummary(e.target.value);
    setActionError(null); // Clear error when summary changes
    setIsLLMGenerated(false); // If user manually edits summary, it's not purely LLM generated anymore
  };

  const handleNotesChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setNotes(e.target.value);
    setActionError(null); // Clear error when notes change
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    setActionError(null); // Clear action errors on new file upload

    if (file) {
      if (file.size > 1024 * 1024) {
        // 1MB limit
        // Correct toast usage: message as first argument, options as second
        toast("Plik jest za duży (max 1 MB).", {
          variant: "destructive",
        });
        // Reset file input value to allow selecting the same file again after error
        if (fileInputRef.current) {
          fileInputRef.current.value = "";
        }
        setFileName(null);
        setTranscription(""); // Clear transcription as file is invalid
        setSummary(""); // Clear summary as transcription changed/failed
        setNotes(""); // Clear notes
        setIsLLMGenerated(false);
        return;
      }

      setFileName(file.name);
      setTranscription(""); // Clear old transcription
      setSummary(""); // Clear summary when a new transcription is loaded
      setNotes(""); // Clear notes
      setIsLLMGenerated(false); // Clear LLM status

      const reader = new FileReader();
      reader.onload = (e) => {
        const text = e.target?.result as string;
        setTranscription(text);
        // Correct toast usage
        toast(`Plik "${file.name}" wczytany.`);
      };
      reader.onerror = () => {
        setActionError("Nie udało się odczytać pliku.");
        setFileName(null);
        setTranscription("");
        setSummary("");
        setNotes("");
        setIsLLMGenerated(false);
        // Correct toast usage
        toast(`Błąd odczytu pliku "${file?.name}".`, {
          variant: "destructive",
        });
      };
      reader.readAsText(file);
    } else {
      // File input was cancelled or cleared
      setFileName(null);
      setTranscription("");
      setSummary("");
      setNotes("");
      setIsLLMGenerated(false);
      setActionError(null); // Clear error if file input is cancelled/cleared
    }
    // Reset file input value when done processing (success or error)
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  const handleSummarize = async () => {
    // Basic validation before calling API
    const isBusy = isInitialLoading || isSummarizing || isSaving; // Recalculate locally
    if (!transcription.trim() || isBusy) return; // Check if transcription is empty or only whitespace

    setIsSummarizing(true);
    setActionError(null); // Clear previous action errors

    try {
      // apiService is updated to handle/skip auth based on MVP rules
      const result = await apiService.generateSummary({ transcription });
      setSummary(result.summary);
      setIsLLMGenerated(true); // Mark as LLM generated
      // Correct toast usage
      toast("Podsumowanie wygenerowane pomyślnie.");
    } catch (err: unknown) {
      // Changed err: any to err: unknown
      // Explicitly type as any if error object structure is unknown
      console.error("Summarize error:", err);
      // Use type guard to safely access message property
      const errorMessage = err instanceof Error ? err.message : String(err);
      setActionError(`Błąd generowania podsumowania: ${errorMessage || "Nieznany błąd"}`);
      setSummary(""); // Clear summary on error
      setIsLLMGenerated(false); // Ensure flag is false on error
    } finally {
      setIsSummarizing(false);
    }
  };

  const handleSave = async () => {
    // Basic validation before calling API
    const isBusy = isInitialLoading || isSummarizing || isSaving; // Recalculate locally
    if (!summary.trim() || isBusy) return; // Check if summary is empty or only whitespace

    setIsSaving(true);
    setActionError(null); // Clear previous action errors

    try {
      if (mode === "create") {
        const payload: CreateSummaryRequestDTO = {
          file_name: fileName, // Include file name from state
          transcription: transcription, // Required
          summary: summary, // Required
          llm_generated: isLLMGenerated, // Use tracked status
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to create summary
        await apiService.createSummary(payload); // POST /api/summaries
        // Correct toast usage
        toast("Podsumowanie zapisane.");
        window.location.href = "/summaries"; // Redirect after create save
      } else if (mode === "edit" && summaryId) {
        const payload: UpdateSummaryRequestDTO = {
          // file_name is not typically updated in edit mode based on plan display
          // If file_name should be updatable, add: file_name: fileName,
          transcription: transcription, // Include transcription for update
          summary: summary, // Include summary for update
          llm_generated: isLLMGenerated, // Include status in update
          notes: notes === "" ? null : notes, // Include notes, ensure null if empty string
        };
        // Use apiService to update summary
        await apiService.updateSummary(summaryId, payload); // PUT /api/summaries/{id}

        // Correct toast usage
        toast("Zmiany zapisane.");
        // No redirect after edit save as per plan (user can click cancel/nav)
        setIsSaving(false); // Reset saving state on success if not redirecting
      }
    } catch (err: unknown) {
      // Changed err: any to err: unknown
      // Explicitly type as any if error object structure is unknown
      console.error("Save error:", err);
      // Display inline save error
      // Use type guard to safely access message property
      const errorMessage = err instanceof Error ? err.message : String(err);
      setActionError(`Błąd zapisu: ${errorMessage || "Nieznany błąd"}`);
      setIsSaving(false); // Reset saving state on error
    }
  };

  const handleCancel = () => {
    // Simple redirect, no confirmation needed as per plan
    window.location.href = "/summaries"; // Navigate back
  };

  // Determine if any major operation is in progress to disable controls
  const isBusy = isInitialLoading || isSummarizing || isSaving;
  // Determine if save button should be disabled (requires non-empty summary AND not busy)
  const isSaveDisabled = !summary.trim() || isBusy;
  // Determine if summarize button should be disabled (requires non-empty transcription AND not busy)
  const isSummarizeDisabled = !transcription.trim() || isBusy;

  return (
    <div className="space-y-6">
      <h1 className="text-2xl font-bold">{mode === "create" ? "Nowe podsumowanie" : `Edytuj podsumowanie`}</h1>
      {/* Display title/file name in edit mode if available */}
      {mode === "edit" &&
        !isInitialLoading &&
        (fileName || summaryId) && ( // Only show if not initially loading
          // Added margin-bottom to separate from fields below
          <div className="text-lg font-semibold text-muted-foreground -mt-4 mb-4">{fileName || `ID: ${summaryId}`}</div>
        )}

      {/* Display initial load error in edit mode */}
      {loadError && mode === "edit" && <p className="text-sm font-medium text-red-500">{loadError}</p>}

      {/* Display spinner for initial load in edit mode */}
      {isInitialLoading ? (
        <div className="flex flex-col justify-center items-center h-64">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
          <span className="mt-2 text-muted-foreground">Ładowanie podsumowania...</span>
        </div>
      ) : (
        <>
          {/* File Upload Section (only in create mode) */}
          {mode === "create" && (
            // Added margin-bottom to separate from transcription field
            <div className="flex flex-col sm:flex-row items-start sm:items-center space-y-2 sm:space-y-0 sm:space-x-4 mb-4">
              <input
                id="file-upload"
                type="file"
                accept=".txt"
                ref={fileInputRef}
                onChange={handleFileChange}
                className="hidden" // Hide the default input
                disabled={isBusy} // Disable file input while busy
              />
              {/* Style label to look like a button */}
              <Label
                htmlFor="file-upload"
                className="inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 h-10 px-4 py-2 bg-primary text-primary-foreground hover:bg-primary/90 cursor-pointer"
                data-disabled={isBusy} // Use data-disabled for styling based on isBusy
              >
                Wczytaj plik TXT (max 1 MB)
              </Label>
              {fileName && <span className="text-sm text-muted-foreground">{fileName}</span>}
            </div>
          )}

          <div>
            <Label htmlFor="transcription">Transkrypcja</Label>
            <Textarea
              id="transcription"
              value={transcription}
              onChange={handleTranscriptionChange} // Use refined handler
              placeholder="Wklej lub wczytaj tekst transkrypcji tutaj..."
              rows={10}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          <div>
            <Label htmlFor="summary">Podsumowanie</Label>
            <Textarea
              id="summary"
              value={summary}
              onChange={handleSummaryChange}
              placeholder="Wygeneruj lub wpisz podsumowanie tutaj..."
              rows={6}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Notes field - Add this field */}
          <div>
            <Label htmlFor="notes">Notatki (opcjonalnie)</Label>
            <Textarea
              id="notes"
              value={notes || ""} // Use empty string for controlled component if notes is null
              onChange={handleNotesChange}
              placeholder="Dodaj dodatkowe notatki..."
              rows={3}
              className="mt-1"
              disabled={isBusy}
            />
          </div>

          {/* Display action-specific errors (e.g., LLM error, save error) */}
          {actionError && (
            // Added margin-top and positioned above action buttons
            <p className="text-sm font-medium text-red-500 mt-4 text-center">{actionError}</p>
          )}

          {/* Action Buttons */}
          <div className="flex flex-col sm:flex-row justify-end gap-2 pt-4">
            <Button variant="outline" onClick={handleCancel} disabled={isBusy}>
              Anuluj
            </Button>
            <Button onClick={handleSummarize} disabled={isSummarizeDisabled}>
              {isSummarizing && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Podsumuj
            </Button>
            <Button onClick={handleSave} disabled={isSaveDisabled}>
              {isSaving && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Zapisz
            </Button>
          </div>

          {/* Footer displaying ID in edit mode */}
          {mode === "edit" &&
            summaryId &&
            !isInitialLoading && ( // Only show if in edit mode and not initially loading
              <div className="text-sm text-muted-foreground mt-4 border-t pt-4 text-center">
                {" "}
                {/* Added border and padding top */}
                ID Podsumowania: {summaryId}
              </div>
            )}
        </>
      )}
    </div>
  );
};

export default SummaryForm;



================================================
File: .history/src/components/views/SummaryList_20250421125923.tsx
================================================
// src/components/views/SummaryList.tsx
import * as React from "react";
import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Loader2, ArrowUpDown } from "lucide-react"; // Add ArrowUpDown for sort indicators
import type { MeetingSummaryListEntryDto, ListSummariesCommand } from "@/types";
import { format } from "date-fns";
import { pl } from "date-fns/locale";
import { supabase } from "@/auth"; // Import supabase client

// Placeholder API Client - Replace with actual fetch calls using JWT
const apiClient = {
  getSummaries: async (params: ListSummariesCommand, accessToken?: string): Promise<MeetingSummaryListEntryDto[]> => {
    // Build query string
    const queryParams = new URLSearchParams();
    if (params.from_dt) queryParams.append("from_dt", params.from_dt);
    if (params.to_dt) queryParams.append("to_dt", params.to_dt);
    queryParams.append("sort_by", params.sort_by);
    queryParams.append("sort_order", params.sort_order);

    const url = `/api/summaries?${queryParams.toString()}`;

    console.log(`Fetching: ${url}`);

    // --- Simulate Actual Fetch with Auth ---
    // In a real scenario, use fetch or axios here.
    // Pass the accessToken in the Authorization header.
    /*
    const response = await fetch(url, {
        headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Content-Type': 'application/json',
        },
    });

    if (!response.ok) {
        // Handle non-2xx responses, e.g., 401 Unauthorized, 500 Internal Server Error
        const errorBody = await response.json();
        throw new Error(errorBody.message || `API Error: ${response.status}`);
    }

    const data: MeetingSummaryListEntryDto[] = await response.json();
    return data;
    */

    // --- Mock Data (for development before API is ready) ---
    await new Promise((resolve) => setTimeout(resolve, 500)); // Simulate API call delay

    const mockData: MeetingSummaryListEntryDto[] = [
      {
        id: "1",
        title: "Spotkanie A",
        file_name: "meeting_a.txt",
        created_at: "2023-10-26T10:00:00Z",
        updated_at: "2023-10-26T10:30:00Z",
      },
      {
        id: "2",
        title: "Briefing zespołu",
        file_name: "briefing.txt",
        created_at: "2023-10-25T09:00:00Z",
        updated_at: "2023-10-25T09:15:00Z",
      },
      {
        id: "3",
        title: "Projekt X - Status",
        file_name: "project_x.txt",
        created_at: "2023-10-24T14:00:00Z",
        updated_at: "2023-10-24T14:00:00Z",
      },
      {
        id: "4",
        title: "Spotkanie B (bez pliku)",
        file_name: null,
        created_at: "2023-10-26T11:00:00Z",
        updated_at: "2023-10-26T11:15:00Z",
      }, // Example with null file_name
      {
        id: "5",
        title: "Dłuższy tytuł spotkania na testy",
        file_name: "long_name_file.txt",
        created_at: "2023-10-27T15:00:00Z",
        updated_at: "2023-10-27T15:00:00Z",
      },
    ];

    // Apply simulated filtering
    const filteredData = mockData.filter((summary) => {
      const createdAt = new Date(summary.created_at);
      const fromDate = params.from_dt ? new Date(params.from_dt) : null;
      const toDate = params.to_dt ? new Date(params.to_dt) : null;

      let passFilter = true;
      if (fromDate) {
        // Compare date parts only for filtering range
        // Set fromDate to start of day for comparison
        const startOfFromDay = new Date(fromDate);
        startOfFromDay.setHours(0, 0, 0, 0);
        passFilter = passFilter && createdAt.getTime() >= startOfFromDay.getTime();
      }
      if (toDate) {
        // Compare date parts only, include end date
        const endOfToDay = new Date(toDate);
        endOfToDay.setHours(23, 59, 59, 999);
        passFilter = passFilter && createdAt.getTime() <= endOfToDay.getTime();
      }
      return passFilter;
    });

    // Apply simulated sorting
    const sortedData = filteredData.sort((a, b) => {
      const key = params.sort_by === "created_at" ? "created_at" : "updated_at"; // Map API sort_by to DTO key
      const dateA = new Date(a[key as keyof MeetingSummaryListEntryDto] as string).getTime();
      const dateB = new Date(b[key as keyof MeetingSummaryListEntryDto] as string).getTime();

      if (dateA < dateB) return params.sort_order === "asc" ? -1 : 1;
      if (dateA > dateB) return params.sort_order === "asc" ? 1 : -1;
      return 0;
    });

    // Simulate API error for testing: uncomment the next lines to test error state
    // if (Math.random() > 0.8) {
    //    throw new Error("Symulowany błąd ładowania danych");
    // }

    return sortedData;
  },
};

const SummaryList: React.FC = () => {
  const [summaries, setSummaries] = useState<MeetingSummaryListEntryDto[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [filterFromDate, setFilterFromDate] = useState<string>(""); // YYYY-MM-DD format for input type="date"
  const [filterToDate, setFilterToDate] = useState<string>(""); // YYYY-MM-DD format for input type="date"
  const [sortColumn, setSortColumn] = useState<ListSummariesCommand["sort_by"]>("created_at");
  const [sortOrder, setSortOrder] = useState<ListSummariesCommand["sort_order"]>("desc");

  const fetchSummaries = async (params: ListSummariesCommand) => {
    setIsLoading(true);
    setError(null);
    try {
      // Get the current session to obtain the access token
      const {
        data: { session },
      } = await supabase.auth.getSession();
      const accessToken = session?.access_token;

      // In a real app, handle case where session/token is null (should be caught by layout/middleware,
      // but defensive coding is good). Could redirect to login or show error.
      if (!accessToken) {
        setError("Brak autoryzacji. Zaloguj się ponownie.");
        setIsLoading(false);
        return; // Stop fetching if no token
      }

      // Pass the token to the API client
      const data = await apiClient.getSummaries(params, accessToken); // Use apiClient
      setSummaries(data);
    } catch (err: any) {
      console.error("Failed to fetch summaries:", err);
      setError("Nie udało się załadować listy podsumowań. Spróbuj ponownie później. Szczegóły: " + (err.message || ""));
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    // Fetch data on mount and when filter/sort params change
    fetchSummaries({
      from_dt: filterFromDate,
      to_dt: filterToDate,
      sort_by: sortColumn,
      sort_order: sortOrder,
    });
  }, [filterFromDate, filterToDate, sortColumn, sortOrder]); // Dependencies

  // This button is technically redundant if useEffect handles state changes,
  // but it provides an explicit user action point.
  // If removing, rely solely on useEffect. Keeping for now as per plan.
  const handleFilterClick = () => {
    // Trigger fetch by changing state (or call fetchSummaries directly if useEffect wasn't used for this)
    // Because useEffect already depends on filterFromDate and filterToDate,
    // just changing the state is enough. No need to call fetchSummaries here.
    console.log("Filter button clicked (state change will trigger fetch)");
  };

  const handleSortChange = (column: "created_at" | "updated_at") => {
    if (sortColumn === column) {
      // Toggle order if clicking the same column
      setSortOrder(sortOrder === "asc" ? "desc" : "asc");
    } else {
      // Set new column and default to desc order (or asc, specify preference)
      setSortColumn(column);
      setSortOrder("desc");
    }
    // fetchSummaries will be called by useEffect due to sort state change
  };

  const handleEditClick = (id: string) => {
    // Redirect to the edit page
    window.location.href = `/edit/${id}`;
  };

  const handleCreateClick = () => {
    // Redirect to the create page
    window.location.href = "/create";
  };

  // Function to format date strings for display
  const formatDate = (dateString: string) => {
    if (!dateString) return "-";
    try {
      // Date-fns parseISO is good for ISO strings
      const date = new Date(dateString);

      if (isNaN(date.getTime())) {
        return "Niepoprawna data";
      }
      // Format as dd.MM.yyyy HH:mm
      return format(date, "dd.MM.yyyy HH:mm", { locale: pl });
    } catch (e) {
      console.error("Failed to format date:", dateString, e);
      return "Błąd formatowania daty";
    }
  };

  return (
    <div className="space-y-6">
      {/* Page Title and New Summary Button */}
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-bold">Moje podsumowania</h1>
        <Button onClick={handleCreateClick}>Nowe podsumowanie</Button>
      </div>

      {/* Filtering Section */}
      <div className="flex flex-col sm:flex-row items-start sm:items-end gap-4 p-4 border rounded-md bg-card">
        <div className="flex flex-col gap-2 w-full sm:w-auto">
          <Label htmlFor="filterFrom">Utworzone od:</Label>
          <Input
            id="filterFrom"
            type="date"
            value={filterFromDate}
            onChange={(e) => setFilterFromDate(e.target.value)}
          />
        </div>
        <div className="flex flex-col gap-2 w-full sm:w-auto">
          <Label htmlFor="filterTo">Utworzone do:</Label>
          <Input id="filterTo" type="date" value={filterToDate} onChange={(e) => setFilterToDate(e.target.value)} />
        </div>
        {/* Filter button - only necessary if filtering was explicitly triggered */}
        {/* <Button onClick={handleFilterClick}>Filtruj</Button> */}
      </div>

      {/* Error Display */}
      {error && <p className="text-sm font-medium text-red-500 mt-4">{error}</p>}

      {/* Summary Table */}
      <div className="border rounded-md overflow-hidden">
        {" "}
        {/* Added overflow-hidden */}
        <Table>
          <TableHeader className="bg-muted/50">
            {" "}
            {/* Optional: Style header */}
            <TableRow>
              <TableHead>Nazwa/Tytuł</TableHead> {/* Updated column name */}
              <TableHead
                className="cursor-pointer hover:text-primary min-w-[150px]" // Added min-width for date columns
                onClick={() => handleSortChange("created_at")}
              >
                <div className="flex items-center">
                  {" "}
                  {/* Flex for text and icon alignment */}
                  Data utworzenia
                  {sortColumn === "created_at" &&
                    (sortOrder === "asc" ? (
                      <ArrowUpDown className="ml-1 h-4 w-4 inline-block rotate-180" />
                    ) : (
                      <ArrowUpDown className="ml-1 h-4 w-4 inline-block" />
                    ))}
                  {sortColumn !== "created_at" && (
                    <ArrowUpDown className="ml-1 h-4 w-4 inline-block text-muted-foreground opacity-50" />
                  )}
                </div>
              </TableHead>
              <TableHead
                className="cursor-pointer hover:text-primary min-w-[150px]" // Added min-width
                onClick={() => handleSortChange("updated_at")}
              >
                <div className="flex items-center">
                  {" "}
                  {/* Flex for text and icon alignment */}
                  Data modyfikacji
                  {sortColumn === "updated_at" &&
                    (sortOrder === "asc" ? (
                      <ArrowUpDown className="ml-1 h-4 w-4 inline-block rotate-180" />
                    ) : (
                      <ArrowUpDown className="ml-1 h-4 w-4 inline-block" />
                    ))}
                  {sortColumn !== "updated_at" && (
                    <ArrowUpDown className="ml-1 h-4 w-4 inline-block text-muted-foreground opacity-50" />
                  )}
                </div>
              </TableHead>
              <TableHead className="text-right">Akcje</TableHead> {/* Align right */}
            </TableRow>
          </TableHeader>
          <TableBody>
            {isLoading ? (
              <TableRow>
                <TableCell colSpan={4} className="text-center py-8">
                  {" "}
                  {/* Increased padding */}
                  <Loader2 className="h-8 w-8 animate-spin mx-auto text-primary" />
                  <span className="mt-2 block">Ładowanie...</span>
                </TableCell>
              </TableRow>
            ) : summaries.length === 0 ? (
              <TableRow>
                <TableCell colSpan={4} className="text-center py-8 text-muted-foreground">
                  {" "}
                  {/* Increased padding, muted text */}
                  Brak podsumowań do wyświetlenia.
                </TableCell>
              </TableRow>
            ) : (
              summaries.map((summary) => (
                <TableRow key={summary.id}>
                  <TableCell className="font-medium">{summary.title || summary.file_name || "Bez nazwy"}</TableCell>{" "}
                  {/* Display title or file_name */}
                  <TableCell>{formatDate(summary.created_at)}</TableCell>
                  <TableCell>{formatDate(summary.updated_at)}</TableCell>
                  <TableCell className="text-right">
                    {" "}
                    {/* Align right */}
                    <Button variant="outline" size="sm" onClick={() => handleEditClick(summary.id)}>
                      Edytuj
                    </Button>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>
    </div>
  );
};

export default SummaryList;



================================================
File: .history/src/components/views/SummaryList_20250421134746.tsx
================================================
// src/components/views/SummaryList.tsx
import * as React from "react";
import { useState, useEffect, useCallback } from "react"; // Import useCallback
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Loader2, ArrowUpDown, Edit, Trash2 } from "lucide-react"; // Add Edit, Trash2 icons
import type { MeetingSummaryListEntryDto, ListSummariesCommand } from "@/types";
import { format } from "date-fns";
import { pl } from "date-fns/locale";
// import { supabase } from "@/auth"; // No longer needed directly for API calls needing auth token
import { apiService } from "@/lib/apiService"; // Import the apiService
import { toast } from "sonner"; // Import toast

// Import date-fns parseISO for parsing date strings from state
import { parseISO } from "date-fns";

const SummaryList: React.FC = () => {
  const [summaries, setSummaries] = useState<MeetingSummaryListEntryDto[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [filterFromDate, setFilterFromDate] = useState<string>(""); // YYYY-MM-DD format for input type="date"
  const [filterToDate, setFilterToDate] = useState<string>(""); // YYYY-MM-DD format for input type="date"
  // State for sort column should use API terms as sent to backend
  const [sortColumn, setSortColumn] = useState<ListSummariesCommand["sort_by"]>("created_at");
  const [sortOrder, setSortOrder] = useState<ListSummariesCommand["sort_order"]>("desc");

  // Memoize fetchSummaries to prevent re-creation on every render
  // useCallback is important here because fetchSummaries is a dependency of useEffect
  const fetchSummaries = useCallback(async (params: ListSummariesCommand) => {
    setIsLoading(true);
    setError(null); // Clear inline error on new fetch
    try {
      // Use the apiService to fetch data
      // apiService is updated to handle/skip auth based on MVP rules
      const data = await apiService.fetchSummaries(params);
      setSummaries(data);
    } catch (err: any) {
      console.error("Failed to fetch summaries:", err);
      // Display generic error message inline above the table
      setError("Nie udało się załadować listy podsumowań. Spróbuj ponownie później.");
      // Optionally, use toast for a less intrusive notification for list loading errors
      // toast({
      //   description: "Wystąpił błąd podczas ładowania listy.",
      //   variant: "destructive",
      // });
    } finally {
      setIsLoading(false);
    }
  }, []); // Dependencies are managed by the state changes that trigger useEffect

  useEffect(() => {
    // Fetch data on mount and when filter/sort params change
    // The date inputs give YYYY-MM-DD, which is sufficient for the backend to parse.
    fetchSummaries({
      from_dt: filterFromDate,
      to_dt: filterToDate,
      sort_by: sortColumn,
      sort_order: sortOrder,
    });
  }, [filterFromDate, filterToDate, sortColumn, sortOrder, fetchSummaries]); // Dependencies now include memoized fetchSummaries

  const handleSortChange = (column: ListSummariesCommand["sort_by"]) => {
    if (sortColumn === column) {
      // Toggle order if clicking the same column
      setSortOrder(sortOrder === "asc" ? "desc" : "asc");
    } else {
      // Set new column and default to desc order
      setSortColumn(column);
      setSortOrder("desc"); // Or 'asc', based on desired default when changing column
    }
    // fetchSummaries will be called by useEffect due to sort state change
  };

  const handleEditClick = (id: string) => {
    // Redirect to the edit page
    window.location.href = `/edit/${id}`;
  };

  const handleDeleteClick = async (id: string, title: string) => {
    if (confirm(`Czy na pewno chcesz usunąć podsumowanie "${title || id}"?`)) {
      try {
        // Use apiService to delete the summary
        await apiService.deleteSummary(id);
        toast({
          description: `Podsumowanie "${title || id}" usunięto.`,
          // variant: "success" // Requires success variant styling
        });
        // Refresh the list after deletion
        // Re-fetch with current filters/sort order
        fetchSummaries({
          from_dt: filterFromDate,
          to_dt: filterToDate,
          sort_by: sortColumn,
          sort_order: sortOrder,
        });
      } catch (err: any) {
        console.error("Failed to delete summary:", err);
        toast({
          description: `Nie udało się usunąć podsumowania "${title || id}". Szczegóły: ${err.message || ""}`,
          variant: "destructive",
        });
      }
    }
  };

  const handleCreateClick = () => {
    // Redirect to the create page
    window.location.href = "/create";
  };

  // Function to format date strings for display
  const formatDate = (dateString: string) => {
    if (!dateString) return "-";
    try {
      // Use date-fns parseISO for reliable parsing of ISO strings from API
      const date = parseISO(dateString);

      if (isNaN(date.getTime())) {
        return "Niepoprawna data";
      }
      // Format as dd.MM.yyyy HH:mm
      return format(date, "dd.MM.yyyy HH:mm", { locale: pl });
    } catch (e) {
      console.error("Failed to format date:", dateString, e);
      return "Błąd formatowania daty";
    }
  };

  return (
    <div className="space-y-6">
      {/* Page Title and New Summary Button */}
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-bold">Moje podsumowania</h1>
        <Button onClick={handleCreateClick}>Nowe podsumowanie</Button>
      </div>

      {/* Filtering Section */}
      {/* Added margin-top to separate from title */}
      <div className="flex flex-col sm:flex-row items-start sm:items-end gap-4 p-4 border rounded-md bg-card mt-4">
        <div className="flex flex-col gap-2 w-full sm:w-auto">
          <Label htmlFor="filterFrom">Utworzone od:</Label>
          <Input
            id="filterFrom"
            type="date"
            value={filterFromDate}
            onChange={(e) => setFilterFromDate(e.target.value)}
          />
        </div>
        <div className="flex flex-col gap-2 w-full sm:w-auto">
          <Label htmlFor="filterTo">Utworzone do:</Label>
          <Input id="filterTo" type="date" value={filterToDate} onChange={(e) => setFilterToDate(e.target.value)} />
        </div>
        {/* Filter button is redundant if filtering updates on date input change */}
        {/* <Button onClick={handleFilterClick}>Filtruj</Button> */}
      </div>

      {/* Error Display (inline for list loading) */}
      {error && <p className="text-sm font-medium text-red-500 mt-4">{error}</p>}

      {/* Summary Table */}
      <div className="border rounded-md overflow-hidden">
        <Table>
          <TableHeader className="bg-muted/50">
            <TableRow>
              {/* Title/File Name Header */}
              <TableHead className="min-w-[150px]">Nazwa/Tytuł</TableHead>
              {/* Created At Header (Sortable) */}
              <TableHead
                className="cursor-pointer hover:text-primary min-w-[150px]" // Added min-width for date columns
                onClick={() => handleSortChange("created_at")}
              >
                <div className="flex items-center">
                  {" "}
                  {/* Flex for text and icon alignment */}
                  Data utworzenia
                  {/* Display sort indicator */}
                  {sortColumn === "created_at" &&
                    (sortOrder === "asc" ? (
                      <ArrowUpDown className="ml-1 h-4 w-4 inline-block rotate-180" />
                    ) : (
                      <ArrowUpDown className="ml-1 h-4 w-4 inline-block" />
                    ))}
                  {/* Show muted icon if not sorting by this column */}
                  {sortColumn !== "created_at" && (
                    <ArrowUpDown className="ml-1 h-4 w-4 inline-block text-muted-foreground opacity-50" />
                  )}
                </div>
              </TableHead>
              {/* Updated At Header (Sortable) */}
              <TableHead
                className="cursor-pointer hover:text-primary min-w-[150px]" // Added min-width
                onClick={() => handleSortChange("updated_at")}
              >
                <div className="flex items-center">
                  {" "}
                  {/* Flex for text and icon alignment */}
                  Data modyfikacji
                  {/* Display sort indicator */}
                  {sortColumn === "updated_at" &&
                    (sortOrder === "asc" ? (
                      <ArrowUpDown className="ml-1 h-4 w-4 inline-block rotate-180" />
                    ) : (
                      <ArrowUpDown className="ml-1 h-4 w-4 inline-block" />
                    ))}
                  {/* Show muted icon if not sorting by this column */}
                  {sortColumn !== "updated_at" && (
                    <ArrowUpDown className="ml-1 h-4 w-4 inline-block text-muted-foreground opacity-50" />
                  )}
                </div>
              </TableHead>
              {/* Actions Header */}
              <TableHead className="text-right min-w-[120px]">Akcje</TableHead> {/* Adjusted min-width for 2 buttons */}
            </TableRow>
          </TableHeader>
          <TableBody>
            {isLoading ? (
              <TableRow>
                <TableCell colSpan={4} className="text-center py-8">
                  <Loader2 className="h-8 w-8 animate-spin mx-auto text-primary" />
                  <span className="mt-2 block">Ładowanie...</span>
                </TableCell>
              </TableRow>
            ) : summaries.length === 0 ? (
              <TableRow>
                <TableCell colSpan={4} className="text-center py-8 text-muted-foreground">
                  Brak podsumowań do wyświetlenia.
                </TableCell>
              </TableRow>
            ) : (
              summaries.map((summary) => (
                <TableRow key={summary.id}>
                  <TableCell className="font-medium max-w-[200px] truncate">
                    {summary.title || summary.file_name || "Bez nazwy"}
                  </TableCell>{" "}
                  {/* Display title or file_name, truncate long names */}
                  <TableCell>{formatDate(summary.created_at)}</TableCell>
                  <TableCell>{formatDate(summary.updated_at)}</TableCell>
                  <TableCell className="text-right flex gap-2 justify-end">
                    {" "}
                    {/* Use flex gap for buttons */}
                    <Button variant="outline" size="sm" onClick={() => handleEditClick(summary.id)}>
                      <Edit className="h-4 w-4" />
                      {/* Visually hide text on small screens for icon-only button */}
                      <span className="sr-only sm:not-sr-only">Edytuj</span>
                    </Button>
                    {/* Delete button - add confirmation */}
                    <Button
                      variant="destructive"
                      size="sm"
                      onClick={() => handleDeleteClick(summary.id, summary.title || summary.file_name || "")}
                    >
                      <Trash2 className="h-4 w-4" />
                      {/* Visually hide text on small screens for icon-only button */}
                      <span className="sr-only sm:not-sr-only">Usuń</span>
                    </Button>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>
    </div>
  );
};

export default SummaryList;



================================================
File: .history/src/components/views/SummaryList_20250421134751.tsx
================================================
// src/components/views/SummaryList.tsx
import * as React from "react";
import { useState, useEffect, useCallback } from "react"; // Import useCallback
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Loader2, ArrowUpDown, Edit, Trash2 } from "lucide-react"; // Add Edit, Trash2 icons
import type { MeetingSummaryListEntryDto, ListSummariesCommand } from "@/types";
import { format } from "date-fns";
import { pl } from "date-fns/locale";
// import { supabase } from "@/auth"; // No longer needed directly for API calls needing auth token
import { apiService } from "@/lib/apiService"; // Import the apiService
import { toast } from "sonner"; // Import toast

// Import date-fns parseISO for parsing date strings from state
import { parseISO } from "date-fns";

const SummaryList: React.FC = () => {
  const [summaries, setSummaries] = useState<MeetingSummaryListEntryDto[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [filterFromDate, setFilterFromDate] = useState<string>(""); // YYYY-MM-DD format for input type="date"
  const [filterToDate, setFilterToDate] = useState<string>(""); // YYYY-MM-DD format for input type="date"
  // State for sort column should use API terms as sent to backend
  const [sortColumn, setSortColumn] = useState<ListSummariesCommand["sort_by"]>("created_at");
  const [sortOrder, setSortOrder] = useState<ListSummariesCommand["sort_order"]>("desc");

  // Memoize fetchSummaries to prevent re-creation on every render
  // useCallback is important here because fetchSummaries is a dependency of useEffect
  const fetchSummaries = useCallback(async (params: ListSummariesCommand) => {
    setIsLoading(true);
    setError(null); // Clear inline error on new fetch
    try {
      // Use the apiService to fetch data
      // apiService is updated to handle/skip auth based on MVP rules
      const data = await apiService.fetchSummaries(params);
      setSummaries(data);
    } catch (err: any) {
      console.error("Failed to fetch summaries:", err);
      // Display generic error message inline above the table
      setError("Nie udało się załadować listy podsumowań. Spróbuj ponownie później.");
      // Optionally, use toast for a less intrusive notification for list loading errors
      // toast({
      //   description: "Wystąpił błąd podczas ładowania listy.",
      //   variant: "destructive",
      // });
    } finally {
      setIsLoading(false);
    }
  }, []); // Dependencies are managed by the state changes that trigger useEffect

  useEffect(() => {
    // Fetch data on mount and when filter/sort params change
    // The date inputs give YYYY-MM-DD, which is sufficient for the backend to parse.
    fetchSummaries({
      from_dt: filterFromDate,
      to_dt: filterToDate,
      sort_by: sortColumn,
      sort_order: sortOrder,
    });
  }, [filterFromDate, filterToDate, sortColumn, sortOrder, fetchSummaries]); // Dependencies now include memoized fetchSummaries

  const handleSortChange = (column: ListSummariesCommand["sort_by"]) => {
    if (sortColumn === column) {
      // Toggle order if clicking the same column
      setSortOrder(sortOrder === "asc" ? "desc" : "asc");
    } else {
      // Set new column and default to desc order
      setSortColumn(column);
      setSortOrder("desc"); // Or 'asc', based on desired default when changing column
    }
    // fetchSummaries will be called by useEffect due to sort state change
  };

  const handleEditClick = (id: string) => {
    // Redirect to the edit page
    window.location.href = `/edit/${id}`;
  };

  const handleDeleteClick = async (id: string, title: string) => {
    if (confirm(`Czy na pewno chcesz usunąć podsumowanie "${title || id}"?`)) {
      try {
        // Use apiService to delete the summary
        await apiService.deleteSummary(id);
        toast({
          description: `Podsumowanie "${title || id}" usunięto.`,
          // variant: "success" // Requires success variant styling
        });
        // Refresh the list after deletion
        // Re-fetch with current filters/sort order
        fetchSummaries({
          from_dt: filterFromDate,
          to_dt: filterToDate,
          sort_by: sortColumn,
          sort_order: sortOrder,
        });
      } catch (err: any) {
        console.error("Failed to delete summary:", err);
        toast({
          description: `Nie udało się usunąć podsumowania "${title || id}". Szczegóły: ${err.message || ""}`,
          variant: "destructive",
        });
      }
    }
  };

  const handleCreateClick = () => {
    // Redirect to the create page
    window.location.href = "/create";
  };

  // Function to format date strings for display
  const formatDate = (dateString: string) => {
    if (!dateString) return "-";
    try {
      // Use date-fns parseISO for reliable parsing of ISO strings from API
      const date = parseISO(dateString);

      if (isNaN(date.getTime())) {
        return "Niepoprawna data";
      }
      // Format as dd.MM.yyyy HH:mm
      return format(date, "dd.MM.yyyy HH:mm", { locale: pl });
    } catch (e) {
      console.error("Failed to format date:", dateString, e);
      return "Błąd formatowania daty";
    }
  };

  return (
    <div className="space-y-6">
      {/* Page Title and New Summary Button */}
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-bold">Moje podsumowania</h1>
        <Button onClick={handleCreateClick}>Nowe podsumowanie</Button>
      </div>

      {/* Filtering Section */}
      {/* Added margin-top to separate from title */}
      <div className="flex flex-col sm:flex-row items-start sm:items-end gap-4 p-4 border rounded-md bg-card mt-4">
        <div className="flex flex-col gap-2 w-full sm:w-auto">
          <Label htmlFor="filterFrom">Utworzone od:</Label>
          <Input
            id="filterFrom"
            type="date"
            value={filterFromDate}
            onChange={(e) => setFilterFromDate(e.target.value)}
          />
        </div>
        <div className="flex flex-col gap-2 w-full sm:w-auto">
          <Label htmlFor="filterTo">Utworzone do:</Label>
          <Input id="filterTo" type="date" value={filterToDate} onChange={(e) => setFilterToDate(e.target.value)} />
        </div>
        {/* Filter button is redundant if filtering updates on date input change */}
        {/* <Button onClick={handleFilterClick}>Filtruj</Button> */}
      </div>

      {/* Error Display (inline for list loading) */}
      {error && <p className="text-sm font-medium text-red-500 mt-4">{error}</p>}

      {/* Summary Table */}
      <div className="border rounded-md overflow-hidden">
        <Table>
          <TableHeader className="bg-muted/50">
            <TableRow>
              {/* Title/File Name Header */}
              <TableHead className="min-w-[150px]">Nazwa/Tytuł</TableHead>
              {/* Created At Header (Sortable) */}
              <TableHead
                className="cursor-pointer hover:text-primary min-w-[150px]" // Added min-width for date columns
                onClick={() => handleSortChange("created_at")}
              >
                <div className="flex items-center">
                  {" "}
                  {/* Flex for text and icon alignment */}
                  Data utworzenia
                  {/* Display sort indicator */}
                  {sortColumn === "created_at" &&
                    (sortOrder === "asc" ? (
                      <ArrowUpDown className="ml-1 h-4 w-4 inline-block rotate-180" />
                    ) : (
                      <ArrowUpDown className="ml-1 h-4 w-4 inline-block" />
                    ))}
                  {/* Show muted icon if not sorting by this column */}
                  {sortColumn !== "created_at" && (
                    <ArrowUpDown className="ml-1 h-4 w-4 inline-block text-muted-foreground opacity-50" />
                  )}
                </div>
              </TableHead>
              {/* Updated At Header (Sortable) */}
              <TableHead
                className="cursor-pointer hover:text-primary min-w-[150px]" // Added min-width
                onClick={() => handleSortChange("updated_at")}
              >
                <div className="flex items-center">
                  {" "}
                  {/* Flex for text and icon alignment */}
                  Data modyfikacji
                  {/* Display sort indicator */}
                  {sortColumn === "updated_at" &&
                    (sortOrder === "asc" ? (
                      <ArrowUpDown className="ml-1 h-4 w-4 inline-block rotate-180" />
                    ) : (
                      <ArrowUpDown className="ml-1 h-4 w-4 inline-block" />
                    ))}
                  {/* Show muted icon if not sorting by this column */}
                  {sortColumn !== "updated_at" && (
                    <ArrowUpDown className="ml-1 h-4 w-4 inline-block text-muted-foreground opacity-50" />
                  )}
                </div>
              </TableHead>
              {/* Actions Header */}
              <TableHead className="text-right min-w-[120px]">Akcje</TableHead> {/* Adjusted min-width for 2 buttons */}
            </TableRow>
          </TableHeader>
          <TableBody>
            {isLoading ? (
              <TableRow>
                <TableCell colSpan={4} className="text-center py-8">
                  <Loader2 className="h-8 w-8 animate-spin mx-auto text-primary" />
                  <span className="mt-2 block">Ładowanie...</span>
                </TableCell>
              </TableRow>
            ) : summaries.length === 0 ? (
              <TableRow>
                <TableCell colSpan={4} className="text-center py-8 text-muted-foreground">
                  Brak podsumowań do wyświetlenia.
                </TableCell>
              </TableRow>
            ) : (
              summaries.map((summary) => (
                <TableRow key={summary.id}>
                  <TableCell className="font-medium max-w-[200px] truncate">
                    {summary.title || summary.file_name || "Bez nazwy"}
                  </TableCell>{" "}
                  {/* Display title or file_name, truncate long names */}
                  <TableCell>{formatDate(summary.created_at)}</TableCell>
                  <TableCell>{formatDate(summary.updated_at)}</TableCell>
                  <TableCell className="text-right flex gap-2 justify-end">
                    {" "}
                    {/* Use flex gap for buttons */}
                    <Button variant="outline" size="sm" onClick={() => handleEditClick(summary.id)}>
                      <Edit className="h-4 w-4" />
                      {/* Visually hide text on small screens for icon-only button */}
                      <span className="sr-only sm:not-sr-only">Edytuj</span>
                    </Button>
                    {/* Delete button - add confirmation */}
                    <Button
                      variant="destructive"
                      size="sm"
                      onClick={() => handleDeleteClick(summary.id, summary.title || summary.file_name || "")}
                    >
                      <Trash2 className="h-4 w-4" />
                      {/* Visually hide text on small screens for icon-only button */}
                      <span className="sr-only sm:not-sr-only">Usuń</span>
                    </Button>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>
    </div>
  );
};

export default SummaryList;



================================================
File: .history/src/db/supabase.client_20250419200154.ts
================================================
// src/db/supabase.client.ts
// Import createClient and the base SupabaseClient type from the library
import { createClient, type SupabaseClient as SupabaseClientBase } from "@supabase/supabase-js";

// Import your local Database type
import type { Database } from "./database.types";

const supabaseUrl = import.meta.env.SUPABASE_URL;
const supabaseAnonKey = import.meta.env.SUPABASE_KEY;

// --- Static User ID for MVP ---
// IMPORTANT: Replace with the actual UUID of the user you want to use for testing.
// This user should exist in your Supabase auth.users and public.users tables.
export const DEFAULT_USER_ID = "9575a8e6-4160-45f5-93bd-0ff215ae4c83";

// Export the Supabase client instance (lowercase)
export const supabaseClient = createClient<Database>(supabaseUrl, supabaseAnonKey, {
  auth: { persistSession: false },
});

// Export the SupabaseClient type alias, parameterized with your Database type
// This uses the imported base type 'SupabaseClientBase'
export type SupabaseClient = SupabaseClientBase<Database>;



================================================
File: .history/src/db/supabase.client_20250421133610.ts
================================================
// src/db/supabase.client.ts
// Import createClient and the base SupabaseClient type from the library
import { createClient, type SupabaseClient as SupabaseClientBase } from "@supabase/supabase-js";

// Import your local Database type
import type { Database } from "./database.types";

const supabaseUrl = import.meta.env.SUPABASE_URL;
const supabaseAnonKey = import.meta.env.SUPABASE_KEY;

// --- Static User ID for MVP ---
// IMPORTANT: Replace with the actual UUID of the user you want to use for testing.
// This user should exist in your Supabase auth.users and public.users tables.
export const DEFAULT_USER_ID = "9575a8e6-4160-45f5-93bd-0ff215ae4c83";

// Export the Supabase client instance (lowercase)
export const supabaseClient = createClient<Database>(supabaseUrl, supabaseAnonKey, {
  auth: { persistSession: false },
});

// Export the SupabaseClient type alias, parameterized with your Database type
// This uses the imported base type 'SupabaseClientBase'
export type SupabaseClient = SupabaseClientBase<Database>;



================================================
File: .history/src/db/supabase.client_20250421134640.ts
================================================
// src/db/supabase.client.ts
// Import the base SupabaseClient type and createServerClient from the library
import { type SupabaseClient as SupabaseClientBase } from "@supabase/ssr"; // Use SSR version for type consistency
import { createServerClient } from "@supabase/ssr"; // Import the SSR factory

// Import your local Database type
import type { Database } from "./database.types"; // Adjust path as needed

// --- Static User ID for MVP (TEMPORARY INSECURE WORKAROUND) ---
// IMPORTANT: This ID is used in API handlers instead of authenticated user ID
// as per specific MVP rule "Don't use any auth at the moment - use the user defined in the supabase.client.ts".
// This OVERRIDES standard Supabase RLS behavior for API endpoints and is INSECURE for production.
// Replace with the actual UUID of the user you want to use for testing MVP DB interactions.
// This user should exist in your Supabase auth.users and public.users tables.
export const DEFAULT_USER_ID = "9575a8e6-4160-45f5-93bd-0ff215ae4c83"; // !!! REPLACE WITH YOUR DEFAULT USER ID !!!

// Export the SupabaseClient type alias, parameterized with your Database type
// This is the type to use for type hinting the Supabase client instance (both server and browser).
export type SupabaseClient = SupabaseClientBase<Database>;

// Export createServerClient for use in Astro middleware and server code.
// The browser client instance is now exported from src/auth.ts.
export { createServerClient };

// Remove the direct export of `supabaseClient` instance from here, as it's now in `src/auth.ts`
// export const supabaseClient = ... ; // REMOVE THIS



================================================
File: .history/src/db/supabase.client_20250421140730.ts
================================================
// src/db/supabase.client.ts
// Import the base SupabaseClient type and createServerClient from the library
import { type SupabaseClient as SupabaseClientBase } from "@supabase/ssr"; // Use SSR version for type consistency
import { createServerClient } from "@supabase/ssr"; // Import the SSR factory

// Import your local Database type
import type { Database } from "./database.types"; // Adjust path as needed

// --- Static User ID for MVP (TEMPORARY INSECURE WORKAROUND) ---
// IMPORTANT: This ID is used in API handlers instead of authenticated user ID
// as per specific MVP rule "Don't use any auth at the moment - use the user defined in the supabase.client.ts".
// This OVERRIDES standard Supabase RLS behavior for API endpoints and is INSECURE for production.
// Replace with the actual UUID of the user you want to use for testing MVP DB interactions.
// This user should exist in your Supabase auth.users and public.users tables.
export const DEFAULT_USER_ID = "9575a8e6-4160-45f5-93bd-0ff215ae4c83"; // !!! REPLACE WITH YOUR DEFAULT USER ID !!!

// Export the SupabaseClient type alias, parameterized with your Database type
// This is the type to use for type hinting the Supabase client instance (both server and browser).
export type SupabaseClient = SupabaseClientBase<Database>;

// Export createServerClient for use in Astro middleware and server code.
// The browser client instance is now exported from src/auth.ts.
export { createServerClient };

// Remove the direct export of `supabaseClient` instance from here, as it's now in `src/auth.ts`
// export const supabaseClient = ... ; // REMOVE THIS



================================================
File: .history/src/db/supabase.client_20250421141241.ts
================================================
// src/db/supabase.client.ts
// Import the base SupabaseClient type and createServerClient from the library
// FIX: Use @supabase/ssr for the SSR client factory and type alias base as intended for middleware/server routes
import { type SupabaseClient as SupabaseClientBase } from "@supabase/ssr";
import { createServerClient } from "@supabase/ssr"; // Import the SSR factory

// Import your local Database type
import type { Database } from "./database.types"; // Adjust path as needed

// --- Static User ID for MVP (TEMPORARY INSECURE WORKAROUND) ---
// IMPORTANT: This ID is used in API handlers instead of authenticated user ID
// as per specific MVP rule "Don't use any auth at the moment - use the user defined in the supabase.client.ts".
// This OVERRIDES standard Supabase RLS behavior for API endpoints and is INSECURE for production.
// Replace with the actual UUID of the user you want to use for testing MVP DB interactions.
// This user should exist in your Supabase auth.users and public.users tables.
export const DEFAULT_USER_ID = "9575a8e6-4160-45f5-93bd-0ff215ae4c83"; // !!! REPLACE WITH YOUR DEFAULT USER ID !!!

// Export the SupabaseClient type alias, parameterized with your Database type
// This is the type to use for type hinting the Supabase client instance (both server and browser).
// FIX: This type alias is now the authoritative source for SupabaseClient type in the project
export type SupabaseClient = SupabaseClientBase<Database>;

// Export createServerClient for use in Astro middleware and server code.
// The browser client instance is now exported from src/auth.ts.
export { createServerClient };

// Remove the direct export of `supabaseClient` instance from here, as it's now in `src/auth.ts`
// export const supabaseClient = ... ; // REMOVE THIS



================================================
File: .history/src/lib/apiService_20250421131015.ts
================================================
// src/lib/apiService.ts
import { supabase } from "@/auth"; // Import the browser client
import type {
  ListSummariesCommand,
  MeetingSummaryListEntryDto,
  MeetingSummaryDetailsDto,
  CreateSummaryRequestDTO,
  CreateSummaryResponseDTO,
  UpdateSummaryRequestDTO,
  GenerateSummaryCommand,
  GenerateSummaryResponseDto,
} from "@/types";

// Helper function to get the auth token
const getAuthToken = async (): Promise<string> => {
  const {
    data: { session },
    error,
  } = await supabase.auth.getSession();
  if (error || !session) {
    // This should ideally not happen on protected routes due to layout checks,
    // but it's a safeguard for API calls.
    console.error("No active session found for API call.");
    throw new Error("Authentication required.");
  }
  return session.access_token;
};

// Helper function for generic fetch calls with auth
const fetchWithAuth = async (url: string, options: RequestInit = {}): Promise<Response> => {
  const token = await getAuthToken();
  const headers = {
    "Content-Type": "application/json",
    Authorization: `Bearer ${token}`,
    ...options.headers,
  };
  const response = await fetch(url, { ...options, headers });

  if (!response.ok) {
    let errorDetail = `API Error: ${response.status}`;
    try {
      const errorBody = await response.json();
      errorDetail = errorBody.message || errorBody.error || errorDetail;
    } catch (e) {
      // Ignore JSON parsing error if response is not JSON
    }
    const error = new Error(`Request failed: ${errorDetail}`);
    // Attach status code for potential specific handling if needed
    (error as any).status = response.status;
    throw error;
  }

  return response;
};

export const apiService = {
  // GET /api/summaries
  async fetchSummaries(params: ListSummariesCommand): Promise<MeetingSummaryListEntryDto[]> {
    const queryParams = new URLSearchParams();
    if (params.from_dt) queryParams.append("from_dt", params.from_dt);
    if (params.to_dt) queryParams.append("to_dt", params.to_dt);
    queryParams.append("sort_by", params.sort_by);
    queryParams.append("sort_order", params.sort_order);

    const url = `/api/summaries?${queryParams.toString()}`;

    const response = await fetchWithAuth(url, { method: "GET" });
    return response.json() as Promise<MeetingSummaryListEntryDto[]>;
  },

  // GET /api/summaries/{id}
  async getSummaryDetails(id: string): Promise<MeetingSummaryDetailsDto> {
    const url = `/api/summaries/${id}`;
    const response = await fetchWithAuth(url, { method: "GET" });
    return response.json() as Promise<MeetingSummaryDetailsDto>;
  },

  // POST /api/summaries
  async createSummary(data: CreateSummaryRequestDTO): Promise<CreateSummaryResponseDTO> {
    const url = "/api/summaries";
    const response = await fetchWithAuth(url, {
      method: "POST",
      body: JSON.stringify(data),
    });
    // API returns 201 Created with the new resource body
    return response.json() as Promise<CreateSummaryResponseDTO>;
  },

  // PUT /api/summaries/{id}
  async updateSummary(id: string, data: UpdateSummaryRequestDTO): Promise<MeetingSummaryDetailsDto> {
    const url = `/api/summaries/${id}`;
    const response = await fetchWithAuth(url, {
      method: "PUT",
      body: JSON.stringify(data),
    });
    // API returns 200 OK with the updated resource body
    return response.json() as Promise<MeetingSummaryDetailsDto>;
  },

  // DELETE /api/summaries/{id}
  async deleteSummary(id: string): Promise<void> {
    const url = `/api/summaries/${id}`;
    const response = await fetchWithAuth(url, {
      method: "DELETE",
    });
    // API returns 204 No Content on success
    if (response.status === 204) {
      return;
    }
    // If response is OK but not 204, maybe there's a body? Handle as error.
    let errorDetail = `API Error: ${response.status}`;
    try {
      const errorBody = await response.json();
      errorDetail = errorBody.message || errorBody.error || errorDetail;
    } catch (e) {
      /* ignore */
    }
    throw new Error(`Delete failed: ${errorDetail}`);
  },

  // POST /api/generate-summary
  async generateSummary(data: GenerateSummaryCommand): Promise<GenerateSummaryResponseDto> {
    const url = "/api/generate-summary";
    const response = await fetchWithAuth(url, {
      method: "POST",
      body: JSON.stringify(data),
    });
    return response.json() as Promise<GenerateSummaryResponseDto>;
  },
};



================================================
File: .history/src/lib/apiService_20250421133805.ts
================================================
// src/lib/apiService.ts
import { supabase } from "@/auth"; // Import the browser client
import type {
  ListSummariesCommand,
  MeetingSummaryListEntryDto,
  MeetingSummaryDetailsDto,
  CreateSummaryRequestDTO,
  CreateSummaryResponseDTO,
  UpdateSummaryRequestDTO,
  GenerateSummaryCommand,
  GenerateSummaryResponseDto,
} from "@/types";

// Helper function to get the auth token
const getAuthToken = async (): Promise<string> => {
  const {
    data: { session },
    error,
  } = await supabase.auth.getSession();
  if (error || !session) {
    // This should ideally not happen on protected routes due to layout checks,
    // but it's a safeguard for API calls.
    console.error("No active session found for API call.");
    throw new Error("Authentication required.");
  }
  return session.access_token;
};

// Helper function for generic fetch calls with auth
const fetchWithAuth = async (url: string, options: RequestInit = {}): Promise<Response> => {
  const token = await getAuthToken();
  const headers = {
    "Content-Type": "application/json",
    Authorization: `Bearer ${token}`,
    ...options.headers,
  };
  const response = await fetch(url, { ...options, headers });

  if (!response.ok) {
    let errorDetail = `API Error: ${response.status}`;
    try {
      const errorBody = await response.json();
      errorDetail = errorBody.message || errorBody.error || errorDetail;
    } catch (e) {
      // Ignore JSON parsing error if response is not JSON
    }
    const error = new Error(`Request failed: ${errorDetail}`);
    // Attach status code for potential specific handling if needed
    (error as any).status = response.status;
    throw error;
  }

  return response;
};

export const apiService = {
  // GET /api/summaries
  async fetchSummaries(params: ListSummariesCommand): Promise<MeetingSummaryListEntryDto[]> {
    const queryParams = new URLSearchParams();
    if (params.from_dt) queryParams.append("from_dt", params.from_dt);
    if (params.to_dt) queryParams.append("to_dt", params.to_dt);
    queryParams.append("sort_by", params.sort_by);
    queryParams.append("sort_order", params.sort_order);

    const url = `/api/summaries?${queryParams.toString()}`;

    const response = await fetchWithAuth(url, { method: "GET" });
    return response.json() as Promise<MeetingSummaryListEntryDto[]>;
  },

  // GET /api/summaries/{id}
  async getSummaryDetails(id: string): Promise<MeetingSummaryDetailsDto> {
    const url = `/api/summaries/${id}`;
    const response = await fetchWithAuth(url, { method: "GET" });
    return response.json() as Promise<MeetingSummaryDetailsDto>;
  },

  // POST /api/summaries
  async createSummary(data: CreateSummaryRequestDTO): Promise<CreateSummaryResponseDTO> {
    const url = "/api/summaries";
    const response = await fetchWithAuth(url, {
      method: "POST",
      body: JSON.stringify(data),
    });
    // API returns 201 Created with the new resource body
    return response.json() as Promise<CreateSummaryResponseDTO>;
  },

  // PUT /api/summaries/{id}
  async updateSummary(id: string, data: UpdateSummaryRequestDTO): Promise<MeetingSummaryDetailsDto> {
    const url = `/api/summaries/${id}`;
    const response = await fetchWithAuth(url, {
      method: "PUT",
      body: JSON.stringify(data),
    });
    // API returns 200 OK with the updated resource body
    return response.json() as Promise<MeetingSummaryDetailsDto>;
  },

  // DELETE /api/summaries/{id}
  async deleteSummary(id: string): Promise<void> {
    const url = `/api/summaries/${id}`;
    const response = await fetchWithAuth(url, {
      method: "DELETE",
    });
    // API returns 204 No Content on success
    if (response.status === 204) {
      return;
    }
    // If response is OK but not 204, maybe there's a body? Handle as error.
    let errorDetail = `API Error: ${response.status}`;
    try {
      const errorBody = await response.json();
      errorDetail = errorBody.message || errorBody.error || errorDetail;
    } catch (e) {
      /* ignore */
    }
    throw new Error(`Delete failed: ${errorDetail}`);
  },

  // POST /api/generate-summary
  async generateSummary(data: GenerateSummaryCommand): Promise<GenerateSummaryResponseDto> {
    const url = "/api/generate-summary";
    const response = await fetchWithAuth(url, {
      method: "POST",
      body: JSON.stringify(data),
    });
    return response.json() as Promise<GenerateSummaryResponseDto>;
  },
};



================================================
File: .history/src/lib/apiService_20250421133812.ts
================================================
// src/lib/apiService.ts
import { supabase } from "@/auth"; // Import the browser client
import type {
  ListSummariesCommand,
  MeetingSummaryListEntryDto,
  MeetingSummaryDetailsDto,
  CreateSummaryRequestDTO,
  CreateSummaryResponseDTO,
  UpdateSummaryRequestDTO,
  GenerateSummaryCommand,
  GenerateSummaryResponseDto,
} from "@/types";

// Helper function to get the auth token
const getAuthToken = async (): Promise<string> => {
  const {
    data: { session },
    error,
  } = await supabase.auth.getSession();
  if (error || !session) {
    // This should ideally not happen on protected routes due to layout checks,
    // but it's a safeguard for API calls.
    console.error("No active session found for API call.");
    throw new Error("Authentication required.");
  }
  return session.access_token;
};

// Helper function for generic fetch calls with auth
const fetchWithAuth = async (url: string, options: RequestInit = {}): Promise<Response> => {
  const token = await getAuthToken();
  const headers = {
    "Content-Type": "application/json",
    Authorization: `Bearer ${token}`,
    ...options.headers,
  };
  const response = await fetch(url, { ...options, headers });

  if (!response.ok) {
    let errorDetail = `API Error: ${response.status}`;
    try {
      const errorBody = await response.json();
      errorDetail = errorBody.message || errorBody.error || errorDetail;
    } catch (e) {
      // Ignore JSON parsing error if response is not JSON
    }
    const error = new Error(`Request failed: ${errorDetail}`);
    // Attach status code for potential specific handling if needed
    (error as any).status = response.status;
    throw error;
  }

  return response;
};

export const apiService = {
  // GET /api/summaries
  async fetchSummaries(params: ListSummariesCommand): Promise<MeetingSummaryListEntryDto[]> {
    const queryParams = new URLSearchParams();
    if (params.from_dt) queryParams.append("from_dt", params.from_dt);
    if (params.to_dt) queryParams.append("to_dt", params.to_dt);
    queryParams.append("sort_by", params.sort_by);
    queryParams.append("sort_order", params.sort_order);

    const url = `/api/summaries?${queryParams.toString()}`;

    const response = await fetchWithAuth(url, { method: "GET" });
    return response.json() as Promise<MeetingSummaryListEntryDto[]>;
  },

  // GET /api/summaries/{id}
  async getSummaryDetails(id: string): Promise<MeetingSummaryDetailsDto> {
    const url = `/api/summaries/${id}`;
    const response = await fetchWithAuth(url, { method: "GET" });
    return response.json() as Promise<MeetingSummaryDetailsDto>;
  },

  // POST /api/summaries
  async createSummary(data: CreateSummaryRequestDTO): Promise<CreateSummaryResponseDTO> {
    const url = "/api/summaries";
    const response = await fetchWithAuth(url, {
      method: "POST",
      body: JSON.stringify(data),
    });
    // API returns 201 Created with the new resource body
    return response.json() as Promise<CreateSummaryResponseDTO>;
  },

  // PUT /api/summaries/{id}
  async updateSummary(id: string, data: UpdateSummaryRequestDTO): Promise<MeetingSummaryDetailsDto> {
    const url = `/api/summaries/${id}`;
    const response = await fetchWithAuth(url, {
      method: "PUT",
      body: JSON.stringify(data),
    });
    // API returns 200 OK with the updated resource body
    return response.json() as Promise<MeetingSummaryDetailsDto>;
  },

  // DELETE /api/summaries/{id}
  async deleteSummary(id: string): Promise<void> {
    const url = `/api/summaries/${id}`;
    const response = await fetchWithAuth(url, {
      method: "DELETE",
    });
    // API returns 204 No Content on success
    if (response.status === 204) {
      return;
    }
    // If response is OK but not 204, maybe there's a body? Handle as error.
    let errorDetail = `API Error: ${response.status}`;
    try {
      const errorBody = await response.json();
      errorDetail = errorBody.message || errorBody.error || errorDetail;
    } catch (e) {
      /* ignore */
    }
    throw new Error(`Delete failed: ${errorDetail}`);
  },

  // POST /api/generate-summary
  async generateSummary(data: GenerateSummaryCommand): Promise<GenerateSummaryResponseDto> {
    const url = "/api/generate-summary";
    const response = await fetchWithAuth(url, {
      method: "POST",
      body: JSON.stringify(data),
    });
    return response.json() as Promise<GenerateSummaryResponseDto>;
  },
};



================================================
File: .history/src/lib/apiService_20250421134716.ts
================================================
// src/lib/apiService.ts
// import { supabase } from "@/auth"; // No longer needed directly for API calls needing auth token
import type {
  // Import types for DTOs
  ListSummariesCommand,
  MeetingSummaryListEntryDto,
  MeetingSummaryDetailsDto,
  CreateSummaryRequestDTO,
  CreateSummaryResponseDTO,
  UpdateSummaryRequestDTO,
  GenerateSummaryCommand,
  GenerateSummaryResponseDto,
} from "@/types";

// Helper function for generic fetch calls
// IMPORTANT: This MVP version does NOT include the Authorization header.
// This is INSECURE for production API endpoints and violates the general API plan.
// This is done only to adhere to the specific MVP rule "Don't use any auth at the moment".
const fetchWithoutAuth = async (url: string, options: RequestInit = {}): Promise<Response> => {
  console.warn(`apiService: Making insecure API call to ${url} without Authorization header (MVP ONLY).`);
  const headers = {
    "Content-Type": "application/json",
    ...options.headers,
  };
  const response = await fetch(url, { ...options, headers });

  if (!response.ok) {
    let errorDetail = `API Error: ${response.status}`;
    try {
      // Attempt to parse error body for more details
      const errorBody = await response.json();
      errorDetail = errorBody.message || errorBody.error || JSON.stringify(errorBody);
    } catch (e) {
      // If JSON parsing fails, just use status text
      errorDetail = `${response.status} ${response.statusText}`;
    }
    const error = new Error(`Request failed: ${errorDetail}`);
    // Attach status code for potential specific handling if needed
    (error as any).status = response.status;
    throw error;
  }

  return response;
};

export const apiService = {
  // GET /api/summaries
  async fetchSummaries(params: ListSummariesCommand): Promise<MeetingSummaryListEntryDto[]> {
    const queryParams = new URLSearchParams();
    if (params.from_dt) queryParams.append("from_dt", params.from_dt);
    if (params.to_dt) queryParams.append("to_dt", params.to_dt);
    queryParams.append("sort_by", params.sort_by);
    queryParams.append("sort_order", params.sort_order);

    const url = `/api/summaries?${queryParams.toString()}`;

    // Use fetchWithoutAuth as auth is skipped in backend handler for this MVP
    const response = await fetchWithoutAuth(url, { method: "GET" });
    return response.json() as Promise<MeetingSummaryListEntryDto[]>;
  },

  // GET /api/summaries/{id}
  async getSummaryDetails(id: string): Promise<MeetingSummaryDetailsDto> {
    const url = `/api/summaries/${id}`;
    // Use fetchWithoutAuth as auth is skipped in backend handler for this MVP
    const response = await fetchWithoutAuth(url, { method: "GET" });
    if (response.status === 404) {
      // Explicitly handle 404 from API
      throw new Error(`Summary with ID ${id} not found.`);
    }
    return response.json() as Promise<MeetingSummaryDetailsDto>;
  },

  // POST /api/summaries
  async createSummary(data: CreateSummaryRequestDTO): Promise<CreateSummaryResponseDTO> {
    const url = "/api/summaries";
    // Use fetchWithoutAuth as auth is skipped in backend handler for this MVP
    const response = await fetchWithoutAuth(url, {
      method: "POST",
      body: JSON.stringify(data),
    });
    // API returns 201 Created with the new resource body
    return response.json() as Promise<CreateSummaryResponseDTO>;
  },

  // PUT /api/summaries/{id}
  async updateSummary(id: string, data: UpdateSummaryRequestDTO): Promise<MeetingSummaryDetailsDto> {
    const url = `/api/summaries/${id}`;
    // Use fetchWithoutAuth as auth is skipped in backend handler for this MVP
    const response = await fetchWithoutAuth(url, {
      method: "PUT",
      body: JSON.stringify(data),
    });
    if (response.status === 404) {
      throw new Error(`Summary with ID ${id} not found for update.`);
    }
    // API returns 200 OK with the updated resource body
    return response.json() as Promise<MeetingSummaryDetailsDto>;
  },

  // DELETE /api/summaries/{id}
  async deleteSummary(id: string): Promise<void> {
    const url = `/api/summaries/${id}`;
    // Use fetchWithoutAuth as auth is skipped in backend handler for this MVP
    const response = await fetchWithoutAuth(url, {
      method: "DELETE",
    });
    if (response.status === 204) {
      return; // Success (No Content)
    }
    if (response.status === 404) {
      throw new Error(`Summary with ID ${id} not found for deletion.`);
    }
    // If response is OK but not 204/404, maybe there's a body? Handle as error.
    let errorDetail = `API Error: ${response.status}`;
    try {
      const errorBody = await response.json();
      errorDetail = errorBody.message || errorBody.error || errorDetail;
    } catch (e) {
      /* ignore */
    }
    throw new Error(`Delete failed unexpectedly: ${errorDetail}`);
  },

  // POST /api/generate-summary
  async generateSummary(data: GenerateSummaryCommand): Promise<GenerateSummaryResponseDto> {
    const url = "/api/generate-summary";
    // Use fetchWithoutAuth as auth is skipped in backend handler for this MVP
    const response = await fetchWithoutAuth(url, {
      method: "POST",
      body: JSON.stringify(data),
    });
    if (response.status === 500) {
      // Backend LLM errors are returned as 500 with a generic message
      throw new Error(`Failed to generate summary. Please try again.`); // Use a user-friendly message
    }
    return response.json() as Promise<GenerateSummaryResponseDto>;
  },
};



================================================
File: .history/src/lib/apiService_20250421134957.ts
================================================
// src/lib/apiService.ts
// import { supabase } from "@/auth"; // No longer needed directly for API calls needing auth token
import type {
  // Import types for DTOs
  ListSummariesCommand,
  MeetingSummaryListEntryDto,
  MeetingSummaryDetailsDto,
  CreateSummaryRequestDTO,
  CreateSummaryResponseDTO,
  UpdateSummaryRequestDTO,
  GenerateSummaryCommand,
  GenerateSummaryResponseDto,
} from "@/types";

// Helper function for generic fetch calls
// IMPORTANT: This MVP version does NOT include the Authorization header.
// This is INSECURE for production API endpoints and violates the general API plan.
// This is done only to adhere to the specific MVP rule "Don't use any auth at the moment".
const fetchWithoutAuth = async (url: string, options: RequestInit = {}): Promise<Response> => {
  console.warn(`apiService: Making insecure API call to ${url} without Authorization header (MVP ONLY).`);
  const headers = {
    "Content-Type": "application/json",
    ...options.headers,
  };
  const response = await fetch(url, { ...options, headers });

  if (!response.ok) {
    let errorDetail = `API Error: ${response.status}`;
    try {
      // Attempt to parse error body for more details
      const errorBody = await response.json();
      errorDetail = errorBody.message || errorBody.error || JSON.stringify(errorBody);
    } catch (e) {
      // If JSON parsing fails, just use status text
      errorDetail = `${response.status} ${response.statusText}`;
    }
    const error = new Error(`Request failed: ${errorDetail}`);
    // Attach status code for potential specific handling if needed
    (error as any).status = response.status;
    throw error;
  }

  return response;
};

export const apiService = {
  // GET /api/summaries
  async fetchSummaries(params: ListSummariesCommand): Promise<MeetingSummaryListEntryDto[]> {
    const queryParams = new URLSearchParams();
    if (params.from_dt) queryParams.append("from_dt", params.from_dt);
    if (params.to_dt) queryParams.append("to_dt", params.to_dt);
    queryParams.append("sort_by", params.sort_by);
    queryParams.append("sort_order", params.sort_order);

    const url = `/api/summaries?${queryParams.toString()}`;

    // Use fetchWithoutAuth as auth is skipped in backend handler for this MVP
    const response = await fetchWithoutAuth(url, { method: "GET" });
    return response.json() as Promise<MeetingSummaryListEntryDto[]>;
  },

  // GET /api/summaries/{id}
  async getSummaryDetails(id: string): Promise<MeetingSummaryDetailsDto> {
    const url = `/api/summaries/${id}`;
    // Use fetchWithoutAuth as auth is skipped in backend handler for this MVP
    const response = await fetchWithoutAuth(url, { method: "GET" });
    if (response.status === 404) {
      // Explicitly handle 404 from API
      throw new Error(`Summary with ID ${id} not found.`);
    }
    return response.json() as Promise<MeetingSummaryDetailsDto>;
  },

  // POST /api/summaries
  async createSummary(data: CreateSummaryRequestDTO): Promise<CreateSummaryResponseDTO> {
    const url = "/api/summaries";
    // Use fetchWithoutAuth as auth is skipped in backend handler for this MVP
    const response = await fetchWithoutAuth(url, {
      method: "POST",
      body: JSON.stringify(data),
    });
    // API returns 201 Created with the new resource body
    return response.json() as Promise<CreateSummaryResponseDTO>;
  },

  // PUT /api/summaries/{id}
  async updateSummary(id: string, data: UpdateSummaryRequestDTO): Promise<MeetingSummaryDetailsDto> {
    const url = `/api/summaries/${id}`;
    // Use fetchWithoutAuth as auth is skipped in backend handler for this MVP
    const response = await fetchWithoutAuth(url, {
      method: "PUT",
      body: JSON.stringify(data),
    });
    if (response.status === 404) {
      throw new Error(`Summary with ID ${id} not found for update.`);
    }
    // API returns 200 OK with the updated resource body
    return response.json() as Promise<MeetingSummaryDetailsDto>;
  },

  // DELETE /api/summaries/{id}
  async deleteSummary(id: string): Promise<void> {
    const url = `/api/summaries/${id}`;
    // Use fetchWithoutAuth as auth is skipped in backend handler for this MVP
    const response = await fetchWithoutAuth(url, {
      method: "DELETE",
    });
    if (response.status === 204) {
      return; // Success (No Content)
    }
    if (response.status === 404) {
      throw new Error(`Summary with ID ${id} not found for deletion.`);
    }
    // If response is OK but not 204/404, maybe there's a body? Handle as error.
    let errorDetail = `API Error: ${response.status}`;
    try {
      const errorBody = await response.json();
      errorDetail = errorBody.message || errorBody.error || errorDetail;
    } catch (e) {
      /* ignore */
    }
    throw new Error(`Delete failed unexpectedly: ${errorDetail}`);
  },

  // POST /api/generate-summary
  async generateSummary(data: GenerateSummaryCommand): Promise<GenerateSummaryResponseDto> {
    const url = "/api/generate-summary";
    // Use fetchWithoutAuth as auth is skipped in backend handler for this MVP
    const response = await fetchWithoutAuth(url, {
      method: "POST",
      body: JSON.stringify(data),
    });
    if (response.status === 500) {
      // Backend LLM errors are returned as 500 with a generic message
      throw new Error(`Failed to generate summary. Please try again.`); // Use a user-friendly message
    }
    return response.json() as Promise<GenerateSummaryResponseDto>;
  },
};



================================================
File: .history/src/middleware/index_20250419234052.ts
================================================
// src/middeware/index.ts
import { defineMiddleware } from "astro:middleware";

// To importuje INSTANCJĘ klienta Supabase (const supabaseClient) z PLIKU, KTÓRY JĄ TWORZY
import { supabaseClient } from "../db/supabase.client.ts";

export const onRequest = defineMiddleware((context, next) => {
  console.error("DEBUG MIDDLEWARE: supabaseClient imported:", typeof supabaseClient, supabaseClient !== undefined); // Tymczasowe logowanie

  context.locals.supabase = supabaseClient;

  console.error(
    "DEBUG MIDDLEWARE: context.locals.supabase after assignment:",
    typeof context.locals.supabase,
    context.locals.supabase !== undefined
  ); // Tymczasowe logowanie

  return next();
});



================================================
File: .history/src/middleware/index_20250421133625.ts
================================================
// src/middleware/index.ts
import { defineMiddleware } from "astro:middleware";
import type { APIContext } from "astro"; // Import APIContext type

// Import the createServerClient function and Database type from your local files
import { createServerClient, type SupabaseClient } from "../db/supabase.client.ts"; // Use your local imports
import type { Database } from "../db/database.types.ts"; // Adjust path if necessary

export const onRequest = defineMiddleware(async (context: APIContext, next) => {
  // Ensure environment variables are available server-side
  const supabaseUrl = context.locals.runtime.env.SUPABASE_URL;
  const supabaseKey = context.locals.runtime.env.SUPABASE_KEY;

  if (!supabaseUrl || !supabaseKey) {
    console.error("SUPABASE_URL or SUPABASE_KEY not found in server environment variables.");
    // In production, you might want to halt or return a specific error page.
    // For development, let's just log and proceed, although Supabase calls will likely fail.
    // return new Response("Internal Server Error: Supabase environment variables not set.", { status: 500 });
  }

  // Create a Supabase client instance specifically for this server-side request
  // This client will automatically read/write cookies based on the request/response
  // and is essential for server-side authentication checks and RLS to work correctly with auth.uid().
  const supabase = createServerClient<Database>(supabaseUrl, supabaseKey, {
    cookies: {
      get: context.cookies.get,
      set: context.cookies.set,
      remove: context.cookies.delete,
    },
  });

  // Attach the server-side Supabase client to context.locals
  context.locals.supabase = supabase;

  // Call the next middleware or the page/API handler
  return next();
});



================================================
File: .history/src/middleware/index_20250421133626.ts
================================================
// src/middleware/index.ts
import { defineMiddleware } from "astro:middleware";
import type { APIContext } from "astro"; // Import APIContext type

// Import the createServerClient function and Database type from your local files
import { createServerClient, type SupabaseClient } from "../db/supabase.client.ts"; // Use your local imports
import type { Database } from "../db/database.types.ts"; // Adjust path if necessary

export const onRequest = defineMiddleware(async (context: APIContext, next) => {
  // Ensure environment variables are available server-side
  const supabaseUrl = context.locals.runtime.env.SUPABASE_URL;
  const supabaseKey = context.locals.runtime.env.SUPABASE_KEY;

  if (!supabaseUrl || !supabaseKey) {
    console.error("SUPABASE_URL or SUPABASE_KEY not found in server environment variables.");
    // In production, you might want to halt or return a specific error page.
    // For development, let's just log and proceed, although Supabase calls will likely fail.
    // return new Response("Internal Server Error: Supabase environment variables not set.", { status: 500 });
  }

  // Create a Supabase client instance specifically for this server-side request
  // This client will automatically read/write cookies based on the request/response
  // and is essential for server-side authentication checks and RLS to work correctly with auth.uid().
  const supabase = createServerClient<Database>(supabaseUrl, supabaseKey, {
    cookies: {
      get: context.cookies.get,
      set: context.cookies.set,
      remove: context.cookies.delete,
    },
  });

  // Attach the server-side Supabase client to context.locals
  context.locals.supabase = supabase;

  // Call the next middleware or the page/API handler
  return next();
});



================================================
File: .history/src/middleware/index_20250421134655.ts
================================================
// src/middleware/index.ts
import { defineMiddleware } from "astro:middleware";
import type { APIContext } from "astro"; // Import APIContext type

// Import the createServerClient function and Database type from your local files
import { createServerClient, type SupabaseClient } from "../db/supabase.client.ts"; // Use your local imports
import type { Database } from "../db/database.types.ts"; // Adjust path if necessary

export const onRequest = defineMiddleware(async (context: APIContext, next) => {
  // Ensure environment variables are available server-side
  const supabaseUrl = context.locals.runtime.env.SUPABASE_URL;
  const supabaseKey = context.locals.runtime.env.SUPABASE_KEY;

  if (!supabaseUrl || !supabaseKey) {
    console.error("SUPABASE_URL or SUPABASE_KEY not found in server environment variables.");
    // In production, you might want to halt or return a specific error page.
    // For development, let's just log and proceed, although Supabase calls will likely fail.
    // return new Response("Internal Server Error: Supabase environment variables not set.", { status: 500 });
  }

  // Create a Supabase client instance specifically for this server-side request
  // This client will automatically read/write cookies based on the request/response
  // and is essential for server-side authentication checks and RLS to work correctly with auth.uid().
  const supabase = createServerClient<Database>(supabaseUrl, supabaseKey, {
    cookies: {
      get: context.cookies.get,
      set: context.cookies.set,
      remove: context.cookies.delete,
    },
  });

  // Attach the server-side Supabase client to context.locals
  context.locals.supabase = supabase;

  // Call the next middleware or the page/API handler
  return next();
});



================================================
File: .history/src/middleware/index_20250421135005.ts
================================================
// src/middleware/index.ts
import { defineMiddleware } from "astro:middleware";
import type { APIContext } from "astro"; // Import APIContext type

// Import the createServerClient function and Database type from your local files
import { createServerClient } from "../db/supabase.client.ts"; // Use your local imports
import type { Database } from "../db/database.types.ts"; // Adjust path if necessary

export const onRequest = defineMiddleware(async (context: APIContext, next) => {
  // Ensure environment variables are available server-side
  const supabaseUrl = context.locals.runtime.env.SUPABASE_URL;
  const supabaseKey = context.locals.runtime.env.SUPABASE_KEY;

  if (!supabaseUrl || !supabaseKey) {
    console.error("SUPABASE_URL or SUPABASE_KEY not found in server environment variables.");
    // In production, you might want to halt or return a specific error page.
    // For development, let's just log and proceed, although Supabase calls will likely fail.
    // return new Response("Internal Server Error: Supabase environment variables not set.", { status: 500 });
  }

  // Create a Supabase client instance specifically for this server-side request
  // This client will automatically read/write cookies based on the request/response
  // and is essential for server-side authentication checks and RLS to work correctly with auth.uid().
  const supabase = createServerClient<Database>(supabaseUrl, supabaseKey, {
    cookies: {
      get: context.cookies.get,
      set: context.cookies.set,
      remove: context.cookies.delete,
    },
  });

  // Attach the server-side Supabase client to context.locals
  context.locals.supabase = supabase;

  // Call the next middleware or the page/API handler
  return next();
});



================================================
File: .history/src/pages/api/generate-summary_20250420232756.ts
================================================
/* eslint-disable no-console */
// src/pages/api/generate-summary.ts -- Handler for /api/generate-summary (POST)

import type { APIRoute } from "astro";
// Import the Zod library
import { z } from "zod";

// Import types for request and response DTOs
import type { GenerateSummaryCommand, GenerateSummaryResponseDto } from "../../types"; // Adjust the path if necessary

// Import SupabaseClient type (not used for authentication check in this endpoint as per instruction)
import type { SupabaseClient } from "../../db/supabase.client"; // Adjust the path if necessary

// --- Zod Schema for Generate Summary Request Body ---
const generateSummaryRequestSchema: z.ZodSchema<GenerateSummaryCommand> = z.object({
  transcription: z.string().min(1, { message: "Transcription cannot be empty." }), // Required non-empty string
});

// Define the inferred type from the schema for validated data
type ValidatedGenerateSummaryRequest = z.infer<typeof generateSummaryRequestSchema>;

// --- Mock LLM Logic ---
// This function simulates calling an LLM API for summary generation
// In a real application, this would interact with an external LLM provider API
async function generateSummaryMock(transcription: string): Promise<string> {
  console.log("Calling mock LLM with transcription (first 100 chars):", transcription.substring(0, 100) + "...");

  try {
    // Simulate some async work (like calling an external API)
    await new Promise((resolve) => setTimeout(resolve, 200)); // Simulate network latency

    // --- Mock Logic: Extract the first line as the summary ---
    const firstLine = transcription.split("\n")[0] || ""; // Handle empty transcription gracefully

    // Ensure summary is max 500 characters, truncate if necessary
    const maxSummaryLength = 500;
    const mockSummary = firstLine.substring(0, maxSummaryLength);

    console.log("Mock LLM returning summary:", mockSummary.substring(0, 100) + "...");

    // Simulate occasional errors for testing the 500 case (Optional, remove for stable mock)
    // if (Math.random() < 0.1) { // 10% chance of failure
    //     throw new Error("Simulated LLM failure.");
    // }

    return mockSummary;
  } catch (error) {
    // Log the error internally if mock logic fails unexpectedly
    console.error("Error in mock LLM function:", error);
    // Re-throw a generic error to be caught by the handler's try...catch
    throw new Error("Mock LLM generation failed.");
  }
}

// --- Handler endpoint POST /api/generate-summary ---
// Implements the Generate Summary endpoint.
// Authentication check is skipped as per current instruction.
export const POST: APIRoute = async (context) => {
  // Although not used for authentication check here, Supabase client might be needed for
  // other reasons in a real scenario, so checking its availability is reasonable.
  const supabase: SupabaseClient = context.locals.supabase;

  if (!supabase) {
    console.error("POST /api/generate-summary: Supabase client not available in context.locals.");
    // Return 500 as this indicates a server-side configuration issue
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client configuration issue.",
      }),
      {
        status: 500,
        headers: {
          "Content-Type": "application/json",
        },
      }
    );
  }

  // --- Authentication Check (Skipped as per current instruction) ---
  // const { data: { user }, error: authError } = await supabase.auth.getUser();
  // if (authError || !user) { ... return 401 ... }
  console.log("POST /api/generate-summary: Authentication check skipped as per instruction.");
  // No user ID is needed for this endpoint as it doesn't interact with DB data.

  let requestBody: unknown; // Use unknown for initial request body type

  try {
    // --- Odczyt ciaĹ‚a ĹĽÄ…dania JSON ---
    requestBody = await context.request.json();
  } catch (error) {
    // 400 ObsĹ‚uga bĹ‚Ä™du: NieprawidĹ‚owy format JSON
    console.error("POST /api/generate-summary: Failed to parse request body as JSON:", error);
    return new Response(
      JSON.stringify({
        error: "Invalid JSON body",
      }),
      {
        status: 400,
        headers: {
          "Content-Type": "application/json",
        },
      }
    );
  }

  // Use a try...catch for errors *after* JSON parsing
  try {
    // --- Walidacja danych wejĹ›ciowych (zod) ---
    const validationResult = generateSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      // 400 ObsĹ‚uga bĹ‚Ä™du: Walidacja danych wejĹ›ciowych nie powiodĹ‚a siÄ™ (zod)
      console.error("POST /api/generate-summary: Input validation failed:", validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors, // Zod errors array
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    const validatedData: ValidatedGenerateSummaryRequest = validationResult.data;
    console.log("POST /api/generate-summary: Validation successful.");

    // --- WywoĹ‚anie metody serwisowej (mocka LLM) ---
    const generatedSummary = await generateSummaryMock(validatedData.transcription);

    // --- ObsĹ‚uga odpowiedzi z serwisu i zwrĂłcenie 200 OK ---
    const responseData: GenerateSummaryResponseDto = {
      summary: generatedSummary,
    };

    return new Response(JSON.stringify(responseData), {
      status: 200, // 200 OK for successful generation
      headers: { "Content-Type": "application/json" },
    });
  } catch (error) {
    // --- Implementacja obsĹ‚ugi bĹ‚Ä™dĂłw serwera / LLM (500) ---
    // This catches errors from validation subsequent logic (like the mock call)
    console.error("POST /api/generate-summary: Caught unexpected error after validation:", error);
    // Return a generic 500 error response
    return new Response(
      JSON.stringify({
        error: "An internal server error occurred during summary generation.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }
};



================================================
File: .history/src/pages/api/generate-summary_20250421133657.ts
================================================
generate - summary.ts;



================================================
File: .history/src/pages/api/generate-summary_20250421133706.ts
================================================
/* eslint-disable no-console */
// src/pages/api/generate-summary.ts -- Handler for /api/generate-summary (POST)

import type { APIRoute, APIContext } from "astro";
import { z } from "zod"; // Import the Zod library

// Import types for request and response DTOs
import type { GenerateSummaryCommand, GenerateSummaryResponseDto } from "../../types"; // Adjust the path if necessary

// Import SupabaseClient type (client is available in context.locals but auth check is skipped per MVP rule)
import type { SupabaseClient } from "../../db/supabase.client"; // Adjust the path if necessary

// --- Zod Schema for Generate Summary Request Body ---
const generateSummaryRequestSchema: z.ZodSchema<GenerateSummaryCommand> = z.object({
  transcription: z.string().min(1, { message: "Transcription cannot be empty." }), // Required non-empty string
});

// Define the inferred type from the schema for validated data
type ValidatedGenerateSummaryRequest = z.infer<typeof generateSummaryRequestSchema>;

// --- LLM Service Placeholder ---
// This function is a placeholder for calling a real LLM API
// Replace this mock logic with actual API call implementation
async function callLLMService(transcription: string): Promise<string> {
  console.log(
    "Calling placeholder LLM service with transcription (first 100 chars):",
    transcription.substring(0, 100) + "..."
  );

  // --- Replace with actual LLM API call (e.g., fetch to OpenAI, OpenRouter, Ollama) ---
  // Example using fetch (replace with your actual LLM provider details and API key)
  /*
  // Note: OPENROUTER_API_KEY is server-side only, accessed via import.meta.env in Astro API routes
  const apiKey = import.meta.env.OPENROUTER_API_KEY;

  try {
    const response = await fetch("https://api.openrouter.ai/api/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json",
        // Recommended headers for OpenRouter to identify your app
        "HTTP-Referer": 'YOUR_APP_URL_OR_IDENTIFIER', // Replace with your app's URL or a unique identifier
        "X-Title": "Meeting Summarizer MVP",
      },
      body: JSON.stringify({
        model: "openai/gpt-3.5-turbo", // Or another suitable model
        messages: [
          { role: "system", content: "JesteĹ› pomocnym asystentem podsumowujÄ…cym spotkania. StwĂłrz zwiÄ™zĹ‚e podsumowanie (do 500 znakĂłw) na podstawie transkrypcji w jÄ™zyku polskim." },
          { role: "user", content: transcription },
        ],
        max_tokens: 200, // Adjust token limit as needed to stay within 500 chars
      }),
    });

    if (!response.ok) {
      const errorBody = await response.json();
      console.error("LLM API Error:", response.status, errorBody);
      throw new Error(`LLM API returned status ${response.status}: ${errorBody.message || 'Unknown error'}`);
    }

    const data = await response.json();
    const generatedText = data.choices[0]?.message?.content || "";

    // Simple truncation just in case LLM exceeds expected length
    const maxSummaryLength = 500;
    const finalSummary = generatedText.substring(0, maxSummaryLength);

    console.log("LLM service returned summary:", finalSummary.substring(0, 100) + "...");
    return finalSummary;

  } catch (error) {
    console.error("Error communicating with LLM API:", error);
    // Log the full error details on the server
    throw new Error("Failed to communicate with summary generation service.");
  }
  */

  // --- Current Mock Logic (Remove for production) ---
  await new Promise((resolve) => setTimeout(resolve, 1500)); // Simulate delay
  if (Math.random() < 0.15) {
    // Simulate occasional error (15% chance)
    console.error("Simulating LLM error");
    throw new Error("Simulated LLM failure.");
  }
  const mockSummary = transcription.split("\n")[0]?.substring(0, 500) || "Mock summary.";
  console.log("Mock LLM returning summary:", mockSummary.substring(0, 100) + "...");
  return mockSummary;
  // --- End Mock Logic ---
}

// --- Handler endpoint POST /api/generate-summary ---
// Implements the Generate Summary endpoint.
// Authentication check is SKIPPED as per specific MVP rule.
export const POST: APIRoute = async (context) => {
  // Supabase client is available, but auth check is skipped per specific MVP rule.
  const supabase: SupabaseClient = context.locals.supabase;

  if (!supabase) {
    console.error("POST /api/generate-summary: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  // const { data: { user }, error: authError } = await supabase.auth.getUser();
  // if (authError || !user) { ... return 401 ... }
  console.log("POST /api/generate-summary: Authentication check SKIPPED as per specific MVP rule.");
  // No user ID is needed for the LLM call itself.

  let requestBody: unknown; // Use unknown for initial request body type

  try {
    // --- Parse Request Body ---
    requestBody = await context.request.json();
  } catch (error) {
    // 400 Error Handling: Invalid JSON format
    console.error("POST /api/generate-summary: Failed to parse request body as JSON:", error);
    return new Response(
      JSON.stringify({
        error: "Invalid JSON body",
      }),
      {
        status: 400,
        headers: {
          "Content-Type": "application/json",
        },
      }
    );
  }

  // Use a try...catch for errors *after* JSON parsing
  try {
    // --- Input Validation (zod) ---
    const validationResult = generateSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      // 400 Error Handling: Input validation failed (zod)
      console.error("POST /api/generate-summary: Input validation failed:", validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors, // Zod errors array
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    const validatedData: ValidatedGenerateSummaryRequest = validationResult.data;
    console.log("POST /api/generate-summary: Validation successful.");

    // --- Call LLM Service (or mock) ---
    // Authentication token is NOT passed to the LLM service call as per specific MVP rule.
    const generatedSummary = await callLLMService(validatedData.transcription);

    // --- Handle Service Response and Return 200 OK ---
    const responseData: GenerateSummaryResponseDto = {
      summary: generatedSummary,
    };

    return new Response(JSON.stringify(responseData), {
      status: 200, // 200 OK for successful generation
      headers: { "Content-Type": "application/json" },
    });
  } catch (error) {
    // --- Server Error Handling (500) ---
    // This catches errors from validation subsequent logic (like the LLM call)
    console.error("POST /api/generate-summary: Caught unexpected error after validation:", error);
    // Return a generic 500 error response
    return new Response(
      JSON.stringify({
        error: "An internal server error occurred during summary generation.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }
};

// Note: Only POST is implemented for this endpoint as per plan.
export const prerender = false; // Needed for server routes



================================================
File: .history/src/pages/api/summaries_20250420232716.ts
================================================
/* eslint-disable no-console */
// src/pages/api/summaries.ts -- Handlers for /api/summaries (GET and POST)

import type { APIRoute } from "astro";
// Import the Zod library
import { z } from "zod";

// Import your local SupabaseClient type alias AND the default user ID
import { type SupabaseClient, DEFAULT_USER_ID } from "../../db/supabase.client";

// Import Supabase specific types for better error handling and results
import type { PostgrestSingleResponse, PostgrestResponse } from "@supabase/supabase-js";

// Import shared DTOs and DB internal types from central types file
import type {
  MeetingSummaryListEntryDto,
  CreateSummaryResponseDTO,
  MeetingSummaryInsertData,
  MeetingSummaryFullRow,
  MeetingSummarySelectedColumns,
  ListSummariesServiceParams,
} from "../../types"; // Adjust the path if necessary

// --- Zod Schema for List Summaries Query Parameters (dla GET) ---
const listSummariesParamsSchema = z.object({
  sort_by: z.enum(["created_at", "updated_at"]).optional().default("created_at"),
  sort_order: z.enum(["asc", "desc"]).optional().default("desc"),
  from_dt: z.string().datetime({ message: "Invalid ISO 8601 date format for 'from_dt'." }).optional(),
  to_dt: z.string().datetime({ message: "Invalid ISO 8601 date format for 'to_dt'." }).optional(),
});

// --- Zod Schema for Create Summary Request Body (dla POST) ---
const createSummaryRequestSchema = z.object({
  file_name: z.string().nullable().optional(),
  transcription: z.string().min(1, { message: "Transcription cannot be empty." }),
  summary: z
    .string()
    .min(1, { message: "Summary cannot be empty." })
    .max(500, { message: "Summary cannot exceed 500 characters." }),
  llm_generated: z.boolean({ required_error: "Field 'llm_generated' is required and must be a boolean." }),
  notes: z.string().optional().default(""),
});

// --- SummaryService Class (dla GET) ---
class SummaryService {
  constructor(private supabase: SupabaseClient) {}

  async listUserSummaries(params: ListSummariesServiceParams): Promise<MeetingSummaryListEntryDto[]> {
    const { userId, dateRange, sortParams } = params;
    try {
      let query = this.supabase.from("meeting_summaries").select("id, title, file_name, created_at, modified_at");

      query = query.eq("user_id", userId);

      if (dateRange.from) {
        query = query.gte("created_at", dateRange.from.toISOString());
      }
      if (dateRange.to) {
        query = query.lte("created_at", dateRange.to.toISOString());
      }

      const result: PostgrestResponse<MeetingSummarySelectedColumns> = await query.order(sortParams.by, {
        ascending: sortParams.order === "asc",
      });
      const { data, error } = result;

      if (error) {
        console.error("Database error fetching summaries for user", userId, ":", error);
        throw new Error("Failed to fetch summaries from database.");
      }

      if (!data) {
        console.warn("GET /api/summaries: Select query returned no data and no error.");
        return [];
      }

      const summariesDto: MeetingSummaryListEntryDto[] = data.map((row) => ({
        id: row.id,
        title: row.title,
        file_name: row.file_name,
        created_at: row.created_at,
        updated_at: row.modified_at,
      }));

      return summariesDto;
    } catch (error) {
      console.error("Error in SummaryService.listUserSummaries:", error);
      throw error;
    }
  }
}

// --- Function Repository (dla POST) ---
async function insertSummaryIntoDB(
  supabase: SupabaseClient,
  data: MeetingSummaryInsertData
): Promise<PostgrestSingleResponse<MeetingSummaryFullRow>> {
  console.log("Attempting to insert data into DB:", data);

  const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await supabase
    .from("meeting_summaries")
    .insert([data])
    .select()
    .single();

  if (result.error) {
    console.error("Database insertion failed:", result.error);
  } else {
    console.log("Database insertion successful. New summary ID:", result.data?.id);
  }

  return result;
}

// --- Handler endpoint GET /api/summaries ---
export const GET: APIRoute = async ({ url, locals }) => {
  const supabase = locals.supabase as SupabaseClient;

  if (!supabase) {
    console.error("GET /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: {
          "Content-Type": "application/json",
        },
      }
    );
  }

  // --- Use Static User ID for MVP (GET) ---
  // Authentication check is removed for MVP based on instruction.
  // Uses DEFAULT_USER_ID instead of authenticated user ID.
  const userId = DEFAULT_USER_ID;

  // --- Use Zod for parameter validation (GET) ---
  const queryParams = Object.fromEntries(url.searchParams.entries());
  const validationResult = listSummariesParamsSchema.safeParse(queryParams);

  if (!validationResult.success) {
    console.error("GET /api/summaries: Query parameter validation failed:", validationResult.error);
    return new Response(
      JSON.stringify({
        message: "Invalid query parameters",
        errors: validationResult.error.format(),
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  const validatedParams = validationResult.data;

  // --- Determine Date Range ---
  let fromDate: Date | undefined;
  let toDate: Date | undefined;

  if (validatedParams.from_dt === undefined && validatedParams.to_dt === undefined) {
    const now = new Date();
    toDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59, 999);
    const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    fromDate = new Date(sevenDaysAgo.getFullYear(), sevenDaysAgo.getMonth(), sevenDaysAgo.getDate(), 0, 0, 0, 0);
    console.log(`DEBUG: Using default 7-day filter: from ${fromDate.toISOString()} to ${toDate.toISOString()}`);
  } else {
    if (validatedParams.from_dt !== undefined) {
      fromDate = new Date(validatedParams.from_dt);
    }
    if (validatedParams.to_dt !== undefined) {
      toDate = new Date(validatedParams.to_dt);
    }
    console.log(
      `DEBUG: Using provided date filters: from ${fromDate?.toISOString() || "none"} to ${toDate?.toISOString() || "none"}`
    );
  }

  const dbSortBy: ListSummariesServiceParams["sortParams"]["by"] =
    validatedParams.sort_by === "updated_at" ? "modified_at" : "created_at";
  const sortOrder: ListSummariesServiceParams["sortParams"]["order"] = validatedParams.sort_order;

  try {
    const summaryService = new SummaryService(supabase);

    const serviceParams: ListSummariesServiceParams = {
      userId: userId,
      dateRange: { from: fromDate, to: toDate },
      sortParams: { by: dbSortBy, order: sortOrder },
    };

    const summariesDto: MeetingSummaryListEntryDto[] = await summaryService.listUserSummaries(serviceParams);

    return new Response(JSON.stringify(summariesDto), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });
  } catch (error) {
    console.error("Caught unexpected error in GET /api/summaries handler:", error);
    return new Response(JSON.stringify({ message: "An internal server error occurred" }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint POST /api/summaries ---
// Implements the Create New Summary endpoint.
// Uses Zod for validation and DEFAULT_USER_ID as per MVP rules for THIS endpoint.
// Authentication check is skipped as per instruction.
export const POST: APIRoute = async (context) => {
  // --- Etap 4: Pobranie klienta Supabase z context.locals ---
  const supabase: SupabaseClient = context.locals.supabase;

  if (!supabase) {
    console.error("POST /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: {
          "Content-Type": "application/json",
        },
      }
    );
  }

  let requestBody: unknown;

  try {
    requestBody = await context.request.json();
  } catch (error) {
    console.error("POST /api/summaries: Failed to parse request body as JSON:", error);
    return new Response(
      JSON.stringify({
        error: "Invalid JSON body",
      }),
      {
        status: 400,
        headers: {
          "Content-Type": "application/json",
        },
      }
    );
  }

  try {
    const validationResult = createSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error("POST /api/summaries: Input validation failed:", validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        {
          status: 400,
          headers: {
            "Content-Type": "application/json",
          },
        }
      );
    }

    const validatedData = validationResult.data;

    // --- Use DEFAULT_USER_ID ---
    // This endpoint assigns data to the DEFAULT_USER_ID as per specific MVP instruction,
    // rather than using the authenticated user's ID.
    // Authentication check is skipped.
    const userIdToAssign = DEFAULT_USER_ID;

    console.log(
      `POST /api/summaries: Validation successful for data assigned to user ID: ${userIdToAssign}. Proceeding to database insertion.`
    );

    // --- Prepare data and call Repository ---
    const dataToInsert: MeetingSummaryInsertData = {
      user_id: userIdToAssign,
      file_name: validatedData.file_name,
      transcription: validatedData.transcription,
      summary: validatedData.summary,
      llm_generated: validatedData.llm_generated,
      notes: validatedData.notes && validatedData.notes.length > 0 ? validatedData.notes : null,
      title:
        validatedData.file_name && validatedData.file_name.trim().length > 0
          ? validatedData.file_name.trim()
          : `Summary created on ${new Date().toLocaleString()}`,
    };

    const { data: newSummaryRecord, error: dbError } = await insertSummaryIntoDB(supabase, dataToInsert);

    // --- Handle Repository Response and DB Errors ---
    if (dbError) {
      console.error("POST /api/summaries: Error inserting summary into database:", dbError);
      return new Response(
        JSON.stringify({
          error: "Internal server error occurred while saving the summary.",
        }),
        {
          status: 500,
          headers: { "Content-Type": "application/json" },
        }
      );
    }

    if (!newSummaryRecord) {
      console.error("POST /api/summaries: DB insertion reported no error but returned no data.");
      return new Response(
        JSON.stringify({
          error: "Internal server error: Insertion failed unexpectedly.",
        }),
        {
          status: 500,
          headers: { "Content-Type": "application/json" },
        }
      );
    }

    console.log("POST /api/summaries: Successfully created new summary record with ID:", newSummaryRecord.id);

    const responseData: CreateSummaryResponseDTO = {
      id: newSummaryRecord.id,
      user_id: newSummaryRecord.user_id,
      file_name: newSummaryRecord.file_name,
      created_at: newSummaryRecord.created_at,
      updated_at: newSummaryRecord.modified_at,
      transcription: newSummaryRecord.transcription,
      summary: newSummaryRecord.summary,
      llm_generated: newSummaryRecord.llm_generated,
      notes: newSummaryRecord.notes,
      title: newSummaryRecord.title,
    };

    return new Response(JSON.stringify(responseData), {
      status: 201,
      headers: {
        "Content-Type": "application/json",
        Location: `/api/summaries/${responseData.id}`,
      },
    });
  } catch (error) {
    console.error("POST /api/summaries: Caught unexpected error after validation:", error);
    return new Response(
      JSON.stringify({
        error: "An internal server error occurred.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }
};

// --- Placeholder Handlers for other methods (PUT, DELETE) ---
// These methods were not part of this implementation task.

// export const PUT: APIRoute = async ({ params, request, locals }) => { /* ... */ };
// export const DELETE: APIRoute = async ({ params, locals }) => { /* ... */ };



================================================
File: .history/src/pages/api/summaries_20250421133728.ts
================================================
/* eslint-disable no-console */
// src/pages/api/summaries.ts -- Handlers for /api/summaries (GET, POST, PUT, DELETE)

import type { APIRoute, APIContext } from "astro";
import { z } from "zod"; // Import the Zod library

// Import your local SupabaseClient type alias AND the default user ID
// IMPORTANT: Using DEFAULT_USER_ID instead of auth.uid() for DB operations in this MVP!
import type { SupabaseClient } from "../../db/supabase.client";
import { DEFAULT_USER_ID } from "../../db/supabase.client"; // Import the default user ID

// Import Supabase specific types for better error handling and results
import type { PostgrestSingleResponse, PostgrestResponse } from "@supabase/supabase-js";

// Import shared DTOs and DB internal types from central types file
import type {
  MeetingSummaryListEntryDto,
  CreateSummaryRequestDTO,
  CreateSummaryResponseDTO,
  UpdateSummaryRequestDTO,
  MeetingSummaryInsertData,
  MeetingSummaryFullRow,
  MeetingSummarySelectedColumns,
  ListSummariesServiceParams,
} from "../../types"; // Adjust the path if necessary

// Import date-fns parseISO for robust date parsing and date helpers
import { parseISO, startOfDay, endOfDay } from "date-fns";

// --- Zod Schema for List Summaries Query Parameters (for GET /api/summaries) ---
const listSummariesParamsSchema = z.object({
  sort_by: z.enum(["created_at", "updated_at"]).optional().default("created_at"),
  sort_order: z.enum(["asc", "desc"]).optional().default("desc"),
  // Accept date strings (YYYY-MM-DD from input type="date") or full ISO 8601
  from_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'from_dt'.",
    }),
  to_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'to_dt'.",
    }),
});

// --- Zod Schema for Create Summary Request Body (for POST /api/summaries) ---
const createSummaryRequestSchema = z.object({
  file_name: z.string().nullable().optional(), // nullable() allows null, optional() allows undefined
  transcription: z.string().min(1, { message: "Transcription cannot be empty." }),
  summary: z
    .string()
    .min(1, { message: "Summary cannot be empty." })
    .max(500, { message: "Summary cannot exceed 500 characters." }),
  llm_generated: z.boolean({ required_error: "Field 'llm_generated' is required and must be a boolean." }),
  notes: z
    .string()
    .nullable()
    .optional()
    .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
});

// --- Zod Schema for Update Summary Request Body (for PUT /api/summaries/{id}) ---
// Allows partial updates
const updateSummaryRequestSchema = z
  .object({
    file_name: z.string().nullable().optional(),
    transcription: z.string().min(1, { message: "Transcription cannot be empty." }).optional(),
    summary: z
      .string()
      .min(1, { message: "Summary cannot be empty." })
      .max(500, { message: "Summary cannot exceed 500 characters." })
      .optional(),
    llm_generated: z.boolean().optional(),
    notes: z
      .string()
      .nullable()
      .optional()
      .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
  })
  .partial(); // Make all fields optional at the top level

// --- SummaryService Class (Central logic for DB interaction) ---
// IMPORTANT: In this MVP version, this service uses DEFAULT_USER_ID for DB operations
// instead of relying on auth.uid() via RLS. This is INSECURE and for MVP ONLY.
class SummaryService {
  constructor(private supabase: SupabaseClient) {}

  // Method to list summaries for the DEFAULT_USER_ID
  async listDefaultUserSummaries(params: ListSummariesServiceParams): Promise<MeetingSummaryListEntryDto[]> {
    // userId parameter is included for type compatibility but ignored in this MVP implementation
    // as we are hardcoding DEFAULT_USER_ID.
    const { dateRange, sortParams } = params;
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID (MVP ONLY).`
    );

    try {
      // Select specific columns for the list view
      let query = this.supabase.from("meeting_summaries").select("id, title, file_name, created_at, modified_at");

      // Explicitly filter by DEFAULT_USER_ID, overriding standard RLS based on auth.uid()
      query = query.eq("user_id", DEFAULT_USER_ID);

      if (dateRange.from) {
        // Use >= for 'from' date (start of the day)
        query = query.gte("created_at", startOfDay(dateRange.from).toISOString());
      }
      if (dateRange.to) {
        // Use <= for 'to' date (end of the day)
        query = query.lte("created_at", endOfDay(dateRange.to).toISOString());
      }

      // Map API sort_by terms to DB column names
      const dbSortBy = sortParams.by === "updated_at" ? "modified_at" : "created_at";

      // Apply sorting
      query = query.order(dbSortBy, { ascending: sortParams.order === "asc" });

      // Execute the query
      const result: PostgrestResponse<MeetingSummarySelectedColumns> = await query;
      const { data, error } = result;

      if (error) {
        console.error("Database error fetching summaries for DEFAULT user", DEFAULT_USER_ID, ":", error);
        // Even with DEFAULT_USER_ID, RLS might still be active on the table!
        // If RLS is active and configured to check auth.uid(), this query might fail with 42501
        // because auth.uid() will be null or different from DEFAULT_USER_ID.
        // For this MVP phase using DEFAULT_USER_ID, you might need RLS on meeting_summaries
        // temporarily disabled during local testing, or modified to allow SELECT if user_id = DEFAULT_USER_ID
        // or auth.uid() is null/different. This is a conflict in MVP rules.
        // Assuming for this MVP, RLS is permissive enough for DEFAULT_USER_ID queries *or* temporarily disabled.
        if ((error as any).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          // Re-throw as 500, hiding specific RLS error
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summaries from database.");
      }

      if (!data) {
        console.warn("GET /api/summaries (DEFAULT_USER): Select query returned no data and no error.");
        return []; // Return empty array if no data
      }

      // Map DB rows to frontend DTOs
      const summariesDto: MeetingSummaryListEntryDto[] = data.map((row) => ({
        id: row.id,
        title: row.title,
        file_name: row.file_name,
        created_at: row.created_at,
        updated_at: row.modified_at, // Map DB modified_at to API updated_at
      }));

      return summariesDto;
    } catch (error) {
      console.error("Error in SummaryService.listDefaultUserSummaries:", error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to get details of a single summary for the DEFAULT_USER_ID
  async getDefaultUserSummaryDetails(id: string): Promise<MeetingSummaryDetailsDto | null> {
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID for details (MVP ONLY).`
    );
    try {
      // Select all relevant columns (excluding user_id as per DTO)
      const query = this.supabase
        .from("meeting_summaries")
        .select("id, title, file_name, created_at, modified_at, transcription, summary, llm_generated, notes")
        .eq("id", id)
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Use single() for one expected row

      const { data, error } = await query;

      if (error && error.code === "PGRST116") {
        // Supabase specific error code for "no rows found"
        console.warn(`Summary not found for ID ${id} or not owned by DEFAULT user ${DEFAULT_USER_ID}.`);
        return null; // Return null for 404 case
      } else if (error) {
        console.error(
          `Database error fetching summary details for ID ${id} and DEFAULT user ${DEFAULT_USER_ID}:`,
          error
        );
        if ((error as any).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summary details from database.");
      }

      if (!data) {
        console.warn(`GET /api/summaries/${id} (DEFAULT_USER): Single query returned no data and no error.`);
        return null; // Should be caught by PGRST116 above, but safety check
      }

      // Map DB row to frontend DTO
      const summaryDto: MeetingSummaryDetailsDto = {
        id: data.id,
        title: data.title,
        file_name: data.file_name,
        created_at: data.created_at,
        updated_at: data.modified_at, // Map DB modified_at to API updated_at
        transcription: data.transcription,
        summary: data.summary,
        llm_generated: data.llm_generated,
        notes: data.notes,
      };

      return summaryDto;
    } catch (error) {
      console.error(`Error in SummaryService.getDefaultUserSummaryDetails for ID ${id}:`, error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to create a new summary for the DEFAULT_USER_ID
  async createDefaultUserSummary(data: CreateSummaryRequestDTO): Promise<MeetingSummaryFullRow> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for creation (MVP ONLY).`);
    // Prepare data for insertion, explicitly setting user_id to DEFAULT_USER_ID
    const dataToInsert: MeetingSummaryInsertData = {
      user_id: DEFAULT_USER_ID, // Assign to DEFAULT user
      file_name: data.file_name,
      transcription: data.transcription,
      summary: data.summary,
      llm_generated: data.llm_generated,
      notes: data.notes, // notes can be string or null from validation
      title:
        data.file_name && data.file_name.trim().length > 0
          ? data.file_name.trim()
          : data.transcription.trim().substring(0, 50) + (data.transcription.trim().length > 50 ? "..." : ""), // Generate title
    };

    console.log("Attempting to insert data into DB for DEFAULT user:", dataToInsert);
    try {
      // Execute the insert query
      // If RLS insert policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .insert([dataToInsert]) // Insert the prepared data
        .select() // Select the inserted row
        .single(); // Expect a single row

      if (result.error) {
        console.error("Database insertion failed for DEFAULT user:", result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Insert for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows insert for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to save summary to database.");
      }

      if (!result.data) {
        console.error("SummaryService.createDefaultUserSummary: Insert returned no error but no data.");
        throw new Error("Database insertion failed unexpectedly.");
      }

      console.log("Database insertion successful for DEFAULT user. New summary ID:", result.data.id);
      return result.data;
    } catch (error) {
      console.error("Error in SummaryService.createDefaultUserSummary:", error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to update an existing summary for the DEFAULT_USER_ID
  async updateDefaultUserSummary(id: string, data: UpdateSummaryRequestDTO): Promise<MeetingSummaryFullRow> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for update (MVP ONLY).`);
    console.log(`Attempting to update summary ${id} for DEFAULT user with data:`, data);
    try {
      // Execute the update query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS update policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .update(data) // Update with the provided data
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .select() // Select the updated row
        .single(); // Expect a single row

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows updated"
        console.warn(`Update attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        // Return null or throw specific error for handler to return 404
        const notFoundError = new Error(`Summary with ID ${id} not found or access denied.`);
        (notFoundError as any).status = 404; // Tag error for handler
        throw notFoundError;
      } else if (result.error) {
        console.error(`Database update failed for ID ${id} and DEFAULT user:`, result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Update for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows update for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to update summary in database.");
      }

      if (!result.data) {
        console.error(`SummaryService.updateDefaultUserSummary: Update returned no error but no data for ID ${id}.`);
        throw new Error("Database update failed unexpectedly.");
      }

      console.log(`Database update successful for ID ${id} and DEFAULT user.`);
      return result.data;
    } catch (error) {
      console.error(`Error in SummaryService.updateDefaultUserSummary for ID ${id}:`, error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to delete an existing summary for the DEFAULT_USER_ID
  async deleteDefaultUserSummary(id: string): Promise<void> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for delete (MVP ONLY).`);
    console.log(`Attempting to delete summary ${id} for DEFAULT user ${DEFAULT_USER_ID}`);
    try {
      // Execute the delete query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS delete policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<null> = await this.supabase
        .from("meeting_summaries")
        .delete() // Perform deletion
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Expect a single row deleted or none

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows found"
        console.warn(`Delete attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        const notFoundError = new Error(`Summary with ID ${id} not found or access denied.`);
        (notFoundError as any).status = 404; // Tag error for handler
        throw notFoundError;
      } else if (result.error) {
        console.error(`Database delete failed for ID ${id} and DEFAULT user:`, result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Delete for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows delete for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to delete summary from database.");
      }

      // Success! result.data will be null for delete single().
      console.log(`Database delete successful for ID ${id} and DEFAULT user.`);
      return; // Return void on success
    } catch (error) {
      console.error(`Error in SummaryService.deleteDefaultUserSummary for ID ${id}:`, error);
      throw error; // Re-throw to be caught by API handler
    }
  }
}

// --- Handler endpoint GET /api/summaries ---
// Implements the List Summaries endpoint.
// Authentication check is SKIPPED. Data filtered by DEFAULT_USER_ID.
export const GET: APIRoute = async ({ url, locals }) => {
  const supabase = locals.supabase as SupabaseClient;

  // --- Get Supabase client from context.locals ---
  if (!supabase) {
    console.error("GET /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "GET /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data filtered by DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used

  // --- Use Zod for parameter validation (GET) ---
  const queryParams = Object.fromEntries(url.searchParams.entries());
  const validationResult = listSummariesParamsSchema.safeParse(queryParams);

  if (!validationResult.success) {
    console.error("GET /api/summaries: Query parameter validation failed:", validationResult.error);
    return new Response(
      JSON.stringify({
        message: "Invalid query parameters",
        errors: validationResult.error.format(),
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  const validatedParams = validationResult.data;

  // --- Determine Date Range ---
  let fromDate: Date | undefined;
  let toDate: Date | undefined;

  if (validatedParams.from_dt === undefined && validatedParams.to_dt === undefined) {
    // Default to last 7 days
    const now = new Date();
    toDate = endOfDay(now); // End of today
    fromDate = startOfDay(new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)); // Start of 7 days ago
    console.log(`DEBUG: Using default 7-day filter: from ${fromDate.toISOString()} to ${toDate.toISOString()}`);
  } else {
    if (validatedParams.from_dt !== undefined) {
      // Parse the date string provided
      fromDate = parseISO(validatedParams.from_dt);
      if (isNaN(fromDate.getTime())) fromDate = undefined; // Handle potential parse failure after refine
    }
    if (validatedParams.to_dt !== undefined) {
      // Parse the date string provided
      toDate = parseISO(validatedParams.to_dt);
      if (isNaN(toDate.getTime())) toDate = undefined; // Handle potential parse failure after refine
    }
    console.log(
      `DEBUG: Using provided date filters: from ${fromDate?.toISOString() || "none"} to ${toDate?.toISOString() || "none"}`
    );
  }

  // Map API sort_by terms to DB column names for the Service layer
  const dbSortBy: ListSummariesServiceParams["sortParams"]["by"] =
    validatedParams.sort_by === "updated_at" ? "modified_at" : "created_at";
  const sortOrder: ListSummariesServiceParams["sortParams"]["order"] = validatedParams.sort_order;

  try {
    const summaryService = new SummaryService(supabase);

    const serviceParams: ListSummariesServiceParams = {
      userId: DEFAULT_USER_ID, // Pass DEFAULT user ID to service
      dateRange: { from: fromDate, to: toDate },
      sortParams: { by: dbSortBy, order: sortOrder },
    };

    // Use the specific service method for the default user
    const summariesDto: MeetingSummaryListEntryDto[] = await summaryService.listDefaultUserSummaries(serviceParams);

    return new Response(JSON.stringify(summariesDto), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });
  } catch (error) {
    console.error("Caught error in GET /api/summaries handler (DEFAULT_USER):", error);
    if ((error as any).status === 404 || (error as any).status === 403) {
      return new Response(JSON.stringify({ message: (error as any).message || "Access Denied/Not Found" }), {
        status: (error as any).status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ message: "An internal server error occurred" }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint POST /api/summaries ---
// Implements the Create New Summary endpoint.
// Authentication check is SKIPPED. Data assigned to DEFAULT_USER_ID.
export const POST: APIRoute = async ({ request, locals }) => {
  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("POST /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "POST /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data assigned to DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;

  try {
    requestBody = await request.json();
  } catch (error) {
    console.error("POST /api/summaries: Failed to parse request body as JSON:", error);
    return new Response(
      JSON.stringify({
        error: "Invalid JSON body",
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  try {
    const validationResult = createSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error("POST /api/summaries: Input validation failed:", validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        {
          status: 400,
          headers: { "Content-Type": "application/json" },
        }
      );
    }

    const validatedData = validationResult.data;

    // --- Call Service to insert data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass validated data to service. Service will use DEFAULT_USER_ID internally.
    const newSummaryRecord: MeetingSummaryFullRow = await summaryService.createDefaultUserSummary(validatedData);

    console.log(
      "POST /api/summaries: Successfully created new summary record with ID:",
      newSummaryRecord.id,
      "for DEFAULT user."
    );

    // Map DB row to frontend DTO
    const responseData: CreateSummaryResponseDTO = {
      id: newSummaryRecord.id,
      user_id: newSummaryRecord.user_id,
      file_name: newSummaryRecord.file_name,
      created_at: newSummaryRecord.created_at,
      updated_at: newSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: newSummaryRecord.transcription,
      summary: newSummaryRecord.summary,
      llm_generated: newSummaryRecord.llm_generated,
      notes: newSummaryRecord.notes,
      title: newSummaryRecord.title,
    };

    return new Response(JSON.stringify(responseData), {
      status: 201, // 201 Created
      headers: {
        "Content-Type": "application/json",
        Location: `/api/summaries/${responseData.id}`, // HATEOAS principle
      },
    });
  } catch (error) {
    console.error("Caught error in POST /api/summaries handler (DEFAULT_USER):", error);
    if ((error as any).status === 404 || (error as any).status === 403) {
      return new Response(JSON.stringify({ message: (error as any).message || "Access Denied/Not Found" }), {
        status: (error as any).status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ error: "An internal server error occurred while saving the summary." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint PUT /api/summaries/{id} ---
// Implements the Update Existing Summary endpoint.
// Authentication check is SKIPPED. Updates summary for DEFAULT_USER_ID.
export const PUT: APIRoute = async ({ params, request, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("PUT /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("PUT /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `PUT /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Updates summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;
  try {
    // --- Parse Request Body ---
    requestBody = await request.json();
  } catch (error) {
    console.error(`PUT /api/summaries/${summaryId}: Failed to parse request body as JSON:`, error);
    return new Response(JSON.stringify({ error: "Invalid JSON body" }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  try {
    // --- Input Validation (zod) ---
    const validationResult = updateSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error(`PUT /api/summaries/${summaryId}: Input validation failed:`, validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }

    const validatedData: UpdateSummaryRequestDTO = validationResult.data;

    // Ensure there's at least one field being updated
    if (Object.keys(validatedData).length === 0) {
      console.warn(`PUT /api/summaries/${summaryId}: Request body is empty, no fields to update.`);
      return new Response(JSON.stringify({ error: "Request body must contain fields to update." }), {
        status: 400,
        headers: { "Content-Type": "application/json" },
      });
    }

    // --- Call Service to update data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass updated data and summaryId to service. Service will use DEFAULT_USER_ID internally.
    const updatedSummaryRecord: MeetingSummaryFullRow = await summaryService.updateDefaultUserSummary(
      summaryId,
      validatedData
    );

    console.log(`PUT /api/summaries/${summaryId}: Successfully updated summary record for DEFAULT user.`);

    // Map DB row to frontend DTO (MeetingSummaryDetailsDto for consistency with GET details)
    const responseData: MeetingSummaryDetailsDto = {
      id: updatedSummaryRecord.id,
      title: updatedSummaryRecord.title, // Include title as it's in the DB row
      file_name: updatedSummaryRecord.file_name,
      created_at: updatedSummaryRecord.created_at,
      updated_at: updatedSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: updatedSummaryRecord.transcription,
      summary: updatedSummaryRecord.summary,
      llm_generated: updatedSummaryRecord.llm_generated,
      notes: updatedSummaryRecord.notes,
      // user_id is omitted from this DTO
    };

    return new Response(JSON.stringify(responseData), {
      status: 200, // 200 OK
      headers: { "Content-Type": "application/json" },
    });
  } catch (error) {
    console.error(`PUT /api/summaries/${summaryId}: Caught error after validation (DEFAULT_USER):`, error);
    if ((error as any).status === 404) {
      return new Response(
        JSON.stringify({
          message: (error as any).message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    if ((error as any).status === 403) {
      // This might happen if RLS is still partially active
      return new Response(
        JSON.stringify({
          message:
            (error as any).message ||
            `Permission denied for summary ID ${summaryId}. Ensure RLS allows access for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while updating summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

// --- Handler endpoint DELETE /api/summaries/{id} ---
// Implements the Delete Summary endpoint.
// Authentication check is SKIPPED. Deletes summary for DEFAULT_USER_ID.
export const DELETE: APIRoute = async ({ params, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("DELETE /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("DELETE /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `DELETE /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Deletes summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  try {
    // --- Call Service to delete data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass summaryId to service. Service will use DEFAULT_USER_ID internally.
    await summaryService.deleteDefaultUserSummary(summaryId);

    console.log(`DELETE /api/summaries/${summaryId}: Successfully deleted summary record for DEFAULT user.`);

    return new Response(null, {
      // 204 No Content
      status: 204,
      // No body for 204 response
    });
  } catch (error) {
    console.error(`DELETE /api/summaries/${summaryId}: Caught error (DEFAULT_USER):`, error);
    if ((error as any).status === 404) {
      return new Response(
        JSON.stringify({
          message: (error as any).message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    if ((error as any).status === 403) {
      // This might happen if RLS is still partially active
      return new Response(
        JSON.stringify({
          message:
            (error as any).message ||
            `Permission denied for summary ID ${summaryId}. Ensure RLS allows delete for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while deleting summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

export const prerender = false; // Needed for server routes



================================================
File: .history/src/pages/api/summaries_20250421133822.ts
================================================
/* eslint-disable no-console */
// src/pages/api/summaries.ts -- Handlers for /api/summaries (GET, POST, PUT, DELETE)

import type { APIRoute, APIContext } from "astro";
import { z } from "zod"; // Import the Zod library

// Import your local SupabaseClient type alias AND the default user ID
// IMPORTANT: Using DEFAULT_USER_ID instead of auth.uid() for DB operations in this MVP!
import type { SupabaseClient } from "../../db/supabase.client";
import { DEFAULT_USER_ID } from "../../db/supabase.client"; // Import the default user ID

// Import Supabase specific types for better error handling and results
import type { PostgrestSingleResponse, PostgrestResponse } from "@supabase/supabase-js";

// Import shared DTOs and DB internal types from central types file
import type {
  MeetingSummaryListEntryDto,
  CreateSummaryRequestDTO,
  CreateSummaryResponseDTO,
  UpdateSummaryRequestDTO,
  MeetingSummaryInsertData,
  MeetingSummaryFullRow,
  MeetingSummarySelectedColumns,
  ListSummariesServiceParams,
} from "../../types"; // Adjust the path if necessary

// Import date-fns parseISO for robust date parsing and date helpers
import { parseISO, startOfDay, endOfDay } from "date-fns";

// --- Zod Schema for List Summaries Query Parameters (for GET /api/summaries) ---
const listSummariesParamsSchema = z.object({
  sort_by: z.enum(["created_at", "updated_at"]).optional().default("created_at"),
  sort_order: z.enum(["asc", "desc"]).optional().default("desc"),
  // Accept date strings (YYYY-MM-DD from input type="date") or full ISO 8601
  from_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'from_dt'.",
    }),
  to_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'to_dt'.",
    }),
});

// --- Zod Schema for Create Summary Request Body (for POST /api/summaries) ---
const createSummaryRequestSchema = z.object({
  file_name: z.string().nullable().optional(), // nullable() allows null, optional() allows undefined
  transcription: z.string().min(1, { message: "Transcription cannot be empty." }),
  summary: z
    .string()
    .min(1, { message: "Summary cannot be empty." })
    .max(500, { message: "Summary cannot exceed 500 characters." }),
  llm_generated: z.boolean({ required_error: "Field 'llm_generated' is required and must be a boolean." }),
  notes: z
    .string()
    .nullable()
    .optional()
    .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
});

// --- Zod Schema for Update Summary Request Body (for PUT /api/summaries/{id}) ---
// Allows partial updates
const updateSummaryRequestSchema = z
  .object({
    file_name: z.string().nullable().optional(),
    transcription: z.string().min(1, { message: "Transcription cannot be empty." }).optional(),
    summary: z
      .string()
      .min(1, { message: "Summary cannot be empty." })
      .max(500, { message: "Summary cannot exceed 500 characters." })
      .optional(),
    llm_generated: z.boolean().optional(),
    notes: z
      .string()
      .nullable()
      .optional()
      .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
  })
  .partial(); // Make all fields optional at the top level

// --- SummaryService Class (Central logic for DB interaction) ---
// IMPORTANT: In this MVP version, this service uses DEFAULT_USER_ID for DB operations
// instead of relying on auth.uid() via RLS. This is INSECURE and for MVP ONLY.
class SummaryService {
  constructor(private supabase: SupabaseClient) {}

  // Method to list summaries for the DEFAULT_USER_ID
  async listDefaultUserSummaries(params: ListSummariesServiceParams): Promise<MeetingSummaryListEntryDto[]> {
    // userId parameter is included for type compatibility but ignored in this MVP implementation
    // as we are hardcoding DEFAULT_USER_ID.
    const { dateRange, sortParams } = params;
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID (MVP ONLY).`
    );

    try {
      // Select specific columns for the list view
      let query = this.supabase.from("meeting_summaries").select("id, title, file_name, created_at, modified_at");

      // Explicitly filter by DEFAULT_USER_ID, overriding standard RLS based on auth.uid()
      query = query.eq("user_id", DEFAULT_USER_ID);

      if (dateRange.from) {
        // Use >= for 'from' date (start of the day)
        query = query.gte("created_at", startOfDay(dateRange.from).toISOString());
      }
      if (dateRange.to) {
        // Use <= for 'to' date (end of the day)
        query = query.lte("created_at", endOfDay(dateRange.to).toISOString());
      }

      // Map API sort_by terms to DB column names
      const dbSortBy = sortParams.by === "updated_at" ? "modified_at" : "created_at";

      // Apply sorting
      query = query.order(dbSortBy, { ascending: sortParams.order === "asc" });

      // Execute the query
      const result: PostgrestResponse<MeetingSummarySelectedColumns> = await query;
      const { data, error } = result;

      if (error) {
        console.error("Database error fetching summaries for DEFAULT user", DEFAULT_USER_ID, ":", error);
        // Even with DEFAULT_USER_ID, RLS might still be active on the table!
        // If RLS is active and configured to check auth.uid(), this query might fail with 42501
        // because auth.uid() will be null or different from DEFAULT_USER_ID.
        // For this MVP phase using DEFAULT_USER_ID, you might need RLS on meeting_summaries
        // temporarily disabled during local testing, or modified to allow SELECT if user_id = DEFAULT_USER_ID
        // or auth.uid() is null/different. This is a conflict in MVP rules.
        // Assuming for this MVP, RLS is permissive enough for DEFAULT_USER_ID queries *or* temporarily disabled.
        if ((error as any).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          // Re-throw as 500, hiding specific RLS error
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summaries from database.");
      }

      if (!data) {
        console.warn("GET /api/summaries (DEFAULT_USER): Select query returned no data and no error.");
        return []; // Return empty array if no data
      }

      // Map DB rows to frontend DTOs
      const summariesDto: MeetingSummaryListEntryDto[] = data.map((row) => ({
        id: row.id,
        title: row.title,
        file_name: row.file_name,
        created_at: row.created_at,
        updated_at: row.modified_at, // Map DB modified_at to API updated_at
      }));

      return summariesDto;
    } catch (error) {
      console.error("Error in SummaryService.listDefaultUserSummaries:", error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to get details of a single summary for the DEFAULT_USER_ID
  async getDefaultUserSummaryDetails(id: string): Promise<MeetingSummaryDetailsDto | null> {
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID for details (MVP ONLY).`
    );
    try {
      // Select all relevant columns (excluding user_id as per DTO)
      const query = this.supabase
        .from("meeting_summaries")
        .select("id, title, file_name, created_at, modified_at, transcription, summary, llm_generated, notes")
        .eq("id", id)
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Use single() for one expected row

      const { data, error } = await query;

      if (error && error.code === "PGRST116") {
        // Supabase specific error code for "no rows found"
        console.warn(`Summary not found for ID ${id} or not owned by DEFAULT user ${DEFAULT_USER_ID}.`);
        return null; // Return null for 404 case
      } else if (error) {
        console.error(
          `Database error fetching summary details for ID ${id} and DEFAULT user ${DEFAULT_USER_ID}:`,
          error
        );
        if ((error as any).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summary details from database.");
      }

      if (!data) {
        console.warn(`GET /api/summaries/${id} (DEFAULT_USER): Single query returned no data and no error.`);
        return null; // Should be caught by PGRST116 above, but safety check
      }

      // Map DB row to frontend DTO
      const summaryDto: MeetingSummaryDetailsDto = {
        id: data.id,
        title: data.title,
        file_name: data.file_name,
        created_at: data.created_at,
        updated_at: data.modified_at, // Map DB modified_at to API updated_at
        transcription: data.transcription,
        summary: data.summary,
        llm_generated: data.llm_generated,
        notes: data.notes,
      };

      return summaryDto;
    } catch (error) {
      console.error(`Error in SummaryService.getDefaultUserSummaryDetails for ID ${id}:`, error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to create a new summary for the DEFAULT_USER_ID
  async createDefaultUserSummary(data: CreateSummaryRequestDTO): Promise<MeetingSummaryFullRow> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for creation (MVP ONLY).`);
    // Prepare data for insertion, explicitly setting user_id to DEFAULT_USER_ID
    const dataToInsert: MeetingSummaryInsertData = {
      user_id: DEFAULT_USER_ID, // Assign to DEFAULT user
      file_name: data.file_name,
      transcription: data.transcription,
      summary: data.summary,
      llm_generated: data.llm_generated,
      notes: data.notes, // notes can be string or null from validation
      title:
        data.file_name && data.file_name.trim().length > 0
          ? data.file_name.trim()
          : data.transcription.trim().substring(0, 50) + (data.transcription.trim().length > 50 ? "..." : ""), // Generate title
    };

    console.log("Attempting to insert data into DB for DEFAULT user:", dataToInsert);
    try {
      // Execute the insert query
      // If RLS insert policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .insert([dataToInsert]) // Insert the prepared data
        .select() // Select the inserted row
        .single(); // Expect a single row

      if (result.error) {
        console.error("Database insertion failed for DEFAULT user:", result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Insert for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows insert for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to save summary to database.");
      }

      if (!result.data) {
        console.error("SummaryService.createDefaultUserSummary: Insert returned no error but no data.");
        throw new Error("Database insertion failed unexpectedly.");
      }

      console.log("Database insertion successful for DEFAULT user. New summary ID:", result.data.id);
      return result.data;
    } catch (error) {
      console.error("Error in SummaryService.createDefaultUserSummary:", error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to update an existing summary for the DEFAULT_USER_ID
  async updateDefaultUserSummary(id: string, data: UpdateSummaryRequestDTO): Promise<MeetingSummaryFullRow> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for update (MVP ONLY).`);
    console.log(`Attempting to update summary ${id} for DEFAULT user with data:`, data);
    try {
      // Execute the update query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS update policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .update(data) // Update with the provided data
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .select() // Select the updated row
        .single(); // Expect a single row

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows updated"
        console.warn(`Update attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        // Return null or throw specific error for handler to return 404
        const notFoundError = new Error(`Summary with ID ${id} not found or access denied.`);
        (notFoundError as any).status = 404; // Tag error for handler
        throw notFoundError;
      } else if (result.error) {
        console.error(`Database update failed for ID ${id} and DEFAULT user:`, result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Update for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows update for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to update summary in database.");
      }

      if (!result.data) {
        console.error(`SummaryService.updateDefaultUserSummary: Update returned no error but no data for ID ${id}.`);
        throw new Error("Database update failed unexpectedly.");
      }

      console.log(`Database update successful for ID ${id} and DEFAULT user.`);
      return result.data;
    } catch (error) {
      console.error(`Error in SummaryService.updateDefaultUserSummary for ID ${id}:`, error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to delete an existing summary for the DEFAULT_USER_ID
  async deleteDefaultUserSummary(id: string): Promise<void> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for delete (MVP ONLY).`);
    console.log(`Attempting to delete summary ${id} for DEFAULT user ${DEFAULT_USER_ID}`);
    try {
      // Execute the delete query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS delete policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<null> = await this.supabase
        .from("meeting_summaries")
        .delete() // Perform deletion
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Expect a single row deleted or none

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows found"
        console.warn(`Delete attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        const notFoundError = new Error(`Summary with ID ${id} not found or access denied.`);
        (notFoundError as any).status = 404; // Tag error for handler
        throw notFoundError;
      } else if (result.error) {
        console.error(`Database delete failed for ID ${id} and DEFAULT user:`, result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Delete for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows delete for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to delete summary from database.");
      }

      // Success! result.data will be null for delete single().
      console.log(`Database delete successful for ID ${id} and DEFAULT user.`);
      return; // Return void on success
    } catch (error) {
      console.error(`Error in SummaryService.deleteDefaultUserSummary for ID ${id}:`, error);
      throw error; // Re-throw to be caught by API handler
    }
  }
}

// --- Handler endpoint GET /api/summaries ---
// Implements the List Summaries endpoint.
// Authentication check is SKIPPED. Data filtered by DEFAULT_USER_ID.
export const GET: APIRoute = async ({ url, locals }) => {
  const supabase = locals.supabase as SupabaseClient;

  // --- Get Supabase client from context.locals ---
  if (!supabase) {
    console.error("GET /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "GET /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data filtered by DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used

  // --- Use Zod for parameter validation (GET) ---
  const queryParams = Object.fromEntries(url.searchParams.entries());
  const validationResult = listSummariesParamsSchema.safeParse(queryParams);

  if (!validationResult.success) {
    console.error("GET /api/summaries: Query parameter validation failed:", validationResult.error);
    return new Response(
      JSON.stringify({
        message: "Invalid query parameters",
        errors: validationResult.error.format(),
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  const validatedParams = validationResult.data;

  // --- Determine Date Range ---
  let fromDate: Date | undefined;
  let toDate: Date | undefined;

  if (validatedParams.from_dt === undefined && validatedParams.to_dt === undefined) {
    // Default to last 7 days
    const now = new Date();
    toDate = endOfDay(now); // End of today
    fromDate = startOfDay(new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)); // Start of 7 days ago
    console.log(`DEBUG: Using default 7-day filter: from ${fromDate.toISOString()} to ${toDate.toISOString()}`);
  } else {
    if (validatedParams.from_dt !== undefined) {
      // Parse the date string provided
      fromDate = parseISO(validatedParams.from_dt);
      if (isNaN(fromDate.getTime())) fromDate = undefined; // Handle potential parse failure after refine
    }
    if (validatedParams.to_dt !== undefined) {
      // Parse the date string provided
      toDate = parseISO(validatedParams.to_dt);
      if (isNaN(toDate.getTime())) toDate = undefined; // Handle potential parse failure after refine
    }
    console.log(
      `DEBUG: Using provided date filters: from ${fromDate?.toISOString() || "none"} to ${toDate?.toISOString() || "none"}`
    );
  }

  // Map API sort_by terms to DB column names for the Service layer
  const dbSortBy: ListSummariesServiceParams["sortParams"]["by"] =
    validatedParams.sort_by === "updated_at" ? "modified_at" : "created_at";
  const sortOrder: ListSummariesServiceParams["sortParams"]["order"] = validatedParams.sort_order;

  try {
    const summaryService = new SummaryService(supabase);

    const serviceParams: ListSummariesServiceParams = {
      userId: DEFAULT_USER_ID, // Pass DEFAULT user ID to service
      dateRange: { from: fromDate, to: toDate },
      sortParams: { by: dbSortBy, order: sortOrder },
    };

    // Use the specific service method for the default user
    const summariesDto: MeetingSummaryListEntryDto[] = await summaryService.listDefaultUserSummaries(serviceParams);

    return new Response(JSON.stringify(summariesDto), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });
  } catch (error) {
    console.error("Caught error in GET /api/summaries handler (DEFAULT_USER):", error);
    if ((error as any).status === 404 || (error as any).status === 403) {
      return new Response(JSON.stringify({ message: (error as any).message || "Access Denied/Not Found" }), {
        status: (error as any).status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ message: "An internal server error occurred" }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint POST /api/summaries ---
// Implements the Create New Summary endpoint.
// Authentication check is SKIPPED. Data assigned to DEFAULT_USER_ID.
export const POST: APIRoute = async ({ request, locals }) => {
  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("POST /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "POST /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data assigned to DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;

  try {
    requestBody = await request.json();
  } catch (error) {
    console.error("POST /api/summaries: Failed to parse request body as JSON:", error);
    return new Response(
      JSON.stringify({
        error: "Invalid JSON body",
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  try {
    const validationResult = createSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error("POST /api/summaries: Input validation failed:", validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        {
          status: 400,
          headers: { "Content-Type": "application/json" },
        }
      );
    }

    const validatedData = validationResult.data;

    // --- Call Service to insert data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass validated data to service. Service will use DEFAULT_USER_ID internally.
    const newSummaryRecord: MeetingSummaryFullRow = await summaryService.createDefaultUserSummary(validatedData);

    console.log(
      "POST /api/summaries: Successfully created new summary record with ID:",
      newSummaryRecord.id,
      "for DEFAULT user."
    );

    // Map DB row to frontend DTO
    const responseData: CreateSummaryResponseDTO = {
      id: newSummaryRecord.id,
      user_id: newSummaryRecord.user_id,
      file_name: newSummaryRecord.file_name,
      created_at: newSummaryRecord.created_at,
      updated_at: newSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: newSummaryRecord.transcription,
      summary: newSummaryRecord.summary,
      llm_generated: newSummaryRecord.llm_generated,
      notes: newSummaryRecord.notes,
      title: newSummaryRecord.title,
    };

    return new Response(JSON.stringify(responseData), {
      status: 201, // 201 Created
      headers: {
        "Content-Type": "application/json",
        Location: `/api/summaries/${responseData.id}`, // HATEOAS principle
      },
    });
  } catch (error) {
    console.error("Caught error in POST /api/summaries handler (DEFAULT_USER):", error);
    if ((error as any).status === 404 || (error as any).status === 403) {
      return new Response(JSON.stringify({ message: (error as any).message || "Access Denied/Not Found" }), {
        status: (error as any).status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ error: "An internal server error occurred while saving the summary." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint PUT /api/summaries/{id} ---
// Implements the Update Existing Summary endpoint.
// Authentication check is SKIPPED. Updates summary for DEFAULT_USER_ID.
export const PUT: APIRoute = async ({ params, request, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("PUT /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("PUT /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `PUT /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Updates summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;
  try {
    // --- Parse Request Body ---
    requestBody = await request.json();
  } catch (error) {
    console.error(`PUT /api/summaries/${summaryId}: Failed to parse request body as JSON:`, error);
    return new Response(JSON.stringify({ error: "Invalid JSON body" }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  try {
    // --- Input Validation (zod) ---
    const validationResult = updateSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error(`PUT /api/summaries/${summaryId}: Input validation failed:`, validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }

    const validatedData: UpdateSummaryRequestDTO = validationResult.data;

    // Ensure there's at least one field being updated
    if (Object.keys(validatedData).length === 0) {
      console.warn(`PUT /api/summaries/${summaryId}: Request body is empty, no fields to update.`);
      return new Response(JSON.stringify({ error: "Request body must contain fields to update." }), {
        status: 400,
        headers: { "Content-Type": "application/json" },
      });
    }

    // --- Call Service to update data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass updated data and summaryId to service. Service will use DEFAULT_USER_ID internally.
    const updatedSummaryRecord: MeetingSummaryFullRow = await summaryService.updateDefaultUserSummary(
      summaryId,
      validatedData
    );

    console.log(`PUT /api/summaries/${summaryId}: Successfully updated summary record for DEFAULT user.`);

    // Map DB row to frontend DTO (MeetingSummaryDetailsDto for consistency with GET details)
    const responseData: MeetingSummaryDetailsDto = {
      id: updatedSummaryRecord.id,
      title: updatedSummaryRecord.title, // Include title as it's in the DB row
      file_name: updatedSummaryRecord.file_name,
      created_at: updatedSummaryRecord.created_at,
      updated_at: updatedSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: updatedSummaryRecord.transcription,
      summary: updatedSummaryRecord.summary,
      llm_generated: updatedSummaryRecord.llm_generated,
      notes: updatedSummaryRecord.notes,
      // user_id is omitted from this DTO
    };

    return new Response(JSON.stringify(responseData), {
      status: 200, // 200 OK
      headers: { "Content-Type": "application/json" },
    });
  } catch (error) {
    console.error(`PUT /api/summaries/${summaryId}: Caught error after validation (DEFAULT_USER):`, error);
    if ((error as any).status === 404) {
      return new Response(
        JSON.stringify({
          message: (error as any).message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    if ((error as any).status === 403) {
      // This might happen if RLS is still partially active
      return new Response(
        JSON.stringify({
          message:
            (error as any).message ||
            `Permission denied for summary ID ${summaryId}. Ensure RLS allows access for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while updating summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

// --- Handler endpoint DELETE /api/summaries/{id} ---
// Implements the Delete Summary endpoint.
// Authentication check is SKIPPED. Deletes summary for DEFAULT_USER_ID.
export const DELETE: APIRoute = async ({ params, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("DELETE /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("DELETE /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `DELETE /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Deletes summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  try {
    // --- Call Service to delete data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass summaryId to service. Service will use DEFAULT_USER_ID internally.
    await summaryService.deleteDefaultUserSummary(summaryId);

    console.log(`DELETE /api/summaries/${summaryId}: Successfully deleted summary record for DEFAULT user.`);

    return new Response(null, {
      // 204 No Content
      status: 204,
      // No body for 204 response
    });
  } catch (error) {
    console.error(`DELETE /api/summaries/${summaryId}: Caught error (DEFAULT_USER):`, error);
    if ((error as any).status === 404) {
      return new Response(
        JSON.stringify({
          message: (error as any).message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    if ((error as any).status === 403) {
      // This might happen if RLS is still partially active
      return new Response(
        JSON.stringify({
          message:
            (error as any).message ||
            `Permission denied for summary ID ${summaryId}. Ensure RLS allows delete for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while deleting summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

export const prerender = false; // Needed for server routes



================================================
File: .history/src/pages/api/summaries_20250421133827.ts
================================================
/* eslint-disable no-console */
// src/pages/api/summaries.ts -- Handlers for /api/summaries (GET, POST, PUT, DELETE)

import type { APIRoute } from "astro";
import { z } from "zod"; // Import the Zod library

// Import your local SupabaseClient type alias AND the default user ID
// IMPORTANT: Using DEFAULT_USER_ID instead of auth.uid() for DB operations in this MVP!
import type { SupabaseClient } from "../../db/supabase.client";
import { DEFAULT_USER_ID } from "../../db/supabase.client"; // Import the default user ID

// Import Supabase specific types for better error handling and results
import type { PostgrestSingleResponse, PostgrestResponse } from "@supabase/supabase-js";

// Import shared DTOs and DB internal types from central types file
import type {
  MeetingSummaryListEntryDto,
  CreateSummaryRequestDTO,
  CreateSummaryResponseDTO,
  UpdateSummaryRequestDTO,
  MeetingSummaryInsertData,
  MeetingSummaryFullRow,
  MeetingSummarySelectedColumns,
  ListSummariesServiceParams,
} from "../../types"; // Adjust the path if necessary

// Import date-fns parseISO for robust date parsing and date helpers
import { parseISO, startOfDay, endOfDay } from "date-fns";

// --- Zod Schema for List Summaries Query Parameters (for GET /api/summaries) ---
const listSummariesParamsSchema = z.object({
  sort_by: z.enum(["created_at", "updated_at"]).optional().default("created_at"),
  sort_order: z.enum(["asc", "desc"]).optional().default("desc"),
  // Accept date strings (YYYY-MM-DD from input type="date") or full ISO 8601
  from_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'from_dt'.",
    }),
  to_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'to_dt'.",
    }),
});

// --- Zod Schema for Create Summary Request Body (for POST /api/summaries) ---
const createSummaryRequestSchema = z.object({
  file_name: z.string().nullable().optional(), // nullable() allows null, optional() allows undefined
  transcription: z.string().min(1, { message: "Transcription cannot be empty." }),
  summary: z
    .string()
    .min(1, { message: "Summary cannot be empty." })
    .max(500, { message: "Summary cannot exceed 500 characters." }),
  llm_generated: z.boolean({ required_error: "Field 'llm_generated' is required and must be a boolean." }),
  notes: z
    .string()
    .nullable()
    .optional()
    .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
});

// --- Zod Schema for Update Summary Request Body (for PUT /api/summaries/{id}) ---
// Allows partial updates
const updateSummaryRequestSchema = z
  .object({
    file_name: z.string().nullable().optional(),
    transcription: z.string().min(1, { message: "Transcription cannot be empty." }).optional(),
    summary: z
      .string()
      .min(1, { message: "Summary cannot be empty." })
      .max(500, { message: "Summary cannot exceed 500 characters." })
      .optional(),
    llm_generated: z.boolean().optional(),
    notes: z
      .string()
      .nullable()
      .optional()
      .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
  })
  .partial(); // Make all fields optional at the top level

// --- SummaryService Class (Central logic for DB interaction) ---
// IMPORTANT: In this MVP version, this service uses DEFAULT_USER_ID for DB operations
// instead of relying on auth.uid() via RLS. This is INSECURE and for MVP ONLY.
class SummaryService {
  constructor(private supabase: SupabaseClient) {}

  // Method to list summaries for the DEFAULT_USER_ID
  async listDefaultUserSummaries(params: ListSummariesServiceParams): Promise<MeetingSummaryListEntryDto[]> {
    // userId parameter is included for type compatibility but ignored in this MVP implementation
    // as we are hardcoding DEFAULT_USER_ID.
    const { dateRange, sortParams } = params;
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID (MVP ONLY).`
    );

    try {
      // Select specific columns for the list view
      let query = this.supabase.from("meeting_summaries").select("id, title, file_name, created_at, modified_at");

      // Explicitly filter by DEFAULT_USER_ID, overriding standard RLS based on auth.uid()
      query = query.eq("user_id", DEFAULT_USER_ID);

      if (dateRange.from) {
        // Use >= for 'from' date (start of the day)
        query = query.gte("created_at", startOfDay(dateRange.from).toISOString());
      }
      if (dateRange.to) {
        // Use <= for 'to' date (end of the day)
        query = query.lte("created_at", endOfDay(dateRange.to).toISOString());
      }

      // Map API sort_by terms to DB column names
      const dbSortBy = sortParams.by === "updated_at" ? "modified_at" : "created_at";

      // Apply sorting
      query = query.order(dbSortBy, { ascending: sortParams.order === "asc" });

      // Execute the query
      const result: PostgrestResponse<MeetingSummarySelectedColumns> = await query;
      const { data, error } = result;

      if (error) {
        console.error("Database error fetching summaries for DEFAULT user", DEFAULT_USER_ID, ":", error);
        // Even with DEFAULT_USER_ID, RLS might still be active on the table!
        // If RLS is active and configured to check auth.uid(), this query might fail with 42501
        // because auth.uid() will be null or different from DEFAULT_USER_ID.
        // For this MVP phase using DEFAULT_USER_ID, you might need RLS on meeting_summaries
        // temporarily disabled during local testing, or modified to allow SELECT if user_id = DEFAULT_USER_ID
        // or auth.uid() is null/different. This is a conflict in MVP rules.
        // Assuming for this MVP, RLS is permissive enough for DEFAULT_USER_ID queries *or* temporarily disabled.
        if ((error as any).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          // Re-throw as 500, hiding specific RLS error
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summaries from database.");
      }

      if (!data) {
        console.warn("GET /api/summaries (DEFAULT_USER): Select query returned no data and no error.");
        return []; // Return empty array if no data
      }

      // Map DB rows to frontend DTOs
      const summariesDto: MeetingSummaryListEntryDto[] = data.map((row) => ({
        id: row.id,
        title: row.title,
        file_name: row.file_name,
        created_at: row.created_at,
        updated_at: row.modified_at, // Map DB modified_at to API updated_at
      }));

      return summariesDto;
    } catch (error) {
      console.error("Error in SummaryService.listDefaultUserSummaries:", error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to get details of a single summary for the DEFAULT_USER_ID
  async getDefaultUserSummaryDetails(id: string): Promise<MeetingSummaryDetailsDto | null> {
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID for details (MVP ONLY).`
    );
    try {
      // Select all relevant columns (excluding user_id as per DTO)
      const query = this.supabase
        .from("meeting_summaries")
        .select("id, title, file_name, created_at, modified_at, transcription, summary, llm_generated, notes")
        .eq("id", id)
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Use single() for one expected row

      const { data, error } = await query;

      if (error && error.code === "PGRST116") {
        // Supabase specific error code for "no rows found"
        console.warn(`Summary not found for ID ${id} or not owned by DEFAULT user ${DEFAULT_USER_ID}.`);
        return null; // Return null for 404 case
      } else if (error) {
        console.error(
          `Database error fetching summary details for ID ${id} and DEFAULT user ${DEFAULT_USER_ID}:`,
          error
        );
        if ((error as any).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summary details from database.");
      }

      if (!data) {
        console.warn(`GET /api/summaries/${id} (DEFAULT_USER): Single query returned no data and no error.`);
        return null; // Should be caught by PGRST116 above, but safety check
      }

      // Map DB row to frontend DTO
      const summaryDto: MeetingSummaryDetailsDto = {
        id: data.id,
        title: data.title,
        file_name: data.file_name,
        created_at: data.created_at,
        updated_at: data.modified_at, // Map DB modified_at to API updated_at
        transcription: data.transcription,
        summary: data.summary,
        llm_generated: data.llm_generated,
        notes: data.notes,
      };

      return summaryDto;
    } catch (error) {
      console.error(`Error in SummaryService.getDefaultUserSummaryDetails for ID ${id}:`, error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to create a new summary for the DEFAULT_USER_ID
  async createDefaultUserSummary(data: CreateSummaryRequestDTO): Promise<MeetingSummaryFullRow> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for creation (MVP ONLY).`);
    // Prepare data for insertion, explicitly setting user_id to DEFAULT_USER_ID
    const dataToInsert: MeetingSummaryInsertData = {
      user_id: DEFAULT_USER_ID, // Assign to DEFAULT user
      file_name: data.file_name,
      transcription: data.transcription,
      summary: data.summary,
      llm_generated: data.llm_generated,
      notes: data.notes, // notes can be string or null from validation
      title:
        data.file_name && data.file_name.trim().length > 0
          ? data.file_name.trim()
          : data.transcription.trim().substring(0, 50) + (data.transcription.trim().length > 50 ? "..." : ""), // Generate title
    };

    console.log("Attempting to insert data into DB for DEFAULT user:", dataToInsert);
    try {
      // Execute the insert query
      // If RLS insert policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .insert([dataToInsert]) // Insert the prepared data
        .select() // Select the inserted row
        .single(); // Expect a single row

      if (result.error) {
        console.error("Database insertion failed for DEFAULT user:", result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Insert for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows insert for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to save summary to database.");
      }

      if (!result.data) {
        console.error("SummaryService.createDefaultUserSummary: Insert returned no error but no data.");
        throw new Error("Database insertion failed unexpectedly.");
      }

      console.log("Database insertion successful for DEFAULT user. New summary ID:", result.data.id);
      return result.data;
    } catch (error) {
      console.error("Error in SummaryService.createDefaultUserSummary:", error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to update an existing summary for the DEFAULT_USER_ID
  async updateDefaultUserSummary(id: string, data: UpdateSummaryRequestDTO): Promise<MeetingSummaryFullRow> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for update (MVP ONLY).`);
    console.log(`Attempting to update summary ${id} for DEFAULT user with data:`, data);
    try {
      // Execute the update query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS update policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .update(data) // Update with the provided data
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .select() // Select the updated row
        .single(); // Expect a single row

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows updated"
        console.warn(`Update attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        // Return null or throw specific error for handler to return 404
        const notFoundError = new Error(`Summary with ID ${id} not found or access denied.`);
        (notFoundError as any).status = 404; // Tag error for handler
        throw notFoundError;
      } else if (result.error) {
        console.error(`Database update failed for ID ${id} and DEFAULT user:`, result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Update for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows update for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to update summary in database.");
      }

      if (!result.data) {
        console.error(`SummaryService.updateDefaultUserSummary: Update returned no error but no data for ID ${id}.`);
        throw new Error("Database update failed unexpectedly.");
      }

      console.log(`Database update successful for ID ${id} and DEFAULT user.`);
      return result.data;
    } catch (error) {
      console.error(`Error in SummaryService.updateDefaultUserSummary for ID ${id}:`, error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to delete an existing summary for the DEFAULT_USER_ID
  async deleteDefaultUserSummary(id: string): Promise<void> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for delete (MVP ONLY).`);
    console.log(`Attempting to delete summary ${id} for DEFAULT user ${DEFAULT_USER_ID}`);
    try {
      // Execute the delete query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS delete policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<null> = await this.supabase
        .from("meeting_summaries")
        .delete() // Perform deletion
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Expect a single row deleted or none

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows found"
        console.warn(`Delete attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        const notFoundError = new Error(`Summary with ID ${id} not found or access denied.`);
        (notFoundError as any).status = 404; // Tag error for handler
        throw notFoundError;
      } else if (result.error) {
        console.error(`Database delete failed for ID ${id} and DEFAULT user:`, result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Delete for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows delete for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to delete summary from database.");
      }

      // Success! result.data will be null for delete single().
      console.log(`Database delete successful for ID ${id} and DEFAULT user.`);
      return; // Return void on success
    } catch (error) {
      console.error(`Error in SummaryService.deleteDefaultUserSummary for ID ${id}:`, error);
      throw error; // Re-throw to be caught by API handler
    }
  }
}

// --- Handler endpoint GET /api/summaries ---
// Implements the List Summaries endpoint.
// Authentication check is SKIPPED. Data filtered by DEFAULT_USER_ID.
export const GET: APIRoute = async ({ url, locals }) => {
  const supabase = locals.supabase as SupabaseClient;

  // --- Get Supabase client from context.locals ---
  if (!supabase) {
    console.error("GET /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "GET /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data filtered by DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used

  // --- Use Zod for parameter validation (GET) ---
  const queryParams = Object.fromEntries(url.searchParams.entries());
  const validationResult = listSummariesParamsSchema.safeParse(queryParams);

  if (!validationResult.success) {
    console.error("GET /api/summaries: Query parameter validation failed:", validationResult.error);
    return new Response(
      JSON.stringify({
        message: "Invalid query parameters",
        errors: validationResult.error.format(),
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  const validatedParams = validationResult.data;

  // --- Determine Date Range ---
  let fromDate: Date | undefined;
  let toDate: Date | undefined;

  if (validatedParams.from_dt === undefined && validatedParams.to_dt === undefined) {
    // Default to last 7 days
    const now = new Date();
    toDate = endOfDay(now); // End of today
    fromDate = startOfDay(new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)); // Start of 7 days ago
    console.log(`DEBUG: Using default 7-day filter: from ${fromDate.toISOString()} to ${toDate.toISOString()}`);
  } else {
    if (validatedParams.from_dt !== undefined) {
      // Parse the date string provided
      fromDate = parseISO(validatedParams.from_dt);
      if (isNaN(fromDate.getTime())) fromDate = undefined; // Handle potential parse failure after refine
    }
    if (validatedParams.to_dt !== undefined) {
      // Parse the date string provided
      toDate = parseISO(validatedParams.to_dt);
      if (isNaN(toDate.getTime())) toDate = undefined; // Handle potential parse failure after refine
    }
    console.log(
      `DEBUG: Using provided date filters: from ${fromDate?.toISOString() || "none"} to ${toDate?.toISOString() || "none"}`
    );
  }

  // Map API sort_by terms to DB column names for the Service layer
  const dbSortBy: ListSummariesServiceParams["sortParams"]["by"] =
    validatedParams.sort_by === "updated_at" ? "modified_at" : "created_at";
  const sortOrder: ListSummariesServiceParams["sortParams"]["order"] = validatedParams.sort_order;

  try {
    const summaryService = new SummaryService(supabase);

    const serviceParams: ListSummariesServiceParams = {
      userId: DEFAULT_USER_ID, // Pass DEFAULT user ID to service
      dateRange: { from: fromDate, to: toDate },
      sortParams: { by: dbSortBy, order: sortOrder },
    };

    // Use the specific service method for the default user
    const summariesDto: MeetingSummaryListEntryDto[] = await summaryService.listDefaultUserSummaries(serviceParams);

    return new Response(JSON.stringify(summariesDto), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });
  } catch (error) {
    console.error("Caught error in GET /api/summaries handler (DEFAULT_USER):", error);
    if ((error as any).status === 404 || (error as any).status === 403) {
      return new Response(JSON.stringify({ message: (error as any).message || "Access Denied/Not Found" }), {
        status: (error as any).status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ message: "An internal server error occurred" }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint POST /api/summaries ---
// Implements the Create New Summary endpoint.
// Authentication check is SKIPPED. Data assigned to DEFAULT_USER_ID.
export const POST: APIRoute = async ({ request, locals }) => {
  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("POST /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "POST /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data assigned to DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;

  try {
    requestBody = await request.json();
  } catch (error) {
    console.error("POST /api/summaries: Failed to parse request body as JSON:", error);
    return new Response(
      JSON.stringify({
        error: "Invalid JSON body",
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  try {
    const validationResult = createSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error("POST /api/summaries: Input validation failed:", validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        {
          status: 400,
          headers: { "Content-Type": "application/json" },
        }
      );
    }

    const validatedData = validationResult.data;

    // --- Call Service to insert data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass validated data to service. Service will use DEFAULT_USER_ID internally.
    const newSummaryRecord: MeetingSummaryFullRow = await summaryService.createDefaultUserSummary(validatedData);

    console.log(
      "POST /api/summaries: Successfully created new summary record with ID:",
      newSummaryRecord.id,
      "for DEFAULT user."
    );

    // Map DB row to frontend DTO
    const responseData: CreateSummaryResponseDTO = {
      id: newSummaryRecord.id,
      user_id: newSummaryRecord.user_id,
      file_name: newSummaryRecord.file_name,
      created_at: newSummaryRecord.created_at,
      updated_at: newSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: newSummaryRecord.transcription,
      summary: newSummaryRecord.summary,
      llm_generated: newSummaryRecord.llm_generated,
      notes: newSummaryRecord.notes,
      title: newSummaryRecord.title,
    };

    return new Response(JSON.stringify(responseData), {
      status: 201, // 201 Created
      headers: {
        "Content-Type": "application/json",
        Location: `/api/summaries/${responseData.id}`, // HATEOAS principle
      },
    });
  } catch (error) {
    console.error("Caught error in POST /api/summaries handler (DEFAULT_USER):", error);
    if ((error as any).status === 404 || (error as any).status === 403) {
      return new Response(JSON.stringify({ message: (error as any).message || "Access Denied/Not Found" }), {
        status: (error as any).status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ error: "An internal server error occurred while saving the summary." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint PUT /api/summaries/{id} ---
// Implements the Update Existing Summary endpoint.
// Authentication check is SKIPPED. Updates summary for DEFAULT_USER_ID.
export const PUT: APIRoute = async ({ params, request, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("PUT /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("PUT /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `PUT /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Updates summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;
  try {
    // --- Parse Request Body ---
    requestBody = await request.json();
  } catch (error) {
    console.error(`PUT /api/summaries/${summaryId}: Failed to parse request body as JSON:`, error);
    return new Response(JSON.stringify({ error: "Invalid JSON body" }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  try {
    // --- Input Validation (zod) ---
    const validationResult = updateSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error(`PUT /api/summaries/${summaryId}: Input validation failed:`, validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }

    const validatedData: UpdateSummaryRequestDTO = validationResult.data;

    // Ensure there's at least one field being updated
    if (Object.keys(validatedData).length === 0) {
      console.warn(`PUT /api/summaries/${summaryId}: Request body is empty, no fields to update.`);
      return new Response(JSON.stringify({ error: "Request body must contain fields to update." }), {
        status: 400,
        headers: { "Content-Type": "application/json" },
      });
    }

    // --- Call Service to update data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass updated data and summaryId to service. Service will use DEFAULT_USER_ID internally.
    const updatedSummaryRecord: MeetingSummaryFullRow = await summaryService.updateDefaultUserSummary(
      summaryId,
      validatedData
    );

    console.log(`PUT /api/summaries/${summaryId}: Successfully updated summary record for DEFAULT user.`);

    // Map DB row to frontend DTO (MeetingSummaryDetailsDto for consistency with GET details)
    const responseData: MeetingSummaryDetailsDto = {
      id: updatedSummaryRecord.id,
      title: updatedSummaryRecord.title, // Include title as it's in the DB row
      file_name: updatedSummaryRecord.file_name,
      created_at: updatedSummaryRecord.created_at,
      updated_at: updatedSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: updatedSummaryRecord.transcription,
      summary: updatedSummaryRecord.summary,
      llm_generated: updatedSummaryRecord.llm_generated,
      notes: updatedSummaryRecord.notes,
      // user_id is omitted from this DTO
    };

    return new Response(JSON.stringify(responseData), {
      status: 200, // 200 OK
      headers: { "Content-Type": "application/json" },
    });
  } catch (error) {
    console.error(`PUT /api/summaries/${summaryId}: Caught error after validation (DEFAULT_USER):`, error);
    if ((error as any).status === 404) {
      return new Response(
        JSON.stringify({
          message: (error as any).message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    if ((error as any).status === 403) {
      // This might happen if RLS is still partially active
      return new Response(
        JSON.stringify({
          message:
            (error as any).message ||
            `Permission denied for summary ID ${summaryId}. Ensure RLS allows access for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while updating summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

// --- Handler endpoint DELETE /api/summaries/{id} ---
// Implements the Delete Summary endpoint.
// Authentication check is SKIPPED. Deletes summary for DEFAULT_USER_ID.
export const DELETE: APIRoute = async ({ params, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("DELETE /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("DELETE /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `DELETE /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Deletes summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  try {
    // --- Call Service to delete data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass summaryId to service. Service will use DEFAULT_USER_ID internally.
    await summaryService.deleteDefaultUserSummary(summaryId);

    console.log(`DELETE /api/summaries/${summaryId}: Successfully deleted summary record for DEFAULT user.`);

    return new Response(null, {
      // 204 No Content
      status: 204,
      // No body for 204 response
    });
  } catch (error) {
    console.error(`DELETE /api/summaries/${summaryId}: Caught error (DEFAULT_USER):`, error);
    if ((error as any).status === 404) {
      return new Response(
        JSON.stringify({
          message: (error as any).message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    if ((error as any).status === 403) {
      // This might happen if RLS is still partially active
      return new Response(
        JSON.stringify({
          message:
            (error as any).message ||
            `Permission denied for summary ID ${summaryId}. Ensure RLS allows delete for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while deleting summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

export const prerender = false; // Needed for server routes



================================================
File: .history/src/pages/api/summaries_20250421133908.ts
================================================
/* eslint-disable no-console */
// src/pages/api/summaries.ts -- Handlers for /api/summaries (GET, POST, PUT, DELETE)

import type { APIRoute } from "astro";
import { z } from "zod"; // Import the Zod library

// Import your local SupabaseClient type alias AND the default user ID
// IMPORTANT: Using DEFAULT_USER_ID instead of auth.uid() for DB operations in this MVP!
import type { SupabaseClient } from "../../db/supabase.client";
import { DEFAULT_USER_ID } from "../../db/supabase.client"; // Import the default user ID

// Import Supabase specific types for better error handling and results
import type { PostgrestSingleResponse, PostgrestResponse } from "@supabase/supabase-js";

// Import shared DTOs and DB internal types from central types file
import type {
  MeetingSummaryListEntryDto,
  CreateSummaryRequestDTO,
  CreateSummaryResponseDTO,
  UpdateSummaryRequestDTO,
  MeetingSummaryInsertData,
  MeetingSummaryFullRow,
  MeetingSummarySelectedColumns,
  ListSummariesServiceParams,
} from "../../types"; // Adjust the path if necessary

// Import date-fns parseISO for robust date parsing and date helpers
import { parseISO, startOfDay, endOfDay } from "date-fns/esm";

// --- Zod Schema for List Summaries Query Parameters (for GET /api/summaries) ---
const listSummariesParamsSchema = z.object({
  sort_by: z.enum(["created_at", "updated_at"]).optional().default("created_at"),
  sort_order: z.enum(["asc", "desc"]).optional().default("desc"),
  // Accept date strings (YYYY-MM-DD from input type="date") or full ISO 8601
  from_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'from_dt'.",
    }),
  to_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'to_dt'.",
    }),
});

// --- Zod Schema for Create Summary Request Body (for POST /api/summaries) ---
const createSummaryRequestSchema = z.object({
  file_name: z.string().nullable().optional(), // nullable() allows null, optional() allows undefined
  transcription: z.string().min(1, { message: "Transcription cannot be empty." }),
  summary: z
    .string()
    .min(1, { message: "Summary cannot be empty." })
    .max(500, { message: "Summary cannot exceed 500 characters." }),
  llm_generated: z.boolean({ required_error: "Field 'llm_generated' is required and must be a boolean." }),
  notes: z
    .string()
    .nullable()
    .optional()
    .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
});

// --- Zod Schema for Update Summary Request Body (for PUT /api/summaries/{id}) ---
// Allows partial updates
const updateSummaryRequestSchema = z
  .object({
    file_name: z.string().nullable().optional(),
    transcription: z.string().min(1, { message: "Transcription cannot be empty." }).optional(),
    summary: z
      .string()
      .min(1, { message: "Summary cannot be empty." })
      .max(500, { message: "Summary cannot exceed 500 characters." })
      .optional(),
    llm_generated: z.boolean().optional(),
    notes: z
      .string()
      .nullable()
      .optional()
      .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
  })
  .partial(); // Make all fields optional at the top level

// --- SummaryService Class (Central logic for DB interaction) ---
// IMPORTANT: In this MVP version, this service uses DEFAULT_USER_ID for DB operations
// instead of relying on auth.uid() via RLS. This is INSECURE and for MVP ONLY.
class SummaryService {
  constructor(private supabase: SupabaseClient) {}

  // Method to list summaries for the DEFAULT_USER_ID
  async listDefaultUserSummaries(params: ListSummariesServiceParams): Promise<MeetingSummaryListEntryDto[]> {
    // userId parameter is included for type compatibility but ignored in this MVP implementation
    // as we are hardcoding DEFAULT_USER_ID.
    const { dateRange, sortParams } = params;
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID (MVP ONLY).`
    );

    try {
      // Select specific columns for the list view
      let query = this.supabase.from("meeting_summaries").select("id, title, file_name, created_at, modified_at");

      // Explicitly filter by DEFAULT_USER_ID, overriding standard RLS based on auth.uid()
      query = query.eq("user_id", DEFAULT_USER_ID);

      if (dateRange.from) {
        // Use >= for 'from' date (start of the day)
        query = query.gte("created_at", startOfDay(dateRange.from).toISOString());
      }
      if (dateRange.to) {
        // Use <= for 'to' date (end of the day)
        query = query.lte("created_at", endOfDay(dateRange.to).toISOString());
      }

      // Map API sort_by terms to DB column names
      const dbSortBy = sortParams.by === "updated_at" ? "modified_at" : "created_at";

      // Apply sorting
      query = query.order(dbSortBy, { ascending: sortParams.order === "asc" });

      // Execute the query
      const result: PostgrestResponse<MeetingSummarySelectedColumns> = await query;
      const { data, error } = result;

      if (error) {
        console.error("Database error fetching summaries for DEFAULT user", DEFAULT_USER_ID, ":", error);
        // Even with DEFAULT_USER_ID, RLS might still be active on the table!
        // If RLS is active and configured to check auth.uid(), this query might fail with 42501
        // because auth.uid() will be null or different from DEFAULT_USER_ID.
        // For this MVP phase using DEFAULT_USER_ID, you might need RLS on meeting_summaries
        // temporarily disabled during local testing, or modified to allow SELECT if user_id = DEFAULT_USER_ID
        // or auth.uid() is null/different. This is a conflict in MVP rules.
        // Assuming for this MVP, RLS is permissive enough for DEFAULT_USER_ID queries *or* temporarily disabled.
        if ((error as any).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          // Re-throw as 500, hiding specific RLS error
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summaries from database.");
      }

      if (!data) {
        console.warn("GET /api/summaries (DEFAULT_USER): Select query returned no data and no error.");
        return []; // Return empty array if no data
      }

      // Map DB rows to frontend DTOs
      const summariesDto: MeetingSummaryListEntryDto[] = data.map((row) => ({
        id: row.id,
        title: row.title,
        file_name: row.file_name,
        created_at: row.created_at,
        updated_at: row.modified_at, // Map DB modified_at to API updated_at
      }));

      return summariesDto;
    } catch (error) {
      console.error("Error in SummaryService.listDefaultUserSummaries:", error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to get details of a single summary for the DEFAULT_USER_ID
  async getDefaultUserSummaryDetails(id: string): Promise<MeetingSummaryDetailsDto | null> {
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID for details (MVP ONLY).`
    );
    try {
      // Select all relevant columns (excluding user_id as per DTO)
      const query = this.supabase
        .from("meeting_summaries")
        .select("id, title, file_name, created_at, modified_at, transcription, summary, llm_generated, notes")
        .eq("id", id)
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Use single() for one expected row

      const { data, error } = await query;

      if (error && error.code === "PGRST116") {
        // Supabase specific error code for "no rows found"
        console.warn(`Summary not found for ID ${id} or not owned by DEFAULT user ${DEFAULT_USER_ID}.`);
        return null; // Return null for 404 case
      } else if (error) {
        console.error(
          `Database error fetching summary details for ID ${id} and DEFAULT user ${DEFAULT_USER_ID}:`,
          error
        );
        if ((error as any).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summary details from database.");
      }

      if (!data) {
        console.warn(`GET /api/summaries/${id} (DEFAULT_USER): Single query returned no data and no error.`);
        return null; // Should be caught by PGRST116 above, but safety check
      }

      // Map DB row to frontend DTO
      const summaryDto: MeetingSummaryDetailsDto = {
        id: data.id,
        title: data.title,
        file_name: data.file_name,
        created_at: data.created_at,
        updated_at: data.modified_at, // Map DB modified_at to API updated_at
        transcription: data.transcription,
        summary: data.summary,
        llm_generated: data.llm_generated,
        notes: data.notes,
      };

      return summaryDto;
    } catch (error) {
      console.error(`Error in SummaryService.getDefaultUserSummaryDetails for ID ${id}:`, error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to create a new summary for the DEFAULT_USER_ID
  async createDefaultUserSummary(data: CreateSummaryRequestDTO): Promise<MeetingSummaryFullRow> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for creation (MVP ONLY).`);
    // Prepare data for insertion, explicitly setting user_id to DEFAULT_USER_ID
    const dataToInsert: MeetingSummaryInsertData = {
      user_id: DEFAULT_USER_ID, // Assign to DEFAULT user
      file_name: data.file_name,
      transcription: data.transcription,
      summary: data.summary,
      llm_generated: data.llm_generated,
      notes: data.notes, // notes can be string or null from validation
      title:
        data.file_name && data.file_name.trim().length > 0
          ? data.file_name.trim()
          : data.transcription.trim().substring(0, 50) + (data.transcription.trim().length > 50 ? "..." : ""), // Generate title
    };

    console.log("Attempting to insert data into DB for DEFAULT user:", dataToInsert);
    try {
      // Execute the insert query
      // If RLS insert policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .insert([dataToInsert]) // Insert the prepared data
        .select() // Select the inserted row
        .single(); // Expect a single row

      if (result.error) {
        console.error("Database insertion failed for DEFAULT user:", result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Insert for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows insert for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to save summary to database.");
      }

      if (!result.data) {
        console.error("SummaryService.createDefaultUserSummary: Insert returned no error but no data.");
        throw new Error("Database insertion failed unexpectedly.");
      }

      console.log("Database insertion successful for DEFAULT user. New summary ID:", result.data.id);
      return result.data;
    } catch (error) {
      console.error("Error in SummaryService.createDefaultUserSummary:", error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to update an existing summary for the DEFAULT_USER_ID
  async updateDefaultUserSummary(id: string, data: UpdateSummaryRequestDTO): Promise<MeetingSummaryFullRow> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for update (MVP ONLY).`);
    console.log(`Attempting to update summary ${id} for DEFAULT user with data:`, data);
    try {
      // Execute the update query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS update policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .update(data) // Update with the provided data
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .select() // Select the updated row
        .single(); // Expect a single row

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows updated"
        console.warn(`Update attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        // Return null or throw specific error for handler to return 404
        const notFoundError = new Error(`Summary with ID ${id} not found or access denied.`);
        (notFoundError as any).status = 404; // Tag error for handler
        throw notFoundError;
      } else if (result.error) {
        console.error(`Database update failed for ID ${id} and DEFAULT user:`, result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Update for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows update for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to update summary in database.");
      }

      if (!result.data) {
        console.error(`SummaryService.updateDefaultUserSummary: Update returned no error but no data for ID ${id}.`);
        throw new Error("Database update failed unexpectedly.");
      }

      console.log(`Database update successful for ID ${id} and DEFAULT user.`);
      return result.data;
    } catch (error) {
      console.error(`Error in SummaryService.updateDefaultUserSummary for ID ${id}:`, error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to delete an existing summary for the DEFAULT_USER_ID
  async deleteDefaultUserSummary(id: string): Promise<void> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for delete (MVP ONLY).`);
    console.log(`Attempting to delete summary ${id} for DEFAULT user ${DEFAULT_USER_ID}`);
    try {
      // Execute the delete query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS delete policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<null> = await this.supabase
        .from("meeting_summaries")
        .delete() // Perform deletion
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Expect a single row deleted or none

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows found"
        console.warn(`Delete attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        const notFoundError = new Error(`Summary with ID ${id} not found or access denied.`);
        (notFoundError as any).status = 404; // Tag error for handler
        throw notFoundError;
      } else if (result.error) {
        console.error(`Database delete failed for ID ${id} and DEFAULT user:`, result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Delete for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows delete for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to delete summary from database.");
      }

      // Success! result.data will be null for delete single().
      console.log(`Database delete successful for ID ${id} and DEFAULT user.`);
      return; // Return void on success
    } catch (error) {
      console.error(`Error in SummaryService.deleteDefaultUserSummary for ID ${id}:`, error);
      throw error; // Re-throw to be caught by API handler
    }
  }
}

// --- Handler endpoint GET /api/summaries ---
// Implements the List Summaries endpoint.
// Authentication check is SKIPPED. Data filtered by DEFAULT_USER_ID.
export const GET: APIRoute = async ({ url, locals }) => {
  const supabase = locals.supabase as SupabaseClient;

  // --- Get Supabase client from context.locals ---
  if (!supabase) {
    console.error("GET /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "GET /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data filtered by DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used

  // --- Use Zod for parameter validation (GET) ---
  const queryParams = Object.fromEntries(url.searchParams.entries());
  const validationResult = listSummariesParamsSchema.safeParse(queryParams);

  if (!validationResult.success) {
    console.error("GET /api/summaries: Query parameter validation failed:", validationResult.error);
    return new Response(
      JSON.stringify({
        message: "Invalid query parameters",
        errors: validationResult.error.format(),
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  const validatedParams = validationResult.data;

  // --- Determine Date Range ---
  let fromDate: Date | undefined;
  let toDate: Date | undefined;

  if (validatedParams.from_dt === undefined && validatedParams.to_dt === undefined) {
    // Default to last 7 days
    const now = new Date();
    toDate = endOfDay(now); // End of today
    fromDate = startOfDay(new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)); // Start of 7 days ago
    console.log(`DEBUG: Using default 7-day filter: from ${fromDate.toISOString()} to ${toDate.toISOString()}`);
  } else {
    if (validatedParams.from_dt !== undefined) {
      // Parse the date string provided
      fromDate = parseISO(validatedParams.from_dt);
      if (isNaN(fromDate.getTime())) fromDate = undefined; // Handle potential parse failure after refine
    }
    if (validatedParams.to_dt !== undefined) {
      // Parse the date string provided
      toDate = parseISO(validatedParams.to_dt);
      if (isNaN(toDate.getTime())) toDate = undefined; // Handle potential parse failure after refine
    }
    console.log(
      `DEBUG: Using provided date filters: from ${fromDate?.toISOString() || "none"} to ${toDate?.toISOString() || "none"}`
    );
  }

  // Map API sort_by terms to DB column names for the Service layer
  const dbSortBy: ListSummariesServiceParams["sortParams"]["by"] =
    validatedParams.sort_by === "updated_at" ? "modified_at" : "created_at";
  const sortOrder: ListSummariesServiceParams["sortParams"]["order"] = validatedParams.sort_order;

  try {
    const summaryService = new SummaryService(supabase);

    const serviceParams: ListSummariesServiceParams = {
      userId: DEFAULT_USER_ID, // Pass DEFAULT user ID to service
      dateRange: { from: fromDate, to: toDate },
      sortParams: { by: dbSortBy, order: sortOrder },
    };

    // Use the specific service method for the default user
    const summariesDto: MeetingSummaryListEntryDto[] = await summaryService.listDefaultUserSummaries(serviceParams);

    return new Response(JSON.stringify(summariesDto), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });
  } catch (error) {
    console.error("Caught error in GET /api/summaries handler (DEFAULT_USER):", error);
    if ((error as any).status === 404 || (error as any).status === 403) {
      return new Response(JSON.stringify({ message: (error as any).message || "Access Denied/Not Found" }), {
        status: (error as any).status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ message: "An internal server error occurred" }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint POST /api/summaries ---
// Implements the Create New Summary endpoint.
// Authentication check is SKIPPED. Data assigned to DEFAULT_USER_ID.
export const POST: APIRoute = async ({ request, locals }) => {
  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("POST /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "POST /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data assigned to DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;

  try {
    requestBody = await request.json();
  } catch (error) {
    console.error("POST /api/summaries: Failed to parse request body as JSON:", error);
    return new Response(
      JSON.stringify({
        error: "Invalid JSON body",
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  try {
    const validationResult = createSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error("POST /api/summaries: Input validation failed:", validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        {
          status: 400,
          headers: { "Content-Type": "application/json" },
        }
      );
    }

    const validatedData = validationResult.data;

    // --- Call Service to insert data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass validated data to service. Service will use DEFAULT_USER_ID internally.
    const newSummaryRecord: MeetingSummaryFullRow = await summaryService.createDefaultUserSummary(validatedData);

    console.log(
      "POST /api/summaries: Successfully created new summary record with ID:",
      newSummaryRecord.id,
      "for DEFAULT user."
    );

    // Map DB row to frontend DTO
    const responseData: CreateSummaryResponseDTO = {
      id: newSummaryRecord.id,
      user_id: newSummaryRecord.user_id,
      file_name: newSummaryRecord.file_name,
      created_at: newSummaryRecord.created_at,
      updated_at: newSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: newSummaryRecord.transcription,
      summary: newSummaryRecord.summary,
      llm_generated: newSummaryRecord.llm_generated,
      notes: newSummaryRecord.notes,
      title: newSummaryRecord.title,
    };

    return new Response(JSON.stringify(responseData), {
      status: 201, // 201 Created
      headers: {
        "Content-Type": "application/json",
        Location: `/api/summaries/${responseData.id}`, // HATEOAS principle
      },
    });
  } catch (error) {
    console.error("Caught error in POST /api/summaries handler (DEFAULT_USER):", error);
    if ((error as any).status === 404 || (error as any).status === 403) {
      return new Response(JSON.stringify({ message: (error as any).message || "Access Denied/Not Found" }), {
        status: (error as any).status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ error: "An internal server error occurred while saving the summary." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint PUT /api/summaries/{id} ---
// Implements the Update Existing Summary endpoint.
// Authentication check is SKIPPED. Updates summary for DEFAULT_USER_ID.
export const PUT: APIRoute = async ({ params, request, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("PUT /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("PUT /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `PUT /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Updates summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;
  try {
    // --- Parse Request Body ---
    requestBody = await request.json();
  } catch (error) {
    console.error(`PUT /api/summaries/${summaryId}: Failed to parse request body as JSON:`, error);
    return new Response(JSON.stringify({ error: "Invalid JSON body" }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  try {
    // --- Input Validation (zod) ---
    const validationResult = updateSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error(`PUT /api/summaries/${summaryId}: Input validation failed:`, validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }

    const validatedData: UpdateSummaryRequestDTO = validationResult.data;

    // Ensure there's at least one field being updated
    if (Object.keys(validatedData).length === 0) {
      console.warn(`PUT /api/summaries/${summaryId}: Request body is empty, no fields to update.`);
      return new Response(JSON.stringify({ error: "Request body must contain fields to update." }), {
        status: 400,
        headers: { "Content-Type": "application/json" },
      });
    }

    // --- Call Service to update data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass updated data and summaryId to service. Service will use DEFAULT_USER_ID internally.
    const updatedSummaryRecord: MeetingSummaryFullRow = await summaryService.updateDefaultUserSummary(
      summaryId,
      validatedData
    );

    console.log(`PUT /api/summaries/${summaryId}: Successfully updated summary record for DEFAULT user.`);

    // Map DB row to frontend DTO (MeetingSummaryDetailsDto for consistency with GET details)
    const responseData: MeetingSummaryDetailsDto = {
      id: updatedSummaryRecord.id,
      title: updatedSummaryRecord.title, // Include title as it's in the DB row
      file_name: updatedSummaryRecord.file_name,
      created_at: updatedSummaryRecord.created_at,
      updated_at: updatedSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: updatedSummaryRecord.transcription,
      summary: updatedSummaryRecord.summary,
      llm_generated: updatedSummaryRecord.llm_generated,
      notes: updatedSummaryRecord.notes,
      // user_id is omitted from this DTO
    };

    return new Response(JSON.stringify(responseData), {
      status: 200, // 200 OK
      headers: { "Content-Type": "application/json" },
    });
  } catch (error) {
    console.error(`PUT /api/summaries/${summaryId}: Caught error after validation (DEFAULT_USER):`, error);
    if ((error as any).status === 404) {
      return new Response(
        JSON.stringify({
          message: (error as any).message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    if ((error as any).status === 403) {
      // This might happen if RLS is still partially active
      return new Response(
        JSON.stringify({
          message:
            (error as any).message ||
            `Permission denied for summary ID ${summaryId}. Ensure RLS allows access for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while updating summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

// --- Handler endpoint DELETE /api/summaries/{id} ---
// Implements the Delete Summary endpoint.
// Authentication check is SKIPPED. Deletes summary for DEFAULT_USER_ID.
export const DELETE: APIRoute = async ({ params, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("DELETE /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("DELETE /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `DELETE /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Deletes summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  try {
    // --- Call Service to delete data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass summaryId to service. Service will use DEFAULT_USER_ID internally.
    await summaryService.deleteDefaultUserSummary(summaryId);

    console.log(`DELETE /api/summaries/${summaryId}: Successfully deleted summary record for DEFAULT user.`);

    return new Response(null, {
      // 204 No Content
      status: 204,
      // No body for 204 response
    });
  } catch (error) {
    console.error(`DELETE /api/summaries/${summaryId}: Caught error (DEFAULT_USER):`, error);
    if ((error as any).status === 404) {
      return new Response(
        JSON.stringify({
          message: (error as any).message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    if ((error as any).status === 403) {
      // This might happen if RLS is still partially active
      return new Response(
        JSON.stringify({
          message:
            (error as any).message ||
            `Permission denied for summary ID ${summaryId}. Ensure RLS allows delete for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while deleting summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

export const prerender = false; // Needed for server routes



================================================
File: .history/src/pages/api/summaries_20250421133938.ts
================================================
/* eslint-disable no-console */
// src/pages/api/summaries.ts -- Handlers for /api/summaries (GET, POST, PUT, DELETE)

import type { APIRoute } from "astro";
import { z } from "zod"; // Import the Zod library

// Import your local SupabaseClient type alias AND the default user ID
// IMPORTANT: Using DEFAULT_USER_ID instead of auth.uid() for DB operations in this MVP!
import type { SupabaseClient } from "../../db/supabase.client";
import { DEFAULT_USER_ID } from "../../db/supabase.client"; // Import the default user ID

// Import Supabase specific types for better error handling and results
import type { PostgrestSingleResponse, PostgrestResponse } from "@supabase/supabase-js";

// Import shared DTOs and DB internal types from central types file
import type {
  MeetingSummaryListEntryDto,
  CreateSummaryRequestDTO,
  CreateSummaryResponseDTO,
  UpdateSummaryRequestDTO,
  MeetingSummaryInsertData,
  MeetingSummaryFullRow,
  MeetingSummarySelectedColumns,
  ListSummariesServiceParams,
} from "../../types"; // Adjust the path if necessary

// Import date-fns parseISO for robust date parsing and date helpers
import { parseISO, startOfDay, endOfDay } from "date-fns/esm";

// --- Zod Schema for List Summaries Query Parameters (for GET /api/summaries) ---
const listSummariesParamsSchema = z.object({
  sort_by: z.enum(["created_at", "updated_at"]).optional().default("created_at"),
  sort_order: z.enum(["asc", "desc"]).optional().default("desc"),
  // Accept date strings (YYYY-MM-DD from input type="date") or full ISO 8601
  from_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'from_dt'.",
    }),
  to_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'to_dt'.",
    }),
});

// --- Zod Schema for Create Summary Request Body (for POST /api/summaries) ---
const createSummaryRequestSchema = z.object({
  file_name: z.string().nullable().optional(), // nullable() allows null, optional() allows undefined
  transcription: z.string().min(1, { message: "Transcription cannot be empty." }),
  summary: z
    .string()
    .min(1, { message: "Summary cannot be empty." })
    .max(500, { message: "Summary cannot exceed 500 characters." }),
  llm_generated: z.boolean({ required_error: "Field 'llm_generated' is required and must be a boolean." }),
  notes: z
    .string()
    .nullable()
    .optional()
    .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
});

// --- Zod Schema for Update Summary Request Body (for PUT /api/summaries/{id}) ---
// Allows partial updates
const updateSummaryRequestSchema = z
  .object({
    file_name: z.string().nullable().optional(),
    transcription: z.string().min(1, { message: "Transcription cannot be empty." }).optional(),
    summary: z
      .string()
      .min(1, { message: "Summary cannot be empty." })
      .max(500, { message: "Summary cannot exceed 500 characters." })
      .optional(),
    llm_generated: z.boolean().optional(),
    notes: z
      .string()
      .nullable()
      .optional()
      .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
  })
  .partial(); // Make all fields optional at the top level

// --- SummaryService Class (Central logic for DB interaction) ---
// IMPORTANT: In this MVP version, this service uses DEFAULT_USER_ID for DB operations
// instead of relying on auth.uid() via RLS. This is INSECURE and for MVP ONLY.
class SummaryService {
  constructor(private supabase: SupabaseClient) {}

  // Method to list summaries for the DEFAULT_USER_ID
  async listDefaultUserSummaries(params: ListSummariesServiceParams): Promise<MeetingSummaryListEntryDto[]> {
    // userId parameter is included for type compatibility but ignored in this MVP implementation
    // as we are hardcoding DEFAULT_USER_ID.
    const { dateRange, sortParams } = params;
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID (MVP ONLY).`
    );

    try {
      // Select specific columns for the list view
      let query = this.supabase.from("meeting_summaries").select("id, title, file_name, created_at, modified_at");

      // Explicitly filter by DEFAULT_USER_ID, overriding standard RLS based on auth.uid()
      query = query.eq("user_id", DEFAULT_USER_ID);

      if (dateRange.from) {
        // Use >= for 'from' date (start of the day)
        query = query.gte("created_at", startOfDay(dateRange.from).toISOString());
      }
      if (dateRange.to) {
        // Use <= for 'to' date (end of the day)
        query = query.lte("created_at", endOfDay(dateRange.to).toISOString());
      }

      // Map API sort_by terms to DB column names
      const dbSortBy = sortParams.by === "updated_at" ? "modified_at" : "created_at";

      // Apply sorting
      query = query.order(dbSortBy, { ascending: sortParams.order === "asc" });

      // Execute the query
      const result: PostgrestResponse<MeetingSummarySelectedColumns> = await query;
      const { data, error } = result;

      if (error) {
        console.error("Database error fetching summaries for DEFAULT user", DEFAULT_USER_ID, ":", error);
        // Even with DEFAULT_USER_ID, RLS might still be active on the table!
        // If RLS is active and configured to check auth.uid(), this query might fail with 42501
        // because auth.uid() will be null or different from DEFAULT_USER_ID.
        // For this MVP phase using DEFAULT_USER_ID, you might need RLS on meeting_summaries
        // temporarily disabled during local testing, or modified to allow SELECT if user_id = DEFAULT_USER_ID
        // or auth.uid() is null/different. This is a conflict in MVP rules.
        // Assuming for this MVP, RLS is permissive enough for DEFAULT_USER_ID queries *or* temporarily disabled.
        if ((error as any).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          // Re-throw as 500, hiding specific RLS error
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summaries from database.");
      }

      if (!data) {
        console.warn("GET /api/summaries (DEFAULT_USER): Select query returned no data and no error.");
        return []; // Return empty array if no data
      }

      // Map DB rows to frontend DTOs
      const summariesDto: MeetingSummaryListEntryDto[] = data.map((row) => ({
        id: row.id,
        title: row.title,
        file_name: row.file_name,
        created_at: row.created_at,
        updated_at: row.modified_at, // Map DB modified_at to API updated_at
      }));

      return summariesDto;
    } catch (error) {
      console.error("Error in SummaryService.listDefaultUserSummaries:", error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to get details of a single summary for the DEFAULT_USER_ID
  async getDefaultUserSummaryDetails(id: string): Promise<MeetingSummaryDetailsDto | null> {
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID for details (MVP ONLY).`
    );
    try {
      // Select all relevant columns (excluding user_id as per DTO)
      const query = this.supabase
        .from("meeting_summaries")
        .select("id, title, file_name, created_at, modified_at, transcription, summary, llm_generated, notes")
        .eq("id", id)
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Use single() for one expected row

      const { data, error } = await query;

      if (error && error.code === "PGRST116") {
        // Supabase specific error code for "no rows found"
        console.warn(`Summary not found for ID ${id} or not owned by DEFAULT user ${DEFAULT_USER_ID}.`);
        return null; // Return null for 404 case
      } else if (error) {
        console.error(
          `Database error fetching summary details for ID ${id} and DEFAULT user ${DEFAULT_USER_ID}:`,
          error
        );
        if ((error as any).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summary details from database.");
      }

      if (!data) {
        console.warn(`GET /api/summaries/${id} (DEFAULT_USER): Single query returned no data and no error.`);
        return null; // Should be caught by PGRST116 above, but safety check
      }

      // Map DB row to frontend DTO
      const summaryDto: MeetingSummaryDetailsDto = {
        id: data.id,
        title: data.title,
        file_name: data.file_name,
        created_at: data.created_at,
        updated_at: data.modified_at, // Map DB modified_at to API updated_at
        transcription: data.transcription,
        summary: data.summary,
        llm_generated: data.llm_generated,
        notes: data.notes,
      };

      return summaryDto;
    } catch (error) {
      console.error(`Error in SummaryService.getDefaultUserSummaryDetails for ID ${id}:`, error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to create a new summary for the DEFAULT_USER_ID
  async createDefaultUserSummary(data: CreateSummaryRequestDTO): Promise<MeetingSummaryFullRow> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for creation (MVP ONLY).`);
    // Prepare data for insertion, explicitly setting user_id to DEFAULT_USER_ID
    const dataToInsert: MeetingSummaryInsertData = {
      user_id: DEFAULT_USER_ID, // Assign to DEFAULT user
      file_name: data.file_name,
      transcription: data.transcription,
      summary: data.summary,
      llm_generated: data.llm_generated,
      notes: data.notes, // notes can be string or null from validation
      title:
        data.file_name && data.file_name.trim().length > 0
          ? data.file_name.trim()
          : data.transcription.trim().substring(0, 50) + (data.transcription.trim().length > 50 ? "..." : ""), // Generate title
    };

    console.log("Attempting to insert data into DB for DEFAULT user:", dataToInsert);
    try {
      // Execute the insert query
      // If RLS insert policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .insert([dataToInsert]) // Insert the prepared data
        .select() // Select the inserted row
        .single(); // Expect a single row

      if (result.error) {
        console.error("Database insertion failed for DEFAULT user:", result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Insert for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows insert for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to save summary to database.");
      }

      if (!result.data) {
        console.error("SummaryService.createDefaultUserSummary: Insert returned no error but no data.");
        throw new Error("Database insertion failed unexpectedly.");
      }

      console.log("Database insertion successful for DEFAULT user. New summary ID:", result.data.id);
      return result.data;
    } catch (error) {
      console.error("Error in SummaryService.createDefaultUserSummary:", error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to update an existing summary for the DEFAULT_USER_ID
  async updateDefaultUserSummary(id: string, data: UpdateSummaryRequestDTO): Promise<MeetingSummaryFullRow> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for update (MVP ONLY).`);
    console.log(`Attempting to update summary ${id} for DEFAULT user with data:`, data);
    try {
      // Execute the update query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS update policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .update(data) // Update with the provided data
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .select() // Select the updated row
        .single(); // Expect a single row

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows updated"
        console.warn(`Update attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        // Return null or throw specific error for handler to return 404
        const notFoundError = new Error(`Summary with ID ${id} not found or access denied.`);
        (notFoundError as any).status = 404; // Tag error for handler
        throw notFoundError;
      } else if (result.error) {
        console.error(`Database update failed for ID ${id} and DEFAULT user:`, result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Update for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows update for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to update summary in database.");
      }

      if (!result.data) {
        console.error(`SummaryService.updateDefaultUserSummary: Update returned no error but no data for ID ${id}.`);
        throw new Error("Database update failed unexpectedly.");
      }

      console.log(`Database update successful for ID ${id} and DEFAULT user.`);
      return result.data;
    } catch (error) {
      console.error(`Error in SummaryService.updateDefaultUserSummary for ID ${id}:`, error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to delete an existing summary for the DEFAULT_USER_ID
  async deleteDefaultUserSummary(id: string): Promise<void> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for delete (MVP ONLY).`);
    console.log(`Attempting to delete summary ${id} for DEFAULT user ${DEFAULT_USER_ID}`);
    try {
      // Execute the delete query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS delete policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<null> = await this.supabase
        .from("meeting_summaries")
        .delete() // Perform deletion
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Expect a single row deleted or none

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows found"
        console.warn(`Delete attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        const notFoundError = new Error(`Summary with ID ${id} not found or access denied.`);
        (notFoundError as any).status = 404; // Tag error for handler
        throw notFoundError;
      } else if (result.error) {
        console.error(`Database delete failed for ID ${id} and DEFAULT user:`, result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Delete for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows delete for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to delete summary from database.");
      }

      // Success! result.data will be null for delete single().
      console.log(`Database delete successful for ID ${id} and DEFAULT user.`);
      return; // Return void on success
    } catch (error) {
      console.error(`Error in SummaryService.deleteDefaultUserSummary for ID ${id}:`, error);
      throw error; // Re-throw to be caught by API handler
    }
  }
}

// --- Handler endpoint GET /api/summaries ---
// Implements the List Summaries endpoint.
// Authentication check is SKIPPED. Data filtered by DEFAULT_USER_ID.
export const GET: APIRoute = async ({ url, locals }) => {
  const supabase = locals.supabase as SupabaseClient;

  // --- Get Supabase client from context.locals ---
  if (!supabase) {
    console.error("GET /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "GET /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data filtered by DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used

  // --- Use Zod for parameter validation (GET) ---
  const queryParams = Object.fromEntries(url.searchParams.entries());
  const validationResult = listSummariesParamsSchema.safeParse(queryParams);

  if (!validationResult.success) {
    console.error("GET /api/summaries: Query parameter validation failed:", validationResult.error);
    return new Response(
      JSON.stringify({
        message: "Invalid query parameters",
        errors: validationResult.error.format(),
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  const validatedParams = validationResult.data;

  // --- Determine Date Range ---
  let fromDate: Date | undefined;
  let toDate: Date | undefined;

  if (validatedParams.from_dt === undefined && validatedParams.to_dt === undefined) {
    // Default to last 7 days
    const now = new Date();
    toDate = endOfDay(now); // End of today
    fromDate = startOfDay(new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)); // Start of 7 days ago
    console.log(`DEBUG: Using default 7-day filter: from ${fromDate.toISOString()} to ${toDate.toISOString()}`);
  } else {
    if (validatedParams.from_dt !== undefined) {
      // Parse the date string provided
      fromDate = parseISO(validatedParams.from_dt);
      if (isNaN(fromDate.getTime())) fromDate = undefined; // Handle potential parse failure after refine
    }
    if (validatedParams.to_dt !== undefined) {
      // Parse the date string provided
      toDate = parseISO(validatedParams.to_dt);
      if (isNaN(toDate.getTime())) toDate = undefined; // Handle potential parse failure after refine
    }
    console.log(
      `DEBUG: Using provided date filters: from ${fromDate?.toISOString() || "none"} to ${toDate?.toISOString() || "none"}`
    );
  }

  // Map API sort_by terms to DB column names for the Service layer
  const dbSortBy: ListSummariesServiceParams["sortParams"]["by"] =
    validatedParams.sort_by === "updated_at" ? "modified_at" : "created_at";
  const sortOrder: ListSummariesServiceParams["sortParams"]["order"] = validatedParams.sort_order;

  try {
    const summaryService = new SummaryService(supabase);

    const serviceParams: ListSummariesServiceParams = {
      userId: DEFAULT_USER_ID, // Pass DEFAULT user ID to service
      dateRange: { from: fromDate, to: toDate },
      sortParams: { by: dbSortBy, order: sortOrder },
    };

    // Use the specific service method for the default user
    const summariesDto: MeetingSummaryListEntryDto[] = await summaryService.listDefaultUserSummaries(serviceParams);

    return new Response(JSON.stringify(summariesDto), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });
  } catch (error) {
    console.error("Caught error in GET /api/summaries handler (DEFAULT_USER):", error);
    if ((error as any).status === 404 || (error as any).status === 403) {
      return new Response(JSON.stringify({ message: (error as any).message || "Access Denied/Not Found" }), {
        status: (error as any).status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ message: "An internal server error occurred" }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint POST /api/summaries ---
// Implements the Create New Summary endpoint.
// Authentication check is SKIPPED. Data assigned to DEFAULT_USER_ID.
export const POST: APIRoute = async ({ request, locals }) => {
  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("POST /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "POST /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data assigned to DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;

  try {
    requestBody = await request.json();
  } catch (error) {
    console.error("POST /api/summaries: Failed to parse request body as JSON:", error);
    return new Response(
      JSON.stringify({
        error: "Invalid JSON body",
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  try {
    const validationResult = createSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error("POST /api/summaries: Input validation failed:", validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        {
          status: 400,
          headers: { "Content-Type": "application/json" },
        }
      );
    }

    const validatedData = validationResult.data;

    // --- Call Service to insert data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass validated data to service. Service will use DEFAULT_USER_ID internally.
    const newSummaryRecord: MeetingSummaryFullRow = await summaryService.createDefaultUserSummary(validatedData);

    console.log(
      "POST /api/summaries: Successfully created new summary record with ID:",
      newSummaryRecord.id,
      "for DEFAULT user."
    );

    // Map DB row to frontend DTO
    const responseData: CreateSummaryResponseDTO = {
      id: newSummaryRecord.id,
      user_id: newSummaryRecord.user_id,
      file_name: newSummaryRecord.file_name,
      created_at: newSummaryRecord.created_at,
      updated_at: newSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: newSummaryRecord.transcription,
      summary: newSummaryRecord.summary,
      llm_generated: newSummaryRecord.llm_generated,
      notes: newSummaryRecord.notes,
      title: newSummaryRecord.title,
    };

    return new Response(JSON.stringify(responseData), {
      status: 201, // 201 Created
      headers: {
        "Content-Type": "application/json",
        Location: `/api/summaries/${responseData.id}`, // HATEOAS principle
      },
    });
  } catch (error) {
    console.error("Caught error in POST /api/summaries handler (DEFAULT_USER):", error);
    if ((error as any).status === 404 || (error as any).status === 403) {
      return new Response(JSON.stringify({ message: (error as any).message || "Access Denied/Not Found" }), {
        status: (error as any).status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ error: "An internal server error occurred while saving the summary." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint PUT /api/summaries/{id} ---
// Implements the Update Existing Summary endpoint.
// Authentication check is SKIPPED. Updates summary for DEFAULT_USER_ID.
export const PUT: APIRoute = async ({ params, request, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("PUT /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("PUT /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `PUT /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Updates summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;
  try {
    // --- Parse Request Body ---
    requestBody = await request.json();
  } catch (error) {
    console.error(`PUT /api/summaries/${summaryId}: Failed to parse request body as JSON:`, error);
    return new Response(JSON.stringify({ error: "Invalid JSON body" }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  try {
    // --- Input Validation (zod) ---
    const validationResult = updateSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error(`PUT /api/summaries/${summaryId}: Input validation failed:`, validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }

    const validatedData: UpdateSummaryRequestDTO = validationResult.data;

    // Ensure there's at least one field being updated
    if (Object.keys(validatedData).length === 0) {
      console.warn(`PUT /api/summaries/${summaryId}: Request body is empty, no fields to update.`);
      return new Response(JSON.stringify({ error: "Request body must contain fields to update." }), {
        status: 400,
        headers: { "Content-Type": "application/json" },
      });
    }

    // --- Call Service to update data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass updated data and summaryId to service. Service will use DEFAULT_USER_ID internally.
    const updatedSummaryRecord: MeetingSummaryFullRow = await summaryService.updateDefaultUserSummary(
      summaryId,
      validatedData
    );

    console.log(`PUT /api/summaries/${summaryId}: Successfully updated summary record for DEFAULT user.`);

    // Map DB row to frontend DTO (MeetingSummaryDetailsDto for consistency with GET details)
    const responseData: MeetingSummaryDetailsDto = {
      id: updatedSummaryRecord.id,
      title: updatedSummaryRecord.title, // Include title as it's in the DB row
      file_name: updatedSummaryRecord.file_name,
      created_at: updatedSummaryRecord.created_at,
      updated_at: updatedSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: updatedSummaryRecord.transcription,
      summary: updatedSummaryRecord.summary,
      llm_generated: updatedSummaryRecord.llm_generated,
      notes: updatedSummaryRecord.notes,
      // user_id is omitted from this DTO
    };

    return new Response(JSON.stringify(responseData), {
      status: 200, // 200 OK
      headers: { "Content-Type": "application/json" },
    });
  } catch (error) {
    console.error(`PUT /api/summaries/${summaryId}: Caught error after validation (DEFAULT_USER):`, error);
    if ((error as any).status === 404) {
      return new Response(
        JSON.stringify({
          message: (error as any).message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    if ((error as any).status === 403) {
      // This might happen if RLS is still partially active
      return new Response(
        JSON.stringify({
          message:
            (error as any).message ||
            `Permission denied for summary ID ${summaryId}. Ensure RLS allows access for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while updating summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

// --- Handler endpoint DELETE /api/summaries/{id} ---
// Implements the Delete Summary endpoint.
// Authentication check is SKIPPED. Deletes summary for DEFAULT_USER_ID.
export const DELETE: APIRoute = async ({ params, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("DELETE /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("DELETE /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `DELETE /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Deletes summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  try {
    // --- Call Service to delete data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass summaryId to service. Service will use DEFAULT_USER_ID internally.
    await summaryService.deleteDefaultUserSummary(summaryId);

    console.log(`DELETE /api/summaries/${summaryId}: Successfully deleted summary record for DEFAULT user.`);

    return new Response(null, {
      // 204 No Content
      status: 204,
      // No body for 204 response
    });
  } catch (error) {
    console.error(`DELETE /api/summaries/${summaryId}: Caught error (DEFAULT_USER):`, error);
    if ((error as any).status === 404) {
      return new Response(
        JSON.stringify({
          message: (error as any).message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    if ((error as any).status === 403) {
      // This might happen if RLS is still partially active
      return new Response(
        JSON.stringify({
          message:
            (error as any).message ||
            `Permission denied for summary ID ${summaryId}. Ensure RLS allows delete for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while deleting summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

export const prerender = false; // Needed for server routes



================================================
File: .history/src/pages/api/summaries_20250421133942.ts
================================================
/* eslint-disable no-console */
// src/pages/api/summaries.ts -- Handlers for /api/summaries (GET, POST, PUT, DELETE)

import type { APIRoute } from "astro";
import { z } from "zod"; // Import the Zod library

// Import your local SupabaseClient type alias AND the default user ID
// IMPORTANT: Using DEFAULT_USER_ID instead of auth.uid() for DB operations in this MVP!
import type { SupabaseClient } from "../../db/supabase.client";
import { DEFAULT_USER_ID } from "../../db/supabase.client"; // Import the default user ID

// Import Supabase specific types for better error handling and results
import type { PostgrestSingleResponse, PostgrestResponse } from "@supabase/supabase-js";

// Import shared DTOs and DB internal types from central types file
import type {
  MeetingSummaryListEntryDto,
  CreateSummaryRequestDTO,
  CreateSummaryResponseDTO,
  UpdateSummaryRequestDTO,
  MeetingSummaryInsertData,
  MeetingSummaryFullRow,
  MeetingSummarySelectedColumns,
  ListSummariesServiceParams,
} from "../../types"; // Adjust the path if necessary

// Import date-fns parseISO for robust date parsing and date helpers
import { parseISO, startOfDay, endOfDay } from "date-fns";

// --- Zod Schema for List Summaries Query Parameters (for GET /api/summaries) ---
const listSummariesParamsSchema = z.object({
  sort_by: z.enum(["created_at", "updated_at"]).optional().default("created_at"),
  sort_order: z.enum(["asc", "desc"]).optional().default("desc"),
  // Accept date strings (YYYY-MM-DD from input type="date") or full ISO 8601
  from_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'from_dt'.",
    }),
  to_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'to_dt'.",
    }),
});

// --- Zod Schema for Create Summary Request Body (for POST /api/summaries) ---
const createSummaryRequestSchema = z.object({
  file_name: z.string().nullable().optional(), // nullable() allows null, optional() allows undefined
  transcription: z.string().min(1, { message: "Transcription cannot be empty." }),
  summary: z
    .string()
    .min(1, { message: "Summary cannot be empty." })
    .max(500, { message: "Summary cannot exceed 500 characters." }),
  llm_generated: z.boolean({ required_error: "Field 'llm_generated' is required and must be a boolean." }),
  notes: z
    .string()
    .nullable()
    .optional()
    .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
});

// --- Zod Schema for Update Summary Request Body (for PUT /api/summaries/{id}) ---
// Allows partial updates
const updateSummaryRequestSchema = z
  .object({
    file_name: z.string().nullable().optional(),
    transcription: z.string().min(1, { message: "Transcription cannot be empty." }).optional(),
    summary: z
      .string()
      .min(1, { message: "Summary cannot be empty." })
      .max(500, { message: "Summary cannot exceed 500 characters." })
      .optional(),
    llm_generated: z.boolean().optional(),
    notes: z
      .string()
      .nullable()
      .optional()
      .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
  })
  .partial(); // Make all fields optional at the top level

// --- SummaryService Class (Central logic for DB interaction) ---
// IMPORTANT: In this MVP version, this service uses DEFAULT_USER_ID for DB operations
// instead of relying on auth.uid() via RLS. This is INSECURE and for MVP ONLY.
class SummaryService {
  constructor(private supabase: SupabaseClient) {}

  // Method to list summaries for the DEFAULT_USER_ID
  async listDefaultUserSummaries(params: ListSummariesServiceParams): Promise<MeetingSummaryListEntryDto[]> {
    // userId parameter is included for type compatibility but ignored in this MVP implementation
    // as we are hardcoding DEFAULT_USER_ID.
    const { dateRange, sortParams } = params;
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID (MVP ONLY).`
    );

    try {
      // Select specific columns for the list view
      let query = this.supabase.from("meeting_summaries").select("id, title, file_name, created_at, modified_at");

      // Explicitly filter by DEFAULT_USER_ID, overriding standard RLS based on auth.uid()
      query = query.eq("user_id", DEFAULT_USER_ID);

      if (dateRange.from) {
        // Use >= for 'from' date (start of the day)
        query = query.gte("created_at", startOfDay(dateRange.from).toISOString());
      }
      if (dateRange.to) {
        // Use <= for 'to' date (end of the day)
        query = query.lte("created_at", endOfDay(dateRange.to).toISOString());
      }

      // Map API sort_by terms to DB column names
      const dbSortBy = sortParams.by === "updated_at" ? "modified_at" : "created_at";

      // Apply sorting
      query = query.order(dbSortBy, { ascending: sortParams.order === "asc" });

      // Execute the query
      const result: PostgrestResponse<MeetingSummarySelectedColumns> = await query;
      const { data, error } = result;

      if (error) {
        console.error("Database error fetching summaries for DEFAULT user", DEFAULT_USER_ID, ":", error);
        // Even with DEFAULT_USER_ID, RLS might still be active on the table!
        // If RLS is active and configured to check auth.uid(), this query might fail with 42501
        // because auth.uid() will be null or different from DEFAULT_USER_ID.
        // For this MVP phase using DEFAULT_USER_ID, you might need RLS on meeting_summaries
        // temporarily disabled during local testing, or modified to allow SELECT if user_id = DEFAULT_USER_ID
        // or auth.uid() is null/different. This is a conflict in MVP rules.
        // Assuming for this MVP, RLS is permissive enough for DEFAULT_USER_ID queries *or* temporarily disabled.
        if ((error as any).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          // Re-throw as 500, hiding specific RLS error
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summaries from database.");
      }

      if (!data) {
        console.warn("GET /api/summaries (DEFAULT_USER): Select query returned no data and no error.");
        return []; // Return empty array if no data
      }

      // Map DB rows to frontend DTOs
      const summariesDto: MeetingSummaryListEntryDto[] = data.map((row) => ({
        id: row.id,
        title: row.title,
        file_name: row.file_name,
        created_at: row.created_at,
        updated_at: row.modified_at, // Map DB modified_at to API updated_at
      }));

      return summariesDto;
    } catch (error) {
      console.error("Error in SummaryService.listDefaultUserSummaries:", error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to get details of a single summary for the DEFAULT_USER_ID
  async getDefaultUserSummaryDetails(id: string): Promise<MeetingSummaryDetailsDto | null> {
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID for details (MVP ONLY).`
    );
    try {
      // Select all relevant columns (excluding user_id as per DTO)
      const query = this.supabase
        .from("meeting_summaries")
        .select("id, title, file_name, created_at, modified_at, transcription, summary, llm_generated, notes")
        .eq("id", id)
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Use single() for one expected row

      const { data, error } = await query;

      if (error && error.code === "PGRST116") {
        // Supabase specific error code for "no rows found"
        console.warn(`Summary not found for ID ${id} or not owned by DEFAULT user ${DEFAULT_USER_ID}.`);
        return null; // Return null for 404 case
      } else if (error) {
        console.error(
          `Database error fetching summary details for ID ${id} and DEFAULT user ${DEFAULT_USER_ID}:`,
          error
        );
        if ((error as any).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summary details from database.");
      }

      if (!data) {
        console.warn(`GET /api/summaries/${id} (DEFAULT_USER): Single query returned no data and no error.`);
        return null; // Should be caught by PGRST116 above, but safety check
      }

      // Map DB row to frontend DTO
      const summaryDto: MeetingSummaryDetailsDto = {
        id: data.id,
        title: data.title,
        file_name: data.file_name,
        created_at: data.created_at,
        updated_at: data.modified_at, // Map DB modified_at to API updated_at
        transcription: data.transcription,
        summary: data.summary,
        llm_generated: data.llm_generated,
        notes: data.notes,
      };

      return summaryDto;
    } catch (error) {
      console.error(`Error in SummaryService.getDefaultUserSummaryDetails for ID ${id}:`, error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to create a new summary for the DEFAULT_USER_ID
  async createDefaultUserSummary(data: CreateSummaryRequestDTO): Promise<MeetingSummaryFullRow> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for creation (MVP ONLY).`);
    // Prepare data for insertion, explicitly setting user_id to DEFAULT_USER_ID
    const dataToInsert: MeetingSummaryInsertData = {
      user_id: DEFAULT_USER_ID, // Assign to DEFAULT user
      file_name: data.file_name,
      transcription: data.transcription,
      summary: data.summary,
      llm_generated: data.llm_generated,
      notes: data.notes, // notes can be string or null from validation
      title:
        data.file_name && data.file_name.trim().length > 0
          ? data.file_name.trim()
          : data.transcription.trim().substring(0, 50) + (data.transcription.trim().length > 50 ? "..." : ""), // Generate title
    };

    console.log("Attempting to insert data into DB for DEFAULT user:", dataToInsert);
    try {
      // Execute the insert query
      // If RLS insert policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .insert([dataToInsert]) // Insert the prepared data
        .select() // Select the inserted row
        .single(); // Expect a single row

      if (result.error) {
        console.error("Database insertion failed for DEFAULT user:", result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Insert for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows insert for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to save summary to database.");
      }

      if (!result.data) {
        console.error("SummaryService.createDefaultUserSummary: Insert returned no error but no data.");
        throw new Error("Database insertion failed unexpectedly.");
      }

      console.log("Database insertion successful for DEFAULT user. New summary ID:", result.data.id);
      return result.data;
    } catch (error) {
      console.error("Error in SummaryService.createDefaultUserSummary:", error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to update an existing summary for the DEFAULT_USER_ID
  async updateDefaultUserSummary(id: string, data: UpdateSummaryRequestDTO): Promise<MeetingSummaryFullRow> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for update (MVP ONLY).`);
    console.log(`Attempting to update summary ${id} for DEFAULT user with data:`, data);
    try {
      // Execute the update query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS update policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .update(data) // Update with the provided data
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .select() // Select the updated row
        .single(); // Expect a single row

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows updated"
        console.warn(`Update attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        // Return null or throw specific error for handler to return 404
        const notFoundError = new Error(`Summary with ID ${id} not found or access denied.`);
        (notFoundError as any).status = 404; // Tag error for handler
        throw notFoundError;
      } else if (result.error) {
        console.error(`Database update failed for ID ${id} and DEFAULT user:`, result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Update for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows update for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to update summary in database.");
      }

      if (!result.data) {
        console.error(`SummaryService.updateDefaultUserSummary: Update returned no error but no data for ID ${id}.`);
        throw new Error("Database update failed unexpectedly.");
      }

      console.log(`Database update successful for ID ${id} and DEFAULT user.`);
      return result.data;
    } catch (error) {
      console.error(`Error in SummaryService.updateDefaultUserSummary for ID ${id}:`, error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to delete an existing summary for the DEFAULT_USER_ID
  async deleteDefaultUserSummary(id: string): Promise<void> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for delete (MVP ONLY).`);
    console.log(`Attempting to delete summary ${id} for DEFAULT user ${DEFAULT_USER_ID}`);
    try {
      // Execute the delete query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS delete policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<null> = await this.supabase
        .from("meeting_summaries")
        .delete() // Perform deletion
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Expect a single row deleted or none

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows found"
        console.warn(`Delete attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        const notFoundError = new Error(`Summary with ID ${id} not found or access denied.`);
        (notFoundError as any).status = 404; // Tag error for handler
        throw notFoundError;
      } else if (result.error) {
        console.error(`Database delete failed for ID ${id} and DEFAULT user:`, result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Delete for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows delete for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to delete summary from database.");
      }

      // Success! result.data will be null for delete single().
      console.log(`Database delete successful for ID ${id} and DEFAULT user.`);
      return; // Return void on success
    } catch (error) {
      console.error(`Error in SummaryService.deleteDefaultUserSummary for ID ${id}:`, error);
      throw error; // Re-throw to be caught by API handler
    }
  }
}

// --- Handler endpoint GET /api/summaries ---
// Implements the List Summaries endpoint.
// Authentication check is SKIPPED. Data filtered by DEFAULT_USER_ID.
export const GET: APIRoute = async ({ url, locals }) => {
  const supabase = locals.supabase as SupabaseClient;

  // --- Get Supabase client from context.locals ---
  if (!supabase) {
    console.error("GET /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "GET /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data filtered by DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used

  // --- Use Zod for parameter validation (GET) ---
  const queryParams = Object.fromEntries(url.searchParams.entries());
  const validationResult = listSummariesParamsSchema.safeParse(queryParams);

  if (!validationResult.success) {
    console.error("GET /api/summaries: Query parameter validation failed:", validationResult.error);
    return new Response(
      JSON.stringify({
        message: "Invalid query parameters",
        errors: validationResult.error.format(),
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  const validatedParams = validationResult.data;

  // --- Determine Date Range ---
  let fromDate: Date | undefined;
  let toDate: Date | undefined;

  if (validatedParams.from_dt === undefined && validatedParams.to_dt === undefined) {
    // Default to last 7 days
    const now = new Date();
    toDate = endOfDay(now); // End of today
    fromDate = startOfDay(new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)); // Start of 7 days ago
    console.log(`DEBUG: Using default 7-day filter: from ${fromDate.toISOString()} to ${toDate.toISOString()}`);
  } else {
    if (validatedParams.from_dt !== undefined) {
      // Parse the date string provided
      fromDate = parseISO(validatedParams.from_dt);
      if (isNaN(fromDate.getTime())) fromDate = undefined; // Handle potential parse failure after refine
    }
    if (validatedParams.to_dt !== undefined) {
      // Parse the date string provided
      toDate = parseISO(validatedParams.to_dt);
      if (isNaN(toDate.getTime())) toDate = undefined; // Handle potential parse failure after refine
    }
    console.log(
      `DEBUG: Using provided date filters: from ${fromDate?.toISOString() || "none"} to ${toDate?.toISOString() || "none"}`
    );
  }

  // Map API sort_by terms to DB column names for the Service layer
  const dbSortBy: ListSummariesServiceParams["sortParams"]["by"] =
    validatedParams.sort_by === "updated_at" ? "modified_at" : "created_at";
  const sortOrder: ListSummariesServiceParams["sortParams"]["order"] = validatedParams.sort_order;

  try {
    const summaryService = new SummaryService(supabase);

    const serviceParams: ListSummariesServiceParams = {
      userId: DEFAULT_USER_ID, // Pass DEFAULT user ID to service
      dateRange: { from: fromDate, to: toDate },
      sortParams: { by: dbSortBy, order: sortOrder },
    };

    // Use the specific service method for the default user
    const summariesDto: MeetingSummaryListEntryDto[] = await summaryService.listDefaultUserSummaries(serviceParams);

    return new Response(JSON.stringify(summariesDto), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });
  } catch (error) {
    console.error("Caught error in GET /api/summaries handler (DEFAULT_USER):", error);
    if ((error as any).status === 404 || (error as any).status === 403) {
      return new Response(JSON.stringify({ message: (error as any).message || "Access Denied/Not Found" }), {
        status: (error as any).status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ message: "An internal server error occurred" }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint POST /api/summaries ---
// Implements the Create New Summary endpoint.
// Authentication check is SKIPPED. Data assigned to DEFAULT_USER_ID.
export const POST: APIRoute = async ({ request, locals }) => {
  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("POST /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "POST /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data assigned to DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;

  try {
    requestBody = await request.json();
  } catch (error) {
    console.error("POST /api/summaries: Failed to parse request body as JSON:", error);
    return new Response(
      JSON.stringify({
        error: "Invalid JSON body",
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  try {
    const validationResult = createSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error("POST /api/summaries: Input validation failed:", validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        {
          status: 400,
          headers: { "Content-Type": "application/json" },
        }
      );
    }

    const validatedData = validationResult.data;

    // --- Call Service to insert data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass validated data to service. Service will use DEFAULT_USER_ID internally.
    const newSummaryRecord: MeetingSummaryFullRow = await summaryService.createDefaultUserSummary(validatedData);

    console.log(
      "POST /api/summaries: Successfully created new summary record with ID:",
      newSummaryRecord.id,
      "for DEFAULT user."
    );

    // Map DB row to frontend DTO
    const responseData: CreateSummaryResponseDTO = {
      id: newSummaryRecord.id,
      user_id: newSummaryRecord.user_id,
      file_name: newSummaryRecord.file_name,
      created_at: newSummaryRecord.created_at,
      updated_at: newSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: newSummaryRecord.transcription,
      summary: newSummaryRecord.summary,
      llm_generated: newSummaryRecord.llm_generated,
      notes: newSummaryRecord.notes,
      title: newSummaryRecord.title,
    };

    return new Response(JSON.stringify(responseData), {
      status: 201, // 201 Created
      headers: {
        "Content-Type": "application/json",
        Location: `/api/summaries/${responseData.id}`, // HATEOAS principle
      },
    });
  } catch (error) {
    console.error("Caught error in POST /api/summaries handler (DEFAULT_USER):", error);
    if ((error as any).status === 404 || (error as any).status === 403) {
      return new Response(JSON.stringify({ message: (error as any).message || "Access Denied/Not Found" }), {
        status: (error as any).status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ error: "An internal server error occurred while saving the summary." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint PUT /api/summaries/{id} ---
// Implements the Update Existing Summary endpoint.
// Authentication check is SKIPPED. Updates summary for DEFAULT_USER_ID.
export const PUT: APIRoute = async ({ params, request, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("PUT /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("PUT /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `PUT /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Updates summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;
  try {
    // --- Parse Request Body ---
    requestBody = await request.json();
  } catch (error) {
    console.error(`PUT /api/summaries/${summaryId}: Failed to parse request body as JSON:`, error);
    return new Response(JSON.stringify({ error: "Invalid JSON body" }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  try {
    // --- Input Validation (zod) ---
    const validationResult = updateSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error(`PUT /api/summaries/${summaryId}: Input validation failed:`, validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }

    const validatedData: UpdateSummaryRequestDTO = validationResult.data;

    // Ensure there's at least one field being updated
    if (Object.keys(validatedData).length === 0) {
      console.warn(`PUT /api/summaries/${summaryId}: Request body is empty, no fields to update.`);
      return new Response(JSON.stringify({ error: "Request body must contain fields to update." }), {
        status: 400,
        headers: { "Content-Type": "application/json" },
      });
    }

    // --- Call Service to update data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass updated data and summaryId to service. Service will use DEFAULT_USER_ID internally.
    const updatedSummaryRecord: MeetingSummaryFullRow = await summaryService.updateDefaultUserSummary(
      summaryId,
      validatedData
    );

    console.log(`PUT /api/summaries/${summaryId}: Successfully updated summary record for DEFAULT user.`);

    // Map DB row to frontend DTO (MeetingSummaryDetailsDto for consistency with GET details)
    const responseData: MeetingSummaryDetailsDto = {
      id: updatedSummaryRecord.id,
      title: updatedSummaryRecord.title, // Include title as it's in the DB row
      file_name: updatedSummaryRecord.file_name,
      created_at: updatedSummaryRecord.created_at,
      updated_at: updatedSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: updatedSummaryRecord.transcription,
      summary: updatedSummaryRecord.summary,
      llm_generated: updatedSummaryRecord.llm_generated,
      notes: updatedSummaryRecord.notes,
      // user_id is omitted from this DTO
    };

    return new Response(JSON.stringify(responseData), {
      status: 200, // 200 OK
      headers: { "Content-Type": "application/json" },
    });
  } catch (error) {
    console.error(`PUT /api/summaries/${summaryId}: Caught error after validation (DEFAULT_USER):`, error);
    if ((error as any).status === 404) {
      return new Response(
        JSON.stringify({
          message: (error as any).message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    if ((error as any).status === 403) {
      // This might happen if RLS is still partially active
      return new Response(
        JSON.stringify({
          message:
            (error as any).message ||
            `Permission denied for summary ID ${summaryId}. Ensure RLS allows access for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while updating summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

// --- Handler endpoint DELETE /api/summaries/{id} ---
// Implements the Delete Summary endpoint.
// Authentication check is SKIPPED. Deletes summary for DEFAULT_USER_ID.
export const DELETE: APIRoute = async ({ params, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("DELETE /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("DELETE /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `DELETE /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Deletes summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  try {
    // --- Call Service to delete data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass summaryId to service. Service will use DEFAULT_USER_ID internally.
    await summaryService.deleteDefaultUserSummary(summaryId);

    console.log(`DELETE /api/summaries/${summaryId}: Successfully deleted summary record for DEFAULT user.`);

    return new Response(null, {
      // 204 No Content
      status: 204,
      // No body for 204 response
    });
  } catch (error) {
    console.error(`DELETE /api/summaries/${summaryId}: Caught error (DEFAULT_USER):`, error);
    if ((error as any).status === 404) {
      return new Response(
        JSON.stringify({
          message: (error as any).message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    if ((error as any).status === 403) {
      // This might happen if RLS is still partially active
      return new Response(
        JSON.stringify({
          message:
            (error as any).message ||
            `Permission denied for summary ID ${summaryId}. Ensure RLS allows delete for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while deleting summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

export const prerender = false; // Needed for server routes



================================================
File: .history/src/pages/api/summaries_20250421133944.ts
================================================
/* eslint-disable no-console */
// src/pages/api/summaries.ts -- Handlers for /api/summaries (GET, POST, PUT, DELETE)

import type { APIRoute } from "astro";
import { z } from "zod"; // Import the Zod library

// Import your local SupabaseClient type alias AND the default user ID
// IMPORTANT: Using DEFAULT_USER_ID instead of auth.uid() for DB operations in this MVP!
import type { SupabaseClient } from "../../db/supabase.client";
import { DEFAULT_USER_ID } from "../../db/supabase.client"; // Import the default user ID

// Import Supabase specific types for better error handling and results
import type { PostgrestSingleResponse, PostgrestResponse } from "@supabase/supabase-js";

// Import shared DTOs and DB internal types from central types file
import type {
  MeetingSummaryListEntryDto,
  CreateSummaryRequestDTO,
  CreateSummaryResponseDTO,
  UpdateSummaryRequestDTO,
  MeetingSummaryInsertData,
  MeetingSummaryFullRow,
  MeetingSummarySelectedColumns,
  ListSummariesServiceParams,
} from "../../types"; // Adjust the path if necessary

// Import date-fns parseISO for robust date parsing and date helpers
import { parseISO, startOfDay, endOfDay } from "date-fns";

// --- Zod Schema for List Summaries Query Parameters (for GET /api/summaries) ---
const listSummariesParamsSchema = z.object({
  sort_by: z.enum(["created_at", "updated_at"]).optional().default("created_at"),
  sort_order: z.enum(["asc", "desc"]).optional().default("desc"),
  // Accept date strings (YYYY-MM-DD from input type="date") or full ISO 8601
  from_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'from_dt'.",
    }),
  to_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'to_dt'.",
    }),
});

// --- Zod Schema for Create Summary Request Body (for POST /api/summaries) ---
const createSummaryRequestSchema = z.object({
  file_name: z.string().nullable().optional(), // nullable() allows null, optional() allows undefined
  transcription: z.string().min(1, { message: "Transcription cannot be empty." }),
  summary: z
    .string()
    .min(1, { message: "Summary cannot be empty." })
    .max(500, { message: "Summary cannot exceed 500 characters." }),
  llm_generated: z.boolean({ required_error: "Field 'llm_generated' is required and must be a boolean." }),
  notes: z
    .string()
    .nullable()
    .optional()
    .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
});

// --- Zod Schema for Update Summary Request Body (for PUT /api/summaries/{id}) ---
// Allows partial updates
const updateSummaryRequestSchema = z
  .object({
    file_name: z.string().nullable().optional(),
    transcription: z.string().min(1, { message: "Transcription cannot be empty." }).optional(),
    summary: z
      .string()
      .min(1, { message: "Summary cannot be empty." })
      .max(500, { message: "Summary cannot exceed 500 characters." })
      .optional(),
    llm_generated: z.boolean().optional(),
    notes: z
      .string()
      .nullable()
      .optional()
      .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
  })
  .partial(); // Make all fields optional at the top level

// --- SummaryService Class (Central logic for DB interaction) ---
// IMPORTANT: In this MVP version, this service uses DEFAULT_USER_ID for DB operations
// instead of relying on auth.uid() via RLS. This is INSECURE and for MVP ONLY.
class SummaryService {
  constructor(private supabase: SupabaseClient) {}

  // Method to list summaries for the DEFAULT_USER_ID
  async listDefaultUserSummaries(params: ListSummariesServiceParams): Promise<MeetingSummaryListEntryDto[]> {
    // userId parameter is included for type compatibility but ignored in this MVP implementation
    // as we are hardcoding DEFAULT_USER_ID.
    const { dateRange, sortParams } = params;
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID (MVP ONLY).`
    );

    try {
      // Select specific columns for the list view
      let query = this.supabase.from("meeting_summaries").select("id, title, file_name, created_at, modified_at");

      // Explicitly filter by DEFAULT_USER_ID, overriding standard RLS based on auth.uid()
      query = query.eq("user_id", DEFAULT_USER_ID);

      if (dateRange.from) {
        // Use >= for 'from' date (start of the day)
        query = query.gte("created_at", startOfDay(dateRange.from).toISOString());
      }
      if (dateRange.to) {
        // Use <= for 'to' date (end of the day)
        query = query.lte("created_at", endOfDay(dateRange.to).toISOString());
      }

      // Map API sort_by terms to DB column names
      const dbSortBy = sortParams.by === "updated_at" ? "modified_at" : "created_at";

      // Apply sorting
      query = query.order(dbSortBy, { ascending: sortParams.order === "asc" });

      // Execute the query
      const result: PostgrestResponse<MeetingSummarySelectedColumns> = await query;
      const { data, error } = result;

      if (error) {
        console.error("Database error fetching summaries for DEFAULT user", DEFAULT_USER_ID, ":", error);
        // Even with DEFAULT_USER_ID, RLS might still be active on the table!
        // If RLS is active and configured to check auth.uid(), this query might fail with 42501
        // because auth.uid() will be null or different from DEFAULT_USER_ID.
        // For this MVP phase using DEFAULT_USER_ID, you might need RLS on meeting_summaries
        // temporarily disabled during local testing, or modified to allow SELECT if user_id = DEFAULT_USER_ID
        // or auth.uid() is null/different. This is a conflict in MVP rules.
        // Assuming for this MVP, RLS is permissive enough for DEFAULT_USER_ID queries *or* temporarily disabled.
        if ((error as any).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          // Re-throw as 500, hiding specific RLS error
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summaries from database.");
      }

      if (!data) {
        console.warn("GET /api/summaries (DEFAULT_USER): Select query returned no data and no error.");
        return []; // Return empty array if no data
      }

      // Map DB rows to frontend DTOs
      const summariesDto: MeetingSummaryListEntryDto[] = data.map((row) => ({
        id: row.id,
        title: row.title,
        file_name: row.file_name,
        created_at: row.created_at,
        updated_at: row.modified_at, // Map DB modified_at to API updated_at
      }));

      return summariesDto;
    } catch (error) {
      console.error("Error in SummaryService.listDefaultUserSummaries:", error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to get details of a single summary for the DEFAULT_USER_ID
  async getDefaultUserSummaryDetails(id: string): Promise<MeetingSummaryDetailsDto | null> {
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID for details (MVP ONLY).`
    );
    try {
      // Select all relevant columns (excluding user_id as per DTO)
      const query = this.supabase
        .from("meeting_summaries")
        .select("id, title, file_name, created_at, modified_at, transcription, summary, llm_generated, notes")
        .eq("id", id)
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Use single() for one expected row

      const { data, error } = await query;

      if (error && error.code === "PGRST116") {
        // Supabase specific error code for "no rows found"
        console.warn(`Summary not found for ID ${id} or not owned by DEFAULT user ${DEFAULT_USER_ID}.`);
        return null; // Return null for 404 case
      } else if (error) {
        console.error(
          `Database error fetching summary details for ID ${id} and DEFAULT user ${DEFAULT_USER_ID}:`,
          error
        );
        if ((error as any).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summary details from database.");
      }

      if (!data) {
        console.warn(`GET /api/summaries/${id} (DEFAULT_USER): Single query returned no data and no error.`);
        return null; // Should be caught by PGRST116 above, but safety check
      }

      // Map DB row to frontend DTO
      const summaryDto: MeetingSummaryDetailsDto = {
        id: data.id,
        title: data.title,
        file_name: data.file_name,
        created_at: data.created_at,
        updated_at: data.modified_at, // Map DB modified_at to API updated_at
        transcription: data.transcription,
        summary: data.summary,
        llm_generated: data.llm_generated,
        notes: data.notes,
      };

      return summaryDto;
    } catch (error) {
      console.error(`Error in SummaryService.getDefaultUserSummaryDetails for ID ${id}:`, error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to create a new summary for the DEFAULT_USER_ID
  async createDefaultUserSummary(data: CreateSummaryRequestDTO): Promise<MeetingSummaryFullRow> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for creation (MVP ONLY).`);
    // Prepare data for insertion, explicitly setting user_id to DEFAULT_USER_ID
    const dataToInsert: MeetingSummaryInsertData = {
      user_id: DEFAULT_USER_ID, // Assign to DEFAULT user
      file_name: data.file_name,
      transcription: data.transcription,
      summary: data.summary,
      llm_generated: data.llm_generated,
      notes: data.notes, // notes can be string or null from validation
      title:
        data.file_name && data.file_name.trim().length > 0
          ? data.file_name.trim()
          : data.transcription.trim().substring(0, 50) + (data.transcription.trim().length > 50 ? "..." : ""), // Generate title
    };

    console.log("Attempting to insert data into DB for DEFAULT user:", dataToInsert);
    try {
      // Execute the insert query
      // If RLS insert policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .insert([dataToInsert]) // Insert the prepared data
        .select() // Select the inserted row
        .single(); // Expect a single row

      if (result.error) {
        console.error("Database insertion failed for DEFAULT user:", result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Insert for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows insert for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to save summary to database.");
      }

      if (!result.data) {
        console.error("SummaryService.createDefaultUserSummary: Insert returned no error but no data.");
        throw new Error("Database insertion failed unexpectedly.");
      }

      console.log("Database insertion successful for DEFAULT user. New summary ID:", result.data.id);
      return result.data;
    } catch (error) {
      console.error("Error in SummaryService.createDefaultUserSummary:", error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to update an existing summary for the DEFAULT_USER_ID
  async updateDefaultUserSummary(id: string, data: UpdateSummaryRequestDTO): Promise<MeetingSummaryFullRow> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for update (MVP ONLY).`);
    console.log(`Attempting to update summary ${id} for DEFAULT user with data:`, data);
    try {
      // Execute the update query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS update policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .update(data) // Update with the provided data
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .select() // Select the updated row
        .single(); // Expect a single row

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows updated"
        console.warn(`Update attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        // Return null or throw specific error for handler to return 404
        const notFoundError = new Error(`Summary with ID ${id} not found or access denied.`);
        (notFoundError as any).status = 404; // Tag error for handler
        throw notFoundError;
      } else if (result.error) {
        console.error(`Database update failed for ID ${id} and DEFAULT user:`, result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Update for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows update for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to update summary in database.");
      }

      if (!result.data) {
        console.error(`SummaryService.updateDefaultUserSummary: Update returned no error but no data for ID ${id}.`);
        throw new Error("Database update failed unexpectedly.");
      }

      console.log(`Database update successful for ID ${id} and DEFAULT user.`);
      return result.data;
    } catch (error) {
      console.error(`Error in SummaryService.updateDefaultUserSummary for ID ${id}:`, error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to delete an existing summary for the DEFAULT_USER_ID
  async deleteDefaultUserSummary(id: string): Promise<void> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for delete (MVP ONLY).`);
    console.log(`Attempting to delete summary ${id} for DEFAULT user ${DEFAULT_USER_ID}`);
    try {
      // Execute the delete query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS delete policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<null> = await this.supabase
        .from("meeting_summaries")
        .delete() // Perform deletion
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Expect a single row deleted or none

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows found"
        console.warn(`Delete attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        const notFoundError = new Error(`Summary with ID ${id} not found or access denied.`);
        (notFoundError as any).status = 404; // Tag error for handler
        throw notFoundError;
      } else if (result.error) {
        console.error(`Database delete failed for ID ${id} and DEFAULT user:`, result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Delete for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows delete for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to delete summary from database.");
      }

      // Success! result.data will be null for delete single().
      console.log(`Database delete successful for ID ${id} and DEFAULT user.`);
      return; // Return void on success
    } catch (error) {
      console.error(`Error in SummaryService.deleteDefaultUserSummary for ID ${id}:`, error);
      throw error; // Re-throw to be caught by API handler
    }
  }
}

// --- Handler endpoint GET /api/summaries ---
// Implements the List Summaries endpoint.
// Authentication check is SKIPPED. Data filtered by DEFAULT_USER_ID.
export const GET: APIRoute = async ({ url, locals }) => {
  const supabase = locals.supabase as SupabaseClient;

  // --- Get Supabase client from context.locals ---
  if (!supabase) {
    console.error("GET /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "GET /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data filtered by DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used

  // --- Use Zod for parameter validation (GET) ---
  const queryParams = Object.fromEntries(url.searchParams.entries());
  const validationResult = listSummariesParamsSchema.safeParse(queryParams);

  if (!validationResult.success) {
    console.error("GET /api/summaries: Query parameter validation failed:", validationResult.error);
    return new Response(
      JSON.stringify({
        message: "Invalid query parameters",
        errors: validationResult.error.format(),
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  const validatedParams = validationResult.data;

  // --- Determine Date Range ---
  let fromDate: Date | undefined;
  let toDate: Date | undefined;

  if (validatedParams.from_dt === undefined && validatedParams.to_dt === undefined) {
    // Default to last 7 days
    const now = new Date();
    toDate = endOfDay(now); // End of today
    fromDate = startOfDay(new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)); // Start of 7 days ago
    console.log(`DEBUG: Using default 7-day filter: from ${fromDate.toISOString()} to ${toDate.toISOString()}`);
  } else {
    if (validatedParams.from_dt !== undefined) {
      // Parse the date string provided
      fromDate = parseISO(validatedParams.from_dt);
      if (isNaN(fromDate.getTime())) fromDate = undefined; // Handle potential parse failure after refine
    }
    if (validatedParams.to_dt !== undefined) {
      // Parse the date string provided
      toDate = parseISO(validatedParams.to_dt);
      if (isNaN(toDate.getTime())) toDate = undefined; // Handle potential parse failure after refine
    }
    console.log(
      `DEBUG: Using provided date filters: from ${fromDate?.toISOString() || "none"} to ${toDate?.toISOString() || "none"}`
    );
  }

  // Map API sort_by terms to DB column names for the Service layer
  const dbSortBy: ListSummariesServiceParams["sortParams"]["by"] =
    validatedParams.sort_by === "updated_at" ? "modified_at" : "created_at";
  const sortOrder: ListSummariesServiceParams["sortParams"]["order"] = validatedParams.sort_order;

  try {
    const summaryService = new SummaryService(supabase);

    const serviceParams: ListSummariesServiceParams = {
      userId: DEFAULT_USER_ID, // Pass DEFAULT user ID to service
      dateRange: { from: fromDate, to: toDate },
      sortParams: { by: dbSortBy, order: sortOrder },
    };

    // Use the specific service method for the default user
    const summariesDto: MeetingSummaryListEntryDto[] = await summaryService.listDefaultUserSummaries(serviceParams);

    return new Response(JSON.stringify(summariesDto), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });
  } catch (error) {
    console.error("Caught error in GET /api/summaries handler (DEFAULT_USER):", error);
    if ((error as any).status === 404 || (error as any).status === 403) {
      return new Response(JSON.stringify({ message: (error as any).message || "Access Denied/Not Found" }), {
        status: (error as any).status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ message: "An internal server error occurred" }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint POST /api/summaries ---
// Implements the Create New Summary endpoint.
// Authentication check is SKIPPED. Data assigned to DEFAULT_USER_ID.
export const POST: APIRoute = async ({ request, locals }) => {
  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("POST /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "POST /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data assigned to DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;

  try {
    requestBody = await request.json();
  } catch (error) {
    console.error("POST /api/summaries: Failed to parse request body as JSON:", error);
    return new Response(
      JSON.stringify({
        error: "Invalid JSON body",
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  try {
    const validationResult = createSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error("POST /api/summaries: Input validation failed:", validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        {
          status: 400,
          headers: { "Content-Type": "application/json" },
        }
      );
    }

    const validatedData = validationResult.data;

    // --- Call Service to insert data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass validated data to service. Service will use DEFAULT_USER_ID internally.
    const newSummaryRecord: MeetingSummaryFullRow = await summaryService.createDefaultUserSummary(validatedData);

    console.log(
      "POST /api/summaries: Successfully created new summary record with ID:",
      newSummaryRecord.id,
      "for DEFAULT user."
    );

    // Map DB row to frontend DTO
    const responseData: CreateSummaryResponseDTO = {
      id: newSummaryRecord.id,
      user_id: newSummaryRecord.user_id,
      file_name: newSummaryRecord.file_name,
      created_at: newSummaryRecord.created_at,
      updated_at: newSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: newSummaryRecord.transcription,
      summary: newSummaryRecord.summary,
      llm_generated: newSummaryRecord.llm_generated,
      notes: newSummaryRecord.notes,
      title: newSummaryRecord.title,
    };

    return new Response(JSON.stringify(responseData), {
      status: 201, // 201 Created
      headers: {
        "Content-Type": "application/json",
        Location: `/api/summaries/${responseData.id}`, // HATEOAS principle
      },
    });
  } catch (error) {
    console.error("Caught error in POST /api/summaries handler (DEFAULT_USER):", error);
    if ((error as any).status === 404 || (error as any).status === 403) {
      return new Response(JSON.stringify({ message: (error as any).message || "Access Denied/Not Found" }), {
        status: (error as any).status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ error: "An internal server error occurred while saving the summary." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint PUT /api/summaries/{id} ---
// Implements the Update Existing Summary endpoint.
// Authentication check is SKIPPED. Updates summary for DEFAULT_USER_ID.
export const PUT: APIRoute = async ({ params, request, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("PUT /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("PUT /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `PUT /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Updates summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;
  try {
    // --- Parse Request Body ---
    requestBody = await request.json();
  } catch (error) {
    console.error(`PUT /api/summaries/${summaryId}: Failed to parse request body as JSON:`, error);
    return new Response(JSON.stringify({ error: "Invalid JSON body" }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  try {
    // --- Input Validation (zod) ---
    const validationResult = updateSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error(`PUT /api/summaries/${summaryId}: Input validation failed:`, validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }

    const validatedData: UpdateSummaryRequestDTO = validationResult.data;

    // Ensure there's at least one field being updated
    if (Object.keys(validatedData).length === 0) {
      console.warn(`PUT /api/summaries/${summaryId}: Request body is empty, no fields to update.`);
      return new Response(JSON.stringify({ error: "Request body must contain fields to update." }), {
        status: 400,
        headers: { "Content-Type": "application/json" },
      });
    }

    // --- Call Service to update data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass updated data and summaryId to service. Service will use DEFAULT_USER_ID internally.
    const updatedSummaryRecord: MeetingSummaryFullRow = await summaryService.updateDefaultUserSummary(
      summaryId,
      validatedData
    );

    console.log(`PUT /api/summaries/${summaryId}: Successfully updated summary record for DEFAULT user.`);

    // Map DB row to frontend DTO (MeetingSummaryDetailsDto for consistency with GET details)
    const responseData: MeetingSummaryDetailsDto = {
      id: updatedSummaryRecord.id,
      title: updatedSummaryRecord.title, // Include title as it's in the DB row
      file_name: updatedSummaryRecord.file_name,
      created_at: updatedSummaryRecord.created_at,
      updated_at: updatedSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: updatedSummaryRecord.transcription,
      summary: updatedSummaryRecord.summary,
      llm_generated: updatedSummaryRecord.llm_generated,
      notes: updatedSummaryRecord.notes,
      // user_id is omitted from this DTO
    };

    return new Response(JSON.stringify(responseData), {
      status: 200, // 200 OK
      headers: { "Content-Type": "application/json" },
    });
  } catch (error) {
    console.error(`PUT /api/summaries/${summaryId}: Caught error after validation (DEFAULT_USER):`, error);
    if ((error as any).status === 404) {
      return new Response(
        JSON.stringify({
          message: (error as any).message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    if ((error as any).status === 403) {
      // This might happen if RLS is still partially active
      return new Response(
        JSON.stringify({
          message:
            (error as any).message ||
            `Permission denied for summary ID ${summaryId}. Ensure RLS allows access for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while updating summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

// --- Handler endpoint DELETE /api/summaries/{id} ---
// Implements the Delete Summary endpoint.
// Authentication check is SKIPPED. Deletes summary for DEFAULT_USER_ID.
export const DELETE: APIRoute = async ({ params, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("DELETE /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("DELETE /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `DELETE /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Deletes summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  try {
    // --- Call Service to delete data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass summaryId to service. Service will use DEFAULT_USER_ID internally.
    await summaryService.deleteDefaultUserSummary(summaryId);

    console.log(`DELETE /api/summaries/${summaryId}: Successfully deleted summary record for DEFAULT user.`);

    return new Response(null, {
      // 204 No Content
      status: 204,
      // No body for 204 response
    });
  } catch (error) {
    console.error(`DELETE /api/summaries/${summaryId}: Caught error (DEFAULT_USER):`, error);
    if ((error as any).status === 404) {
      return new Response(
        JSON.stringify({
          message: (error as any).message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    if ((error as any).status === 403) {
      // This might happen if RLS is still partially active
      return new Response(
        JSON.stringify({
          message:
            (error as any).message ||
            `Permission denied for summary ID ${summaryId}. Ensure RLS allows delete for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while deleting summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

export const prerender = false; // Needed for server routes



================================================
File: .history/src/pages/api/summaries_20250421134314.ts
================================================
/* eslint-disable no-console */
// src/pages/api/summaries.ts -- Handlers for /api/summaries (GET, POST, PUT, DELETE)

import type { APIRoute } from "astro";
import { z } from "zod"; // Import the Zod library

// Import your local SupabaseClient type alias AND the default user ID
// IMPORTANT: Using DEFAULT_USER_ID instead of auth.uid() for DB operations in this MVP!
import type { SupabaseClient } from "../../db/supabase.client";
import { DEFAULT_USER_ID } from "../../db/supabase.client"; // Import the default user ID

// Import Supabase specific types for better error handling and results
import type { PostgrestSingleResponse, PostgrestResponse } from "@supabase/supabase-js";

// Import shared DTOs and DB internal types from central types file
import type {
  MeetingSummaryListEntryDto,
  CreateSummaryRequestDTO,
  CreateSummaryResponseDTO,
  UpdateSummaryRequestDTO,
  MeetingSummaryInsertData,
  MeetingSummaryFullRow,
  MeetingSummarySelectedColumns,
  ListSummariesServiceParams,
} from "../../types"; // Adjust the path if necessary

// Import date-fns parseISO for robust date parsing and date helpers
import { parseISO, startOfDay, endOfDay } from "date-fns";

// --- Zod Schema for List Summaries Query Parameters (for GET /api/summaries) ---
const listSummariesParamsSchema = z.object({
  sort_by: z.enum(["created_at", "updated_at"]).optional().default("created_at"),
  sort_order: z.enum(["asc", "desc"]).optional().default("desc"),
  // Accept date strings (YYYY-MM-DD from input type="date") or full ISO 8601
  from_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'from_dt'.",
    }),
  to_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'to_dt'.",
    }),
});

// --- Zod Schema for Create Summary Request Body (for POST /api/summaries) ---
const createSummaryRequestSchema = z.object({
  file_name: z.string().nullable().optional(), // nullable() allows null, optional() allows undefined
  transcription: z.string().min(1, { message: "Transcription cannot be empty." }),
  summary: z
    .string()
    .min(1, { message: "Summary cannot be empty." })
    .max(500, { message: "Summary cannot exceed 500 characters." }),
  llm_generated: z.boolean({ required_error: "Field 'llm_generated' is required and must be a boolean." }),
  notes: z
    .string()
    .nullable()
    .optional()
    .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
});

// --- Zod Schema for Update Summary Request Body (for PUT /api/summaries/{id}) ---
// Allows partial updates
const updateSummaryRequestSchema = z
  .object({
    file_name: z.string().nullable().optional(),
    transcription: z.string().min(1, { message: "Transcription cannot be empty." }).optional(),
    summary: z
      .string()
      .min(1, { message: "Summary cannot be empty." })
      .max(500, { message: "Summary cannot exceed 500 characters." })
      .optional(),
    llm_generated: z.boolean().optional(),
    notes: z
      .string()
      .nullable()
      .optional()
      .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
  })
  .partial(); // Make all fields optional at the top level

// --- SummaryService Class (Central logic for DB interaction) ---
// IMPORTANT: In this MVP version, this service uses DEFAULT_USER_ID for DB operations
// instead of relying on auth.uid() via RLS. This is INSECURE and for MVP ONLY.
class SummaryService {
  constructor(private supabase: SupabaseClient) {}

  // Method to list summaries for the DEFAULT_USER_ID
  async listDefaultUserSummaries(params: ListSummariesServiceParams): Promise<MeetingSummaryListEntryDto[]> {
    // userId parameter is included for type compatibility but ignored in this MVP implementation
    // as we are hardcoding DEFAULT_USER_ID.
    const { dateRange, sortParams } = params;
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID (MVP ONLY).`
    );

    try {
      // Select specific columns for the list view
      let query = this.supabase.from("meeting_summaries").select("id, title, file_name, created_at, modified_at");

      // Explicitly filter by DEFAULT_USER_ID, overriding standard RLS based on auth.uid()
      query = query.eq("user_id", DEFAULT_USER_ID);

      if (dateRange.from) {
        // Use >= for 'from' date (start of the day)
        query = query.gte("created_at", startOfDay(dateRange.from).toISOString());
      }
      if (dateRange.to) {
        // Use <= for 'to' date (end of the day)
        query = query.lte("created_at", endOfDay(dateRange.to).toISOString());
      }

      // Map API sort_by terms to DB column names
      const dbSortBy = sortParams.by === "modified_at" ? "modified_at" : "created_at";

      // Apply sorting
      query = query.order(dbSortBy, { ascending: sortParams.order === "asc" });

      // Execute the query
      const result: PostgrestResponse<MeetingSummarySelectedColumns> = await query;
      const { data, error } = result;

      if (error) {
        console.error("Database error fetching summaries for DEFAULT user", DEFAULT_USER_ID, ":", error);
        // Even with DEFAULT_USER_ID, RLS might still be active on the table!
        // If RLS is active and configured to check auth.uid(), this query might fail with 42501
        // because auth.uid() will be null or different from DEFAULT_USER_ID.
        // For this MVP phase using DEFAULT_USER_ID, you might need RLS on meeting_summaries
        // temporarily disabled during local testing, or modified to allow SELECT if user_id = DEFAULT_USER_ID
        // or auth.uid() is null/different. This is a conflict in MVP rules.
        // Assuming for this MVP, RLS is permissive enough for DEFAULT_USER_ID queries *or* temporarily disabled.
        if ((error as any).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          // Re-throw as 500, hiding specific RLS error
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summaries from database.");
      }

      if (!data) {
        console.warn("GET /api/summaries (DEFAULT_USER): Select query returned no data and no error.");
        return []; // Return empty array if no data
      }

      // Map DB rows to frontend DTOs
      const summariesDto: MeetingSummaryListEntryDto[] = data.map((row) => ({
        id: row.id,
        title: row.title,
        file_name: row.file_name,
        created_at: row.created_at,
        updated_at: row.modified_at, // Map DB modified_at to API updated_at
      }));

      return summariesDto;
    } catch (error) {
      console.error("Error in SummaryService.listDefaultUserSummaries:", error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to get details of a single summary for the DEFAULT_USER_ID
  async getDefaultUserSummaryDetails(id: string): Promise<MeetingSummaryDetailsDto | null> {
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID for details (MVP ONLY).`
    );
    try {
      // Select all relevant columns (excluding user_id as per DTO)
      const query = this.supabase
        .from("meeting_summaries")
        .select("id, title, file_name, created_at, modified_at, transcription, summary, llm_generated, notes")
        .eq("id", id)
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Use single() for one expected row

      const { data, error } = await query;

      if (error && error.code === "PGRST116") {
        // Supabase specific error code for "no rows found"
        console.warn(`Summary not found for ID ${id} or not owned by DEFAULT user ${DEFAULT_USER_ID}.`);
        return null; // Return null for 404 case
      } else if (error) {
        console.error(
          `Database error fetching summary details for ID ${id} and DEFAULT user ${DEFAULT_USER_ID}:`,
          error
        );
        if ((error as any).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summary details from database.");
      }

      if (!data) {
        console.warn(`GET /api/summaries/${id} (DEFAULT_USER): Single query returned no data and no error.`);
        return null; // Should be caught by PGRST116 above, but safety check
      }

      // Map DB row to frontend DTO
      const summaryDto: MeetingSummaryDetailsDto = {
        id: data.id,
        title: data.title,
        file_name: data.file_name,
        created_at: data.created_at,
        updated_at: data.modified_at, // Map DB modified_at to API updated_at
        transcription: data.transcription,
        summary: data.summary,
        llm_generated: data.llm_generated,
        notes: data.notes,
      };

      return summaryDto;
    } catch (error) {
      console.error(`Error in SummaryService.getDefaultUserSummaryDetails for ID ${id}:`, error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to create a new summary for the DEFAULT_USER_ID
  async createDefaultUserSummary(data: CreateSummaryRequestDTO): Promise<MeetingSummaryFullRow> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for creation (MVP ONLY).`);
    // Prepare data for insertion, explicitly setting user_id to DEFAULT_USER_ID
    const dataToInsert: MeetingSummaryInsertData = {
      user_id: DEFAULT_USER_ID, // Assign to DEFAULT user
      file_name: data.file_name,
      transcription: data.transcription,
      summary: data.summary,
      llm_generated: data.llm_generated,
      notes: data.notes, // notes can be string or null from validation
      title:
        data.file_name && data.file_name.trim().length > 0
          ? data.file_name.trim()
          : data.transcription.trim().substring(0, 50) + (data.transcription.trim().length > 50 ? "..." : ""), // Generate title
    };

    console.log("Attempting to insert data into DB for DEFAULT user:", dataToInsert);
    try {
      // Execute the insert query
      // If RLS insert policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .insert([dataToInsert]) // Insert the prepared data
        .select() // Select the inserted row
        .single(); // Expect a single row

      if (result.error) {
        console.error("Database insertion failed for DEFAULT user:", result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Insert for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows insert for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to save summary to database.");
      }

      if (!result.data) {
        console.error("SummaryService.createDefaultUserSummary: Insert returned no error but no data.");
        throw new Error("Database insertion failed unexpectedly.");
      }

      console.log("Database insertion successful for DEFAULT user. New summary ID:", result.data.id);
      return result.data;
    } catch (error) {
      console.error("Error in SummaryService.createDefaultUserSummary:", error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to update an existing summary for the DEFAULT_USER_ID
  async updateDefaultUserSummary(id: string, data: UpdateSummaryRequestDTO): Promise<MeetingSummaryFullRow> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for update (MVP ONLY).`);
    console.log(`Attempting to update summary ${id} for DEFAULT user with data:`, data);
    try {
      // Execute the update query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS update policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .update(data) // Update with the provided data
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .select() // Select the updated row
        .single(); // Expect a single row

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows updated"
        console.warn(`Update attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        // Return null or throw specific error for handler to return 404
        const notFoundError = new Error(`Summary with ID ${id} not found or access denied.`);
        (notFoundError as any).status = 404; // Tag error for handler
        throw notFoundError;
      } else if (result.error) {
        console.error(`Database update failed for ID ${id} and DEFAULT user:`, result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Update for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows update for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to update summary in database.");
      }

      if (!result.data) {
        console.error(`SummaryService.updateDefaultUserSummary: Update returned no error but no data for ID ${id}.`);
        throw new Error("Database update failed unexpectedly.");
      }

      console.log(`Database update successful for ID ${id} and DEFAULT user.`);
      return result.data;
    } catch (error) {
      console.error(`Error in SummaryService.updateDefaultUserSummary for ID ${id}:`, error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to delete an existing summary for the DEFAULT_USER_ID
  async deleteDefaultUserSummary(id: string): Promise<void> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for delete (MVP ONLY).`);
    console.log(`Attempting to delete summary ${id} for DEFAULT user ${DEFAULT_USER_ID}`);
    try {
      // Execute the delete query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS delete policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<null> = await this.supabase
        .from("meeting_summaries")
        .delete() // Perform deletion
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Expect a single row deleted or none

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows found"
        console.warn(`Delete attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        const notFoundError = new Error(`Summary with ID ${id} not found or access denied.`);
        (notFoundError as any).status = 404; // Tag error for handler
        throw notFoundError;
      } else if (result.error) {
        console.error(`Database delete failed for ID ${id} and DEFAULT user:`, result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Delete for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows delete for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to delete summary from database.");
      }

      // Success! result.data will be null for delete single().
      console.log(`Database delete successful for ID ${id} and DEFAULT user.`);
      return; // Return void on success
    } catch (error) {
      console.error(`Error in SummaryService.deleteDefaultUserSummary for ID ${id}:`, error);
      throw error; // Re-throw to be caught by API handler
    }
  }
}

// --- Handler endpoint GET /api/summaries ---
// Implements the List Summaries endpoint.
// Authentication check is SKIPPED. Data filtered by DEFAULT_USER_ID.
export const GET: APIRoute = async ({ url, locals }) => {
  const supabase = locals.supabase as SupabaseClient;

  // --- Get Supabase client from context.locals ---
  if (!supabase) {
    console.error("GET /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "GET /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data filtered by DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used

  // --- Use Zod for parameter validation (GET) ---
  const queryParams = Object.fromEntries(url.searchParams.entries());
  const validationResult = listSummariesParamsSchema.safeParse(queryParams);

  if (!validationResult.success) {
    console.error("GET /api/summaries: Query parameter validation failed:", validationResult.error);
    return new Response(
      JSON.stringify({
        message: "Invalid query parameters",
        errors: validationResult.error.format(),
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  const validatedParams = validationResult.data;

  // --- Determine Date Range ---
  let fromDate: Date | undefined;
  let toDate: Date | undefined;

  if (validatedParams.from_dt === undefined && validatedParams.to_dt === undefined) {
    // Default to last 7 days
    const now = new Date();
    toDate = endOfDay(now); // End of today
    fromDate = startOfDay(new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)); // Start of 7 days ago
    console.log(`DEBUG: Using default 7-day filter: from ${fromDate.toISOString()} to ${toDate.toISOString()}`);
  } else {
    if (validatedParams.from_dt !== undefined) {
      // Parse the date string provided
      fromDate = parseISO(validatedParams.from_dt);
      if (isNaN(fromDate.getTime())) fromDate = undefined; // Handle potential parse failure after refine
    }
    if (validatedParams.to_dt !== undefined) {
      // Parse the date string provided
      toDate = parseISO(validatedParams.to_dt);
      if (isNaN(toDate.getTime())) toDate = undefined; // Handle potential parse failure after refine
    }
    console.log(
      `DEBUG: Using provided date filters: from ${fromDate?.toISOString() || "none"} to ${toDate?.toISOString() || "none"}`
    );
  }

  // Map API sort_by terms to DB column names for the Service layer
  const dbSortBy: ListSummariesServiceParams["sortParams"]["by"] =
    validatedParams.sort_by === "modified_at" ? "modified_at" : "created_at";
  const sortOrder: ListSummariesServiceParams["sortParams"]["order"] = validatedParams.sort_order;

  try {
    const summaryService = new SummaryService(supabase);

    const serviceParams: ListSummariesServiceParams = {
      userId: DEFAULT_USER_ID, // Pass DEFAULT user ID to service
      dateRange: { from: fromDate, to: toDate },
      sortParams: { by: dbSortBy, order: sortOrder },
    };

    // Use the specific service method for the default user
    const summariesDto: MeetingSummaryListEntryDto[] = await summaryService.listDefaultUserSummaries(serviceParams);

    return new Response(JSON.stringify(summariesDto), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });
  } catch (error) {
    console.error("Caught error in GET /api/summaries handler (DEFAULT_USER):", error);
    if ((error as any).status === 404 || (error as any).status === 403) {
      return new Response(JSON.stringify({ message: (error as any).message || "Access Denied/Not Found" }), {
        status: (error as any).status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ message: "An internal server error occurred" }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint POST /api/summaries ---
// Implements the Create New Summary endpoint.
// Authentication check is SKIPPED. Data assigned to DEFAULT_USER_ID.
export const POST: APIRoute = async ({ request, locals }) => {
  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("POST /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "POST /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data assigned to DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;

  try {
    requestBody = await request.json();
  } catch (error) {
    console.error("POST /api/summaries: Failed to parse request body as JSON:", error);
    return new Response(
      JSON.stringify({
        error: "Invalid JSON body",
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  try {
    const validationResult = createSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error("POST /api/summaries: Input validation failed:", validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        {
          status: 400,
          headers: { "Content-Type": "application/json" },
        }
      );
    }

    const validatedData = validationResult.data;

    // --- Call Service to insert data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass validated data to service. Service will use DEFAULT_USER_ID internally.
    const newSummaryRecord: MeetingSummaryFullRow = await summaryService.createDefaultUserSummary(validatedData);

    console.log(
      "POST /api/summaries: Successfully created new summary record with ID:",
      newSummaryRecord.id,
      "for DEFAULT user."
    );

    // Map DB row to frontend DTO
    const responseData: CreateSummaryResponseDTO = {
      id: newSummaryRecord.id,
      user_id: newSummaryRecord.user_id,
      file_name: newSummaryRecord.file_name,
      created_at: newSummaryRecord.created_at,
      updated_at: newSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: newSummaryRecord.transcription,
      summary: newSummaryRecord.summary,
      llm_generated: newSummaryRecord.llm_generated,
      notes: newSummaryRecord.notes,
      title: newSummaryRecord.title,
    };

    return new Response(JSON.stringify(responseData), {
      status: 201, // 201 Created
      headers: {
        "Content-Type": "application/json",
        Location: `/api/summaries/${responseData.id}`, // HATEOAS principle
      },
    });
  } catch (error) {
    console.error("Caught error in POST /api/summaries handler (DEFAULT_USER):", error);
    if ((error as any).status === 404 || (error as any).status === 403) {
      return new Response(JSON.stringify({ message: (error as any).message || "Access Denied/Not Found" }), {
        status: (error as any).status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ error: "An internal server error occurred while saving the summary." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint PUT /api/summaries/{id} ---
// Implements the Update Existing Summary endpoint.
// Authentication check is SKIPPED. Updates summary for DEFAULT_USER_ID.
export const PUT: APIRoute = async ({ params, request, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("PUT /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("PUT /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `PUT /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Updates summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;
  try {
    // --- Parse Request Body ---
    requestBody = await request.json();
  } catch (error) {
    console.error(`PUT /api/summaries/${summaryId}: Failed to parse request body as JSON:`, error);
    return new Response(JSON.stringify({ error: "Invalid JSON body" }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  try {
    // --- Input Validation (zod) ---
    const validationResult = updateSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error(`PUT /api/summaries/${summaryId}: Input validation failed:`, validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }

    const validatedData: UpdateSummaryRequestDTO = validationResult.data;

    // Ensure there's at least one field being updated
    if (Object.keys(validatedData).length === 0) {
      console.warn(`PUT /api/summaries/${summaryId}: Request body is empty, no fields to update.`);
      return new Response(JSON.stringify({ error: "Request body must contain fields to update." }), {
        status: 400,
        headers: { "Content-Type": "application/json" },
      });
    }

    // --- Call Service to update data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass updated data and summaryId to service. Service will use DEFAULT_USER_ID internally.
    const updatedSummaryRecord: MeetingSummaryFullRow = await summaryService.updateDefaultUserSummary(
      summaryId,
      validatedData
    );

    console.log(`PUT /api/summaries/${summaryId}: Successfully updated summary record for DEFAULT user.`);

    // Map DB row to frontend DTO (MeetingSummaryDetailsDto for consistency with GET details)
    const responseData: MeetingSummaryDetailsDto = {
      id: updatedSummaryRecord.id,
      title: updatedSummaryRecord.title, // Include title as it's in the DB row
      file_name: updatedSummaryRecord.file_name,
      created_at: updatedSummaryRecord.created_at,
      updated_at: updatedSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: updatedSummaryRecord.transcription,
      summary: updatedSummaryRecord.summary,
      llm_generated: updatedSummaryRecord.llm_generated,
      notes: updatedSummaryRecord.notes,
      // user_id is omitted from this DTO
    };

    return new Response(JSON.stringify(responseData), {
      status: 200, // 200 OK
      headers: { "Content-Type": "application/json" },
    });
  } catch (error) {
    console.error(`PUT /api/summaries/${summaryId}: Caught error after validation (DEFAULT_USER):`, error);
    if ((error as any).status === 404) {
      return new Response(
        JSON.stringify({
          message: (error as any).message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    if ((error as any).status === 403) {
      // This might happen if RLS is still partially active
      return new Response(
        JSON.stringify({
          message:
            (error as any).message ||
            `Permission denied for summary ID ${summaryId}. Ensure RLS allows access for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while updating summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

// --- Handler endpoint DELETE /api/summaries/{id} ---
// Implements the Delete Summary endpoint.
// Authentication check is SKIPPED. Deletes summary for DEFAULT_USER_ID.
export const DELETE: APIRoute = async ({ params, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("DELETE /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("DELETE /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `DELETE /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Deletes summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  try {
    // --- Call Service to delete data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass summaryId to service. Service will use DEFAULT_USER_ID internally.
    await summaryService.deleteDefaultUserSummary(summaryId);

    console.log(`DELETE /api/summaries/${summaryId}: Successfully deleted summary record for DEFAULT user.`);

    return new Response(null, {
      // 204 No Content
      status: 204,
      // No body for 204 response
    });
  } catch (error) {
    console.error(`DELETE /api/summaries/${summaryId}: Caught error (DEFAULT_USER):`, error);
    if ((error as any).status === 404) {
      return new Response(
        JSON.stringify({
          message: (error as any).message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    if ((error as any).status === 403) {
      // This might happen if RLS is still partially active
      return new Response(
        JSON.stringify({
          message:
            (error as any).message ||
            `Permission denied for summary ID ${summaryId}. Ensure RLS allows delete for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while deleting summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

export const prerender = false; // Needed for server routes



================================================
File: .history/src/pages/api/summaries_20250421134354.ts
================================================
/* eslint-disable no-console */
// src/pages/api/summaries.ts -- Handlers for /api/summaries (GET, POST, PUT, DELETE)

import type { APIRoute } from "astro";
import { z } from "zod"; // Import the Zod library

// Import your local SupabaseClient type alias AND the default user ID
// IMPORTANT: Using DEFAULT_USER_ID instead of auth.uid() for DB operations in this MVP!
import type { SupabaseClient } from "../../db/supabase.client";
import { DEFAULT_USER_ID } from "../../db/supabase.client"; // Import the default user ID

// Import Supabase specific types for better error handling and results
import type { PostgrestSingleResponse, PostgrestResponse } from "@supabase/supabase-js";

// Import shared DTOs and DB internal types from central types file
import type {
  MeetingSummaryListEntryDto,
  CreateSummaryRequestDTO,
  CreateSummaryResponseDTO,
  UpdateSummaryRequestDTO,
  MeetingSummaryInsertData,
  MeetingSummaryFullRow,
  MeetingSummarySelectedColumns,
  ListSummariesServiceParams,
} from "../../types"; // Adjust the path if necessary

// Import date-fns parseISO for robust date parsing and date helpers
import { parseISO, startOfDay, endOfDay } from "date-fns";

// --- Zod Schema for List Summaries Query Parameters (for GET /api/summaries) ---
const listSummariesParamsSchema = z.object({
  sort_by: z.enum(["created_at", "updated_at"]).optional().default("created_at"),
  sort_order: z.enum(["asc", "desc"]).optional().default("desc"),
  // Accept date strings (YYYY-MM-DD from input type="date") or full ISO 8601
  from_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'from_dt'.",
    }),
  to_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'to_dt'.",
    }),
});

// --- Zod Schema for Create Summary Request Body (for POST /api/summaries) ---
const createSummaryRequestSchema = z.object({
  file_name: z.string().nullable().optional(), // nullable() allows null, optional() allows undefined
  transcription: z.string().min(1, { message: "Transcription cannot be empty." }),
  summary: z
    .string()
    .min(1, { message: "Summary cannot be empty." })
    .max(500, { message: "Summary cannot exceed 500 characters." }),
  llm_generated: z.boolean({ required_error: "Field 'llm_generated' is required and must be a boolean." }),
  notes: z
    .string()
    .nullable()
    .optional()
    .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
});

// --- Zod Schema for Update Summary Request Body (for PUT /api/summaries/{id}) ---
// Allows partial updates
const updateSummaryRequestSchema = z
  .object({
    file_name: z.string().nullable().optional(),
    transcription: z.string().min(1, { message: "Transcription cannot be empty." }).optional(),
    summary: z
      .string()
      .min(1, { message: "Summary cannot be empty." })
      .max(500, { message: "Summary cannot exceed 500 characters." })
      .optional(),
    llm_generated: z.boolean().optional(),
    notes: z
      .string()
      .nullable()
      .optional()
      .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
  })
  .partial(); // Make all fields optional at the top level

// --- SummaryService Class (Central logic for DB interaction) ---
// IMPORTANT: In this MVP version, this service uses DEFAULT_USER_ID for DB operations
// instead of relying on auth.uid() via RLS. This is INSECURE and for MVP ONLY.
class SummaryService {
  constructor(private supabase: SupabaseClient) {}

  // Method to list summaries for the DEFAULT_USER_ID
  async listDefaultUserSummaries(params: ListSummariesServiceParams): Promise<MeetingSummaryListEntryDto[]> {
    // userId parameter is included for type compatibility but ignored in this MVP implementation
    // as we are hardcoding DEFAULT_USER_ID.
    const { dateRange, sortParams } = params;
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID (MVP ONLY).`
    );

    try {
      // Select specific columns for the list view
      let query = this.supabase.from("meeting_summaries").select("id, title, file_name, created_at, modified_at");

      // Explicitly filter by DEFAULT_USER_ID, overriding standard RLS based on auth.uid()
      query = query.eq("user_id", DEFAULT_USER_ID);

      if (dateRange.from) {
        // Use >= for 'from' date (start of the day)
        query = query.gte("created_at", startOfDay(dateRange.from).toISOString());
      }
      if (dateRange.to) {
        // Use <= for 'to' date (end of the day)
        query = query.lte("created_at", endOfDay(dateRange.to).toISOString());
      }

      // Map API sort_by terms to DB column names
      const dbSortBy = sortParams.by === "modified_at" ? "modified_at" : "created_at";

      // Apply sorting
      query = query.order(dbSortBy, { ascending: sortParams.order === "asc" });

      // Execute the query
      const result: PostgrestResponse<MeetingSummarySelectedColumns> = await query;
      const { data, error } = result;

      if (error) {
        console.error("Database error fetching summaries for DEFAULT user", DEFAULT_USER_ID, ":", error);
        // Even with DEFAULT_USER_ID, RLS might still be active on the table!
        // If RLS is active and configured to check auth.uid(), this query might fail with 42501
        // because auth.uid() will be null or different from DEFAULT_USER_ID.
        // For this MVP phase using DEFAULT_USER_ID, you might need RLS on meeting_summaries
        // temporarily disabled during local testing, or modified to allow SELECT if user_id = DEFAULT_USER_ID
        // or auth.uid() is null/different. This is a conflict in MVP rules.
        // Assuming for this MVP, RLS is permissive enough for DEFAULT_USER_ID queries *or* temporarily disabled.
        if ((error as any).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          // Re-throw as 500, hiding specific RLS error
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summaries from database.");
      }

      if (!data) {
        console.warn("GET /api/summaries (DEFAULT_USER): Select query returned no data and no error.");
        return []; // Return empty array if no data
      }

      // Map DB rows to frontend DTOs
      const summariesDto: MeetingSummaryListEntryDto[] = data.map((row) => ({
        id: row.id,
        title: row.title,
        file_name: row.file_name,
        created_at: row.created_at,
        updated_at: row.modified_at, // Map DB modified_at to API updated_at
      }));

      return summariesDto;
    } catch (error) {
      console.error("Error in SummaryService.listDefaultUserSummaries:", error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to get details of a single summary for the DEFAULT_USER_ID
  async getDefaultUserSummaryDetails(id: string): Promise<MeetingSummaryDetailsDto | null> {
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID for details (MVP ONLY).`
    );
    try {
      // Select all relevant columns (excluding user_id as per DTO)
      const query = this.supabase
        .from("meeting_summaries")
        .select("id, title, file_name, created_at, modified_at, transcription, summary, llm_generated, notes")
        .eq("id", id)
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Use single() for one expected row

      const { data, error } = await query;

      if (error && error.code === "PGRST116") {
        // Supabase specific error code for "no rows found"
        console.warn(`Summary not found for ID ${id} or not owned by DEFAULT user ${DEFAULT_USER_ID}.`);
        return null; // Return null for 404 case
      } else if (error) {
        console.error(
          `Database error fetching summary details for ID ${id} and DEFAULT user ${DEFAULT_USER_ID}:`,
          error
        );
        if ((error as any).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summary details from database.");
      }

      if (!data) {
        console.warn(`GET /api/summaries/${id} (DEFAULT_USER): Single query returned no data and no error.`);
        return null; // Should be caught by PGRST116 above, but safety check
      }

      // Map DB row to frontend DTO
      const summaryDto: MeetingSummaryDetailsDto = {
        id: data.id,
        title: data.title,
        file_name: data.file_name,
        created_at: data.created_at,
        updated_at: data.modified_at, // Map DB modified_at to API updated_at
        transcription: data.transcription,
        summary: data.summary,
        llm_generated: data.llm_generated,
        notes: data.notes,
      };

      return summaryDto;
    } catch (error) {
      console.error(`Error in SummaryService.getDefaultUserSummaryDetails for ID ${id}:`, error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to create a new summary for the DEFAULT_USER_ID
  async createDefaultUserSummary(data: CreateSummaryRequestDTO): Promise<MeetingSummaryFullRow> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for creation (MVP ONLY).`);
    // Prepare data for insertion, explicitly setting user_id to DEFAULT_USER_ID
    const dataToInsert: MeetingSummaryInsertData = {
      user_id: DEFAULT_USER_ID, // Assign to DEFAULT user
      file_name: data.file_name,
      transcription: data.transcription,
      summary: data.summary,
      llm_generated: data.llm_generated,
      notes: data.notes, // notes can be string or null from validation
      title:
        data.file_name && data.file_name.trim().length > 0
          ? data.file_name.trim()
          : data.transcription.trim().substring(0, 50) + (data.transcription.trim().length > 50 ? "..." : ""), // Generate title
    };

    console.log("Attempting to insert data into DB for DEFAULT user:", dataToInsert);
    try {
      // Execute the insert query
      // If RLS insert policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .insert([dataToInsert]) // Insert the prepared data
        .select() // Select the inserted row
        .single(); // Expect a single row

      if (result.error) {
        console.error("Database insertion failed for DEFAULT user:", result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Insert for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows insert for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to save summary to database.");
      }

      if (!result.data) {
        console.error("SummaryService.createDefaultUserSummary: Insert returned no error but no data.");
        throw new Error("Database insertion failed unexpectedly.");
      }

      console.log("Database insertion successful for DEFAULT user. New summary ID:", result.data.id);
      return result.data;
    } catch (error) {
      console.error("Error in SummaryService.createDefaultUserSummary:", error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to update an existing summary for the DEFAULT_USER_ID
  async updateDefaultUserSummary(id: string, data: UpdateSummaryRequestDTO): Promise<MeetingSummaryFullRow> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for update (MVP ONLY).`);
    console.log(`Attempting to update summary ${id} for DEFAULT user with data:`, data);
    try {
      // Execute the update query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS update policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .update(data) // Update with the provided data
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .select() // Select the updated row
        .single(); // Expect a single row

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows updated"
        console.warn(`Update attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        // Return null or throw specific error for handler to return 404
        const notFoundError = new Error(`Summary with ID ${id} not found or access denied.`);
        (notFoundError as any).status = 404; // Tag error for handler
        throw notFoundError;
      } else if (result.error) {
        console.error(`Database update failed for ID ${id} and DEFAULT user:`, result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Update for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows update for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to update summary in database.");
      }

      if (!result.data) {
        console.error(`SummaryService.updateDefaultUserSummary: Update returned no error but no data for ID ${id}.`);
        throw new Error("Database update failed unexpectedly.");
      }

      console.log(`Database update successful for ID ${id} and DEFAULT user.`);
      return result.data;
    } catch (error) {
      console.error(`Error in SummaryService.updateDefaultUserSummary for ID ${id}:`, error);
      throw error; // Re-throw to be caught by API handler
    }
  }

  // Method to delete an existing summary for the DEFAULT_USER_ID
  async deleteDefaultUserSummary(id: string): Promise<void> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for delete (MVP ONLY).`);
    console.log(`Attempting to delete summary ${id} for DEFAULT user ${DEFAULT_USER_ID}`);
    try {
      // Execute the delete query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS delete policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<null> = await this.supabase
        .from("meeting_summaries")
        .delete() // Perform deletion
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Expect a single row deleted or none

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows found"
        console.warn(`Delete attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        const notFoundError = new Error(`Summary with ID ${id} not found or access denied.`);
        (notFoundError as any).status = 404; // Tag error for handler
        throw notFoundError;
      } else if (result.error) {
        console.error(`Database delete failed for ID ${id} and DEFAULT user:`, result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Delete for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows delete for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to delete summary from database.");
      }

      // Success! result.data will be null for delete single().
      console.log(`Database delete successful for ID ${id} and DEFAULT user.`);
      return; // Return void on success
    } catch (error) {
      console.error(`Error in SummaryService.deleteDefaultUserSummary for ID ${id}:`, error);
      throw error; // Re-throw to be caught by API handler
    }
  }
}

// --- Handler endpoint GET /api/summaries ---
// Implements the List Summaries endpoint.
// Authentication check is SKIPPED. Data filtered by DEFAULT_USER_ID.
export const GET: APIRoute = async ({ url, locals }) => {
  const supabase = locals.supabase as SupabaseClient;

  // --- Get Supabase client from context.locals ---
  if (!supabase) {
    console.error("GET /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "GET /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data filtered by DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used

  // --- Use Zod for parameter validation (GET) ---
  const queryParams = Object.fromEntries(url.searchParams.entries());
  const validationResult = listSummariesParamsSchema.safeParse(queryParams);

  if (!validationResult.success) {
    console.error("GET /api/summaries: Query parameter validation failed:", validationResult.error);
    return new Response(
      JSON.stringify({
        message: "Invalid query parameters",
        errors: validationResult.error.format(),
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  const validatedParams = validationResult.data;

  // --- Determine Date Range ---
  let fromDate: Date | undefined;
  let toDate: Date | undefined;

  if (validatedParams.from_dt === undefined && validatedParams.to_dt === undefined) {
    // Default to last 7 days
    const now = new Date();
    toDate = endOfDay(now); // End of today
    fromDate = startOfDay(new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)); // Start of 7 days ago
    console.log(`DEBUG: Using default 7-day filter: from ${fromDate.toISOString()} to ${toDate.toISOString()}`);
  } else {
    if (validatedParams.from_dt !== undefined) {
      // Parse the date string provided
      fromDate = parseISO(validatedParams.from_dt);
      if (isNaN(fromDate.getTime())) fromDate = undefined; // Handle potential parse failure after refine
    }
    if (validatedParams.to_dt !== undefined) {
      // Parse the date string provided
      toDate = parseISO(validatedParams.to_dt);
      if (isNaN(toDate.getTime())) toDate = undefined; // Handle potential parse failure after refine
    }
    console.log(
      `DEBUG: Using provided date filters: from ${fromDate?.toISOString() || "none"} to ${toDate?.toISOString() || "none"}`
    );
  }

  // Map API sort_by terms to DB column names for the Service layer
  const dbSortBy: ListSummariesServiceParams["sortParams"]["by"] =
    validatedParams.sort_by === "modified_at" ? "modified_at" : "created_at";
  const sortOrder: ListSummariesServiceParams["sortParams"]["order"] = validatedParams.sort_order;

  try {
    const summaryService = new SummaryService(supabase);

    const serviceParams: ListSummariesServiceParams = {
      userId: DEFAULT_USER_ID, // Pass DEFAULT user ID to service
      dateRange: { from: fromDate, to: toDate },
      sortParams: { by: dbSortBy, order: sortOrder },
    };

    // Use the specific service method for the default user
    const summariesDto: MeetingSummaryListEntryDto[] = await summaryService.listDefaultUserSummaries(serviceParams);

    return new Response(JSON.stringify(summariesDto), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });
  } catch (error) {
    console.error("Caught error in GET /api/summaries handler (DEFAULT_USER):", error);
    if ((error as any).status === 404 || (error as any).status === 403) {
      return new Response(JSON.stringify({ message: (error as any).message || "Access Denied/Not Found" }), {
        status: (error as any).status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ message: "An internal server error occurred" }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint POST /api/summaries ---
// Implements the Create New Summary endpoint.
// Authentication check is SKIPPED. Data assigned to DEFAULT_USER_ID.
export const POST: APIRoute = async ({ request, locals }) => {
  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("POST /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "POST /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data assigned to DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;

  try {
    requestBody = await request.json();
  } catch (error) {
    console.error("POST /api/summaries: Failed to parse request body as JSON:", error);
    return new Response(
      JSON.stringify({
        error: "Invalid JSON body",
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  try {
    const validationResult = createSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error("POST /api/summaries: Input validation failed:", validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        {
          status: 400,
          headers: { "Content-Type": "application/json" },
        }
      );
    }

    const validatedData = validationResult.data;

    // --- Call Service to insert data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass validated data to service. Service will use DEFAULT_USER_ID internally.
    const newSummaryRecord: MeetingSummaryFullRow = await summaryService.createDefaultUserSummary(validatedData);

    console.log(
      "POST /api/summaries: Successfully created new summary record with ID:",
      newSummaryRecord.id,
      "for DEFAULT user."
    );

    // Map DB row to frontend DTO
    const responseData: CreateSummaryResponseDTO = {
      id: newSummaryRecord.id,
      user_id: newSummaryRecord.user_id,
      file_name: newSummaryRecord.file_name,
      created_at: newSummaryRecord.created_at,
      updated_at: newSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: newSummaryRecord.transcription,
      summary: newSummaryRecord.summary,
      llm_generated: newSummaryRecord.llm_generated,
      notes: newSummaryRecord.notes,
      title: newSummaryRecord.title,
    };

    return new Response(JSON.stringify(responseData), {
      status: 201, // 201 Created
      headers: {
        "Content-Type": "application/json",
        Location: `/api/summaries/${responseData.id}`, // HATEOAS principle
      },
    });
  } catch (error) {
    console.error("Caught error in POST /api/summaries handler (DEFAULT_USER):", error);
    if ((error as any).status === 404 || (error as any).status === 403) {
      return new Response(JSON.stringify({ message: (error as any).message || "Access Denied/Not Found" }), {
        status: (error as any).status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ error: "An internal server error occurred while saving the summary." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint PUT /api/summaries/{id} ---
// Implements the Update Existing Summary endpoint.
// Authentication check is SKIPPED. Updates summary for DEFAULT_USER_ID.
export const PUT: APIRoute = async ({ params, request, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("PUT /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("PUT /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `PUT /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Updates summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;
  try {
    // --- Parse Request Body ---
    requestBody = await request.json();
  } catch (error) {
    console.error(`PUT /api/summaries/${summaryId}: Failed to parse request body as JSON:`, error);
    return new Response(JSON.stringify({ error: "Invalid JSON body" }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  try {
    // --- Input Validation (zod) ---
    const validationResult = updateSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error(`PUT /api/summaries/${summaryId}: Input validation failed:`, validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }

    const validatedData: UpdateSummaryRequestDTO = validationResult.data;

    // Ensure there's at least one field being updated
    if (Object.keys(validatedData).length === 0) {
      console.warn(`PUT /api/summaries/${summaryId}: Request body is empty, no fields to update.`);
      return new Response(JSON.stringify({ error: "Request body must contain fields to update." }), {
        status: 400,
        headers: { "Content-Type": "application/json" },
      });
    }

    // --- Call Service to update data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass updated data and summaryId to service. Service will use DEFAULT_USER_ID internally.
    const updatedSummaryRecord: MeetingSummaryFullRow = await summaryService.updateDefaultUserSummary(
      summaryId,
      validatedData
    );

    console.log(`PUT /api/summaries/${summaryId}: Successfully updated summary record for DEFAULT user.`);

    // Map DB row to frontend DTO (MeetingSummaryDetailsDto for consistency with GET details)
    const responseData: MeetingSummaryDetailsDto = {
      id: updatedSummaryRecord.id,
      title: updatedSummaryRecord.title, // Include title as it's in the DB row
      file_name: updatedSummaryRecord.file_name,
      created_at: updatedSummaryRecord.created_at,
      updated_at: updatedSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: updatedSummaryRecord.transcription,
      summary: updatedSummaryRecord.summary,
      llm_generated: updatedSummaryRecord.llm_generated,
      notes: updatedSummaryRecord.notes,
      // user_id is omitted from this DTO
    };

    return new Response(JSON.stringify(responseData), {
      status: 200, // 200 OK
      headers: { "Content-Type": "application/json" },
    });
  } catch (error) {
    console.error(`PUT /api/summaries/${summaryId}: Caught error after validation (DEFAULT_USER):`, error);
    if ((error as any).status === 404) {
      return new Response(
        JSON.stringify({
          message: (error as any).message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    if ((error as any).status === 403) {
      // This might happen if RLS is still partially active
      return new Response(
        JSON.stringify({
          message:
            (error as any).message ||
            `Permission denied for summary ID ${summaryId}. Ensure RLS allows access for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while updating summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

// --- Handler endpoint DELETE /api/summaries/{id} ---
// Implements the Delete Summary endpoint.
// Authentication check is SKIPPED. Deletes summary for DEFAULT_USER_ID.
export const DELETE: APIRoute = async ({ params, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("DELETE /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("DELETE /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `DELETE /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Deletes summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  try {
    // --- Call Service to delete data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass summaryId to service. Service will use DEFAULT_USER_ID internally.
    await summaryService.deleteDefaultUserSummary(summaryId);

    console.log(`DELETE /api/summaries/${summaryId}: Successfully deleted summary record for DEFAULT user.`);

    return new Response(null, {
      // 204 No Content
      status: 204,
      // No body for 204 response
    });
  } catch (error) {
    console.error(`DELETE /api/summaries/${summaryId}: Caught error (DEFAULT_USER):`, error);
    if ((error as any).status === 404) {
      return new Response(
        JSON.stringify({
          message: (error as any).message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    if ((error as any).status === 403) {
      // This might happen if RLS is still partially active
      return new Response(
        JSON.stringify({
          message:
            (error as any).message ||
            `Permission denied for summary ID ${summaryId}. Ensure RLS allows delete for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while deleting summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

export const prerender = false; // Needed for server routes



================================================
File: .history/src/pages/api/summaries_20250421134842.ts
================================================
/* eslint-disable no-console */
// src/pages/api/summaries.ts -- Handlers for /api/summaries (GET, POST, PUT, DELETE)

import type { APIRoute, APIContext } from "astro";
import { z } from "zod"; // Import the Zod library

// Import your local SupabaseClient type alias AND the default user ID
// IMPORTANT: Using DEFAULT_USER_ID instead of auth.uid() for DB operations in this MVP!
import type { SupabaseClient } from "../../db/supabase.client";
import { DEFAULT_USER_ID } from "../../db/supabase.client"; // Import the default user ID

// Import Supabase specific types for better error handling and results
import type { PostgrestSingleResponse, PostgrestResponse } from "@supabase/supabase-js";

// Import shared DTOs and DB internal types from central types file
import type {
  MeetingSummaryListEntryDto,
  CreateSummaryRequestDTO,
  CreateSummaryResponseDTO,
  UpdateSummaryRequestDTO,
  MeetingSummaryInsertData,
  MeetingSummaryFullRow,
  MeetingSummarySelectedColumns,
  ListSummariesServiceParams,
  MeetingSummaryDetailsDto, // Ensure this is imported if used in service method return types or mapping
} from "../../types"; // Adjust the path if necessary

// Import date-fns parseISO for robust date parsing and date helpers
import { parseISO, startOfDay, endOfDay } from "date-fns";

// --- Zod Schema for List Summaries Query Parameters (for GET /api/summaries) ---
const listSummariesParamsSchema = z.object({
  sort_by: z.enum(["created_at", "updated_at"]).optional().default("created_at"),
  sort_order: z.enum(["asc", "desc"]).optional().default("desc"),
  // Accept date strings (YYYY-MM-DD from input type="date") or full ISO 8601
  from_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'from_dt'.",
    }),
  to_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'to_dt'.",
    }),
});

// --- Zod Schema for Create Summary Request Body (for POST /api/summaries) ---
const createSummaryRequestSchema = z.object({
  file_name: z.string().nullable().optional(), // nullable() allows null, optional() allows undefined
  transcription: z.string().min(1, { message: "Transcription cannot be empty." }),
  summary: z
    .string()
    .min(1, { message: "Summary cannot be empty." })
    .max(500, { message: "Summary cannot exceed 500 characters." }),
  llm_generated: z.boolean({ required_error: "Field 'llm_generated' is required and must be a boolean." }),
  notes: z
    .string()
    .nullable()
    .optional()
    .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
});

// --- Zod Schema for Update Summary Request Body (for PUT /api/summaries/{id}) ---
// Allows partial updates
const updateSummaryRequestSchema = z
  .object({
    file_name: z.string().nullable().optional(),
    transcription: z.string().min(1, { message: "Transcription cannot be empty." }).optional(),
    summary: z
      .string()
      .min(1, { message: "Summary cannot be empty." })
      .max(500, { message: "Summary cannot exceed 500 characters." })
      .optional(),
    llm_generated: z.boolean().optional(),
    notes: z
      .string()
      .nullable()
      .optional()
      .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
  })
  .partial(); // Make all fields optional at the top level

// --- SummaryService Class (Central logic for DB interaction) ---
// IMPORTANT: In this MVP version, this service uses DEFAULT_USER_ID for DB operations
// instead of relying on auth.uid() via RLS. This is INSECURE and for MVP ONLY.
class SummaryService {
  constructor(private supabase: SupabaseClient) {}

  // Method to list summaries for the DEFAULT_USER_ID
  async listDefaultUserSummaries(params: ListSummariesServiceParams): Promise<MeetingSummaryListEntryDto[]> {
    // userId parameter is included for type compatibility but ignored in this MVP implementation
    // as we are hardcoding DEFAULT_USER_ID.
    const { dateRange, sortParams } = params;
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID (MVP ONLY).`
    );

    try {
      // Select specific columns for the list view
      let query = this.supabase.from("meeting_summaries").select("id, title, file_name, created_at, modified_at");

      // Explicitly filter by DEFAULT_USER_ID, overriding standard RLS based on auth.uid()
      query = query.eq("user_id", DEFAULT_USER_ID);

      if (dateRange.from) {
        // Use >= for 'from' date (start of the day)
        query = query.gte("created_at", startOfDay(dateRange.from).toISOString());
      }
      if (dateRange.to) {
        // Use <= for 'to' date (end of the day)
        query = query.lte("created_at", endOfDay(dateRange.to).toISOString());
      }

      // Map API sort_by terms to DB column names
      // FIX: Correct the comparison from "updated_at" to "modified_at" as used in state/params type
      const dbSortBy = sortParams.by === "modified_at" ? "modified_at" : "created_at";

      // Apply sorting
      query = query.order(dbSortBy, { ascending: sortParams.order === "asc" });

      // Execute the query
      const result: PostgrestResponse<MeetingSummarySelectedColumns> = await query;
      const { data, error } = result;

      if (error) {
        console.error("Database error fetching summaries for DEFAULT user", DEFAULT_USER_ID, ":", error);
        // Even with DEFAULT_USER_ID, RLS might still be active on the table!
        // If RLS is active and configured to check auth.uid(), this query might fail with 42501
        // because auth.uid() will be null or different from DEFAULT_USER_ID.
        // For this MVP phase using DEFAULT_USER_ID, you might need RLS on meeting_summaries
        // temporarily disabled during local testing, or modified to allow SELECT if user_id = DEFAULT_USER_ID
        // or auth.uid() is null/different. This is a conflict in MVP rules.
        // Assuming for this MVP, RLS is permissive enough for DEFAULT_USER_ID queries *or* temporarily disabled.
        if ((error as any).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          // Re-throw as 500, hiding specific RLS error
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summaries from database.");
      }

      if (!data) {
        console.warn("GET /api/summaries (DEFAULT_USER): Select query returned no data and no error.");
        return []; // Return empty array if no data
      }

      // Map DB rows to frontend DTOs
      const summariesDto: MeetingSummaryListEntryDto[] = data.map((row) => ({
        id: row.id,
        title: row.title,
        file_name: row.file_name,
        created_at: row.created_at,
        updated_at: row.modified_at, // Map DB modified_at to API updated_at
      }));

      return summariesDto;
    } catch (error: any) {
      // Fix: Type error as any
      console.error("Error in SummaryService.listDefaultUserSummaries:", error);
      // Pass status code if available, otherwise default to 500
      const typedError = error as any; // Use typedError for potential custom properties
      throw new Error(typedError.message || "An internal server error occurred");
    }
  }

  // Method to get details of a single summary for the DEFAULT_USER_ID
  // FIX: Correct return type to MeetingSummaryFullRow as returned by DB query
  async getDefaultUserSummaryDetails(id: string): Promise<MeetingSummaryFullRow | null> {
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID for details (MVP ONLY).`
    );
    try {
      // Select ALL columns (including user_id needed for mapping to FullRow)
      // FIX: select("*") or list all columns for FullRow type
      const query = this.supabase
        .from("meeting_summaries")
        .select("*") // Select all columns to match MeetingSummaryFullRow
        .eq("id", id)
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Use single() for one expected row

      const { data, error } = await query;

      if (error && error.code === "PGRST116") {
        // Supabase specific error code for "no rows found"
        console.warn(`Summary not found for ID ${id} or not owned by DEFAULT user ${DEFAULT_USER_ID}.`);
        return null; // Return null for 404 case
      } else if (error) {
        console.error(
          `Database error fetching summary details for ID ${id} and DEFAULT user ${DEFAULT_USER_ID}:`,
          error
        );
        if ((error as any).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summary details from database.");
      }

      // Data will be of type MeetingSummaryFullRow | null
      return data; // Return the raw data
    } catch (error: any) {
      // Fix: Type error as any
      console.error(`Error in SummaryService.getDefaultUserDetails for ID ${id}:`, error);
      // Pass status code if available, otherwise default to 500
      const typedError = error as any;
      throw new Error(typedError.message || "An internal server error occurred"); // Re-throw to be caught by API handler
    }
  }

  // Method to create a new summary for the DEFAULT_USER_ID
  async createDefaultUserSummary(data: CreateSummaryRequestDTO): Promise<MeetingSummaryFullRow> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for creation (MVP ONLY).`);
    // Prepare data for insertion, explicitly setting user_id to DEFAULT_USER_ID
    const dataToInsert: MeetingSummaryInsertData = {
      user_id: DEFAULT_USER_ID, // Assign to DEFAULT user
      file_name: data.file_name,
      transcription: data.transcription,
      summary: data.summary,
      llm_generated: data.llm_generated,
      notes: data.notes, // notes can be string or null from validation
      title:
        data.file_name && data.file_name.trim().length > 0
          ? data.file_name.trim()
          : data.transcription.trim().substring(0, 50) + (data.transcription.trim().length > 50 ? "..." : ""), // Generate title
    };

    console.log("Attempting to insert data into DB for DEFAULT user:", dataToInsert);
    try {
      // Execute the insert query
      // If RLS insert policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .insert([dataToInsert]) // Insert the prepared data
        .select() // Select the inserted row
        .single(); // Expect a single row

      if (result.error) {
        console.error("Database insertion failed for DEFAULT user:", result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Insert for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows insert for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to save summary to database.");
      }

      if (!result.data) {
        console.error("SummaryService.createDefaultUserSummary: Insert returned no error but no data.");
        throw new Error("Database insertion failed unexpectedly.");
      }

      console.log("Database insertion successful for DEFAULT user. New summary ID:", result.data.id);
      return result.data;
    } catch (error: any) {
      // Fix: Type error as any
      console.error("Error in SummaryService.createDefaultUserSummary:", error);
      // Pass status code if available, otherwise default to 500
      const typedError = error as any;
      throw new Error(typedError.message || "An internal server error occurred");
    }
  }

  // Method to update an existing summary for the DEFAULT_USER_ID
  // FIX: Correct return type to MeetingSummaryFullRow as returned by DB query
  async updateDefaultUserSummary(id: string, data: UpdateSummaryRequestDTO): Promise<MeetingSummaryFullRow | null> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for update (MVP ONLY).`);
    console.log(`Attempting to update summary ${id} for DEFAULT user with data:`, data);
    try {
      // Execute the update query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS update policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .update(data) // Update with the provided data
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .select() // Select the updated row
        .single(); // Expect a single row

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows updated"
        console.warn(`Update attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        // Return null or throw specific error for handler to return 404
        const notFoundError = new Error(`Summary with ID ${id} not found or access denied.`);
        (notFoundError as any).status = 404; // Tag error for handler
        throw notFoundError; // Throw the error for the handler to catch and return 404
      } else if (result.error) {
        console.error(`Database update failed for ID ${id} and DEFAULT user:`, result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Update for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows update for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to update summary in database.");
      }

      // Data will be of type MeetingSummaryFullRow | null. If no error, data should exist due to single().
      if (!result.data) {
        console.error(`SummaryService.updateDefaultUserSummary: Update returned no error but no data for ID ${id}.`);
        // This state is unexpected if PGRST116 is caught, but safety check
        throw new Error("Database update failed unexpectedly.");
      }

      console.log(`Database update successful for ID ${id} and DEFAULT user.`);
      return result.data; // Return the updated data
    } catch (error: any) {
      // Fix: Type error as any
      console.error(`Error in SummaryService.updateDefaultUserSummary for ID ${id}:`, error);
      // Pass status code if available, otherwise default to 500
      const typedError = error as any;
      // Re-throw the error including custom status if set
      const throwError = new Error(typedError.message || "An internal server error occurred");
      (throwError as any).status = typedError.status; // Preserve status if available
      throw throwError; // Re-throw to be caught by API handler
    }
  }

  // Method to delete an existing summary for the DEFAULT_USER_ID
  async deleteDefaultUserSummary(id: string): Promise<void> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for delete (MVP ONLY).`);
    console.log(`Attempting to delete summary ${id} for DEFAULT user ${DEFAULT_USER_ID}`);
    try {
      // Execute the delete query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS delete policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<null> = await this.supabase
        .from("meeting_summaries")
        .delete() // Perform deletion
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Expect a single row deleted or none (returns null on success)

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows found" for delete
        console.warn(`Delete attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        const notFoundError = new Error(`Summary with ID ${id} not found or access denied.`);
        (notFoundError as any).status = 404; // Tag error for handler
        throw notFoundError; // Throw the error for the handler to catch and return 404
      } else if (result.error) {
        console.error(`Database delete failed for ID ${id} and DEFAULT user:`, result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Delete for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows delete for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to delete summary from database.");
      }

      // Success! result.data will be null for delete single().
      console.log(`Database delete successful for ID ${id} and DEFAULT user.`);
      return; // Return void on success
    } catch (error: any) {
      // Fix: Type error as any
      console.error(`Error in SummaryService.deleteDefaultUserSummary for ID ${id}:`, error);
      // Pass status code if available, otherwise default to 500
      const typedError = error as any;
      // Re-throw the error including custom status if set
      const throwError = new Error(typedError.message || "An internal server error occurred");
      (throwError as any).status = typedError.status; // Preserve status if available
      throw throwError; // Re-throw to be caught by API handler
    }
  }
}

// --- Handler endpoint GET /api/summaries ---
// Implements the List Summaries endpoint.
// Authentication check is SKIPPED. Data filtered by DEFAULT_USER_ID.
export const GET: APIRoute = async ({ url, locals }) => {
  const supabase = locals.supabase as SupabaseClient;

  // --- Get Supabase client from context.locals ---
  if (!supabase) {
    console.error("GET /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "GET /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data filtered by DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used

  // --- Use Zod for parameter validation (GET) ---
  const queryParams = Object.fromEntries(url.searchParams.entries());
  const validationResult = listSummariesParamsSchema.safeParse(queryParams);

  if (!validationResult.success) {
    console.error("GET /api/summaries: Query parameter validation failed:", validationResult.error);
    return new Response(
      JSON.stringify({
        message: "Invalid query parameters",
        errors: validationResult.error.format(),
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  const validatedParams = validationResult.data;

  // --- Determine Date Range ---
  let fromDate: Date | undefined;
  let toDate: Date | undefined;

  if (validatedParams.from_dt === undefined && validatedParams.to_dt === undefined) {
    // Default to last 7 days
    const now = new Date();
    toDate = endOfDay(now); // End of today
    fromDate = startOfDay(new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)); // Start of 7 days ago
    console.log(`DEBUG: Using default 7-day filter: from ${fromDate.toISOString()} to ${toDate.toISOString()}`);
  } else {
    if (validatedParams.from_dt !== undefined) {
      // Parse the date string provided
      fromDate = parseISO(validatedParams.from_dt);
      if (isNaN(fromDate.getTime())) fromDate = undefined; // Handle potential parse failure after refine
    }
    if (validatedParams.to_dt !== undefined) {
      // Parse the date string provided
      toDate = parseISO(validatedParams.to_dt);
      if (isNaN(toDate.getTime())) toDate = undefined; // Handle potential parse failure after refine
    }
    console.log(
      `DEBUG: Using provided date filters: from ${fromDate?.toISOString() || "none"} to ${toDate?.toISOString() || "none"}`
    );
  }

  // Map API sort_by terms to DB column names for the Service layer
  const dbSortBy: ListSummariesServiceParams["sortParams"]["by"] =
    validatedParams.sort_by === "updated_at" ? "modified_at" : "created_at";
  const sortOrder: ListSummariesServiceParams["sortParams"]["order"] = validatedParams.sort_order;

  try {
    const summaryService = new SummaryService(supabase);

    const serviceParams: ListSummariesServiceParams = {
      userId: DEFAULT_USER_ID, // Pass DEFAULT user ID to service
      dateRange: { from: fromDate, to: toDate },
      sortParams: { by: dbSortBy, order: sortOrder },
    };

    // Use the specific service method for the default user
    const summariesDto: MeetingSummaryListEntryDto[] = await summaryService.listDefaultUserSummaries(serviceParams);

    return new Response(JSON.stringify(summariesDto), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });
  } catch (error: any) {
    // Fix: Type error as any
    console.error("Caught error in GET /api/summaries handler (DEFAULT_USER):", error);
    if ((error as any).status === 404 || (error as any).status === 403) {
      return new Response(JSON.stringify({ message: (error as any).message || "Access Denied/Not Found" }), {
        status: (error as any).status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ message: "An internal server error occurred" }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint POST /api/summaries ---
// Implements the Create New Summary endpoint.
// Authentication check is SKIPPED. Data assigned to DEFAULT_USER_ID.
export const POST: APIRoute = async ({ request, locals }) => {
  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("POST /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "POST /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data assigned to DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;

  try {
    requestBody = await request.json();
  } catch (error) {
    console.error("POST /api/summaries: Failed to parse request body as JSON:", error);
    return new Response(
      JSON.stringify({
        error: "Invalid JSON body",
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  try {
    const validationResult = createSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error("POST /api/summaries: Input validation failed:", validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        {
          status: 400,
          headers: { "Content-Type": "application/json" },
        }
      );
    }

    const validatedData = validationResult.data;

    // --- Call Service to insert data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass validated data to service. Service will use DEFAULT_USER_ID internally.
    const newSummaryRecord: MeetingSummaryFullRow = await summaryService.createDefaultUserSummary(validatedData);

    console.log(
      "POST /api/summaries: Successfully created new summary record with ID:",
      newSummaryRecord.id,
      "for DEFAULT user."
    );

    // Map DB row to frontend DTO
    const responseData: CreateSummaryResponseDTO = {
      id: newSummaryRecord.id,
      user_id: newSummaryRecord.user_id,
      file_name: newSummaryRecord.file_name,
      created_at: newSummaryRecord.created_at,
      updated_at: newSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: newSummaryRecord.transcription,
      summary: newSummaryRecord.summary,
      llm_generated: newSummaryRecord.llm_generated,
      notes: newSummaryRecord.notes,
      title: newSummaryRecord.title,
    };

    return new Response(JSON.stringify(responseData), {
      status: 201, // 201 Created
      headers: {
        "Content-Type": "application/json",
        Location: `/api/summaries/${responseData.id}`, // HATEOAS principle
      },
    });
  } catch (error: any) {
    // Fix: Type error as any
    console.error("Caught error in POST /api/summaries handler (DEFAULT_USER):", error);
    if ((error as any).status === 404 || (error as any).status === 403) {
      return new Response(JSON.stringify({ message: (error as any).message || "Access Denied/Not Found" }), {
        status: (error as any).status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ error: "An internal server error occurred while saving the summary." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint PUT /api/summaries/{id} ---
// Implements the Update Existing Summary endpoint.
// Authentication check is SKIPPED. Updates summary for DEFAULT_USER_ID.
export const PUT: APIRoute = async ({ params, request, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("PUT /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("PUT /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `PUT /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Updates summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;
  try {
    // --- Parse Request Body ---
    requestBody = await request.json();
  } catch (error) {
    console.error(`PUT /api/summaries/${summaryId}: Failed to parse request body as JSON:`, error);
    return new Response(JSON.stringify({ error: "Invalid JSON body" }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  try {
    // --- Input Validation (zod) ---
    const validationResult = updateSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error(`PUT /api/summaries/${summaryId}: Input validation failed:`, validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }

    const validatedData: UpdateSummaryRequestDTO = validationResult.data;

    // Ensure there's at least one field being updated
    if (Object.keys(validatedData).length === 0) {
      console.warn(`PUT /api/summaries/${summaryId}: Request body is empty, no fields to update.`);
      return new Response(JSON.stringify({ error: "Request body must contain fields to update." }), {
        status: 400,
        headers: { "Content-Type": "application/json" },
      });
    }

    // --- Call Service to update data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass updated data and summaryId to service. Service will use DEFAULT_USER_ID internally.
    // FIX: Expect MeetingSummaryFullRow or null return type from service
    const updatedSummaryRecord: MeetingSummaryFullRow | null = await summaryService.updateDefaultUserSummary(
      summaryId,
      validatedData
    );

    // FIX: Handle null return (404 Not Found)
    if (!updatedSummaryRecord) {
      console.warn(`PUT /api/summaries/${summaryId}: Service returned null, likely 404 Not Found.`);
      return new Response(JSON.stringify({ message: `Summary with ID ${summaryId} not found or access denied.` }), {
        status: 404,
        headers: { "Content-Type": "application/json" },
      });
    }

    console.log(`PUT /api/summaries/${summaryId}: Successfully updated summary record for DEFAULT user.`);

    // Map DB row to frontend DTO (MeetingSummaryDetailsDto for consistency with GET details)
    const responseData: MeetingSummaryDetailsDto = {
      id: updatedSummaryRecord.id,
      title: updatedSummaryRecord.title, // Include title as it's in the DB row
      file_name: updatedSummaryRecord.file_name,
      created_at: updatedSummaryRecord.created_at,
      updated_at: updatedSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: updatedSummaryRecord.transcription,
      summary: updatedSummaryRecord.summary,
      llm_generated: updatedSummaryRecord.llm_generated,
      notes: updatedSummaryRecord.notes,
      // user_id is omitted from this DTO
    };

    return new Response(JSON.stringify(responseData), {
      status: 200, // 200 OK
      headers: { "Content-Type": "application/json" },
    });
  } catch (error: any) {
    // Fix: Type error as any
    console.error(`PUT /api/summaries/${summaryId}: Caught error after validation (DEFAULT_USER):`, error);
    // Check if it's a known error type from service
    if ((error as any).status === 404) {
      // Service indicates Not Found/Not Owned - redundant if null check above works
      return new Response(
        JSON.stringify({
          message: (error as any).message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    if ((error as any).code === "42501" || (error as any).status === 403) {
      // Service indicates Permission Denied
      return new Response(
        JSON.stringify({
          message:
            (error as any).message ||
            `Permission denied for summary ID ${summaryId}. Ensure RLS allows access for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while updating summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

// --- Handler endpoint DELETE /api/summaries/{id} ---
// Implements the Delete Summary endpoint.
// Authentication check is SKIPPED. Deletes summary for DEFAULT_USER_ID.
export const DELETE: APIRoute = async ({ params, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("DELETE /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("DELETE /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `DELETE /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Deletes summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  try {
    // --- Call Service to delete data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass summaryId to service. Service will use DEFAULT_USER_ID internally.
    await summaryService.deleteDefaultUserSummary(summaryId);

    console.log(`DELETE /api/summaries/${summaryId}: Successfully deleted summary record for DEFAULT user.`);

    return new Response(null, {
      // 204 No Content
      status: 204,
      // No body for 204 response
    });
  } catch (error: any) {
    // Fix: Type error as any
    console.error(`DELETE /api/summaries/${summaryId}: Caught error (DEFAULT_USER):`, error);
    if ((error as any).status === 404) {
      return new Response(
        JSON.stringify({
          message: (error as any).message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    if ((error as any).code === "42501" || (error as any).status === 403) {
      // This might happen if RLS is still partially active
      return new Response(
        JSON.stringify({
          message:
            (error as any).message ||
            `Permission denied for summary ID ${summaryId}. Ensure RLS allows delete for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while deleting summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

export const prerender = false; // Needed for server routes



================================================
File: .history/src/pages/api/summaries_20250421134846.ts
================================================
/* eslint-disable no-console */
// src/pages/api/summaries.ts -- Handlers for /api/summaries (GET, POST, PUT, DELETE)

import type { APIRoute, APIContext } from "astro";
import { z } from "zod"; // Import the Zod library

// Import your local SupabaseClient type alias AND the default user ID
// IMPORTANT: Using DEFAULT_USER_ID instead of auth.uid() for DB operations in this MVP!
import type { SupabaseClient } from "../../db/supabase.client";
import { DEFAULT_USER_ID } from "../../db/supabase.client"; // Import the default user ID

// Import Supabase specific types for better error handling and results
import type { PostgrestSingleResponse, PostgrestResponse } from "@supabase/supabase-js";

// Import shared DTOs and DB internal types from central types file
import type {
  MeetingSummaryListEntryDto,
  CreateSummaryRequestDTO,
  CreateSummaryResponseDTO,
  UpdateSummaryRequestDTO,
  MeetingSummaryInsertData,
  MeetingSummaryFullRow,
  MeetingSummarySelectedColumns,
  ListSummariesServiceParams,
  MeetingSummaryDetailsDto, // Ensure this is imported if used in service method return types or mapping
} from "../../types"; // Adjust the path if necessary

// Import date-fns parseISO for robust date parsing and date helpers
import { parseISO, startOfDay, endOfDay } from "date-fns";

// --- Zod Schema for List Summaries Query Parameters (for GET /api/summaries) ---
const listSummariesParamsSchema = z.object({
  sort_by: z.enum(["created_at", "updated_at"]).optional().default("created_at"),
  sort_order: z.enum(["asc", "desc"]).optional().default("desc"),
  // Accept date strings (YYYY-MM-DD from input type="date") or full ISO 8601
  from_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'from_dt'.",
    }),
  to_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'to_dt'.",
    }),
});

// --- Zod Schema for Create Summary Request Body (for POST /api/summaries) ---
const createSummaryRequestSchema = z.object({
  file_name: z.string().nullable().optional(), // nullable() allows null, optional() allows undefined
  transcription: z.string().min(1, { message: "Transcription cannot be empty." }),
  summary: z
    .string()
    .min(1, { message: "Summary cannot be empty." })
    .max(500, { message: "Summary cannot exceed 500 characters." }),
  llm_generated: z.boolean({ required_error: "Field 'llm_generated' is required and must be a boolean." }),
  notes: z
    .string()
    .nullable()
    .optional()
    .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
});

// --- Zod Schema for Update Summary Request Body (for PUT /api/summaries/{id}) ---
// Allows partial updates
const updateSummaryRequestSchema = z
  .object({
    file_name: z.string().nullable().optional(),
    transcription: z.string().min(1, { message: "Transcription cannot be empty." }).optional(),
    summary: z
      .string()
      .min(1, { message: "Summary cannot be empty." })
      .max(500, { message: "Summary cannot exceed 500 characters." })
      .optional(),
    llm_generated: z.boolean().optional(),
    notes: z
      .string()
      .nullable()
      .optional()
      .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
  })
  .partial(); // Make all fields optional at the top level

// --- SummaryService Class (Central logic for DB interaction) ---
// IMPORTANT: In this MVP version, this service uses DEFAULT_USER_ID for DB operations
// instead of relying on auth.uid() via RLS. This is INSECURE and for MVP ONLY.
class SummaryService {
  constructor(private supabase: SupabaseClient) {}

  // Method to list summaries for the DEFAULT_USER_ID
  async listDefaultUserSummaries(params: ListSummariesServiceParams): Promise<MeetingSummaryListEntryDto[]> {
    // userId parameter is included for type compatibility but ignored in this MVP implementation
    // as we are hardcoding DEFAULT_USER_ID.
    const { dateRange, sortParams } = params;
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID (MVP ONLY).`
    );

    try {
      // Select specific columns for the list view
      let query = this.supabase.from("meeting_summaries").select("id, title, file_name, created_at, modified_at");

      // Explicitly filter by DEFAULT_USER_ID, overriding standard RLS based on auth.uid()
      query = query.eq("user_id", DEFAULT_USER_ID);

      if (dateRange.from) {
        // Use >= for 'from' date (start of the day)
        query = query.gte("created_at", startOfDay(dateRange.from).toISOString());
      }
      if (dateRange.to) {
        // Use <= for 'to' date (end of the day)
        query = query.lte("created_at", endOfDay(dateRange.to).toISOString());
      }

      // Map API sort_by terms to DB column names
      // FIX: Correct the comparison from "updated_at" to "modified_at" as used in state/params type
      const dbSortBy = sortParams.by === "modified_at" ? "modified_at" : "created_at";

      // Apply sorting
      query = query.order(dbSortBy, { ascending: sortParams.order === "asc" });

      // Execute the query
      const result: PostgrestResponse<MeetingSummarySelectedColumns> = await query;
      const { data, error } = result;

      if (error) {
        console.error("Database error fetching summaries for DEFAULT user", DEFAULT_USER_ID, ":", error);
        // Even with DEFAULT_USER_ID, RLS might still be active on the table!
        // If RLS is active and configured to check auth.uid(), this query might fail with 42501
        // because auth.uid() will be null or different from DEFAULT_USER_ID.
        // For this MVP phase using DEFAULT_USER_ID, you might need RLS on meeting_summaries
        // temporarily disabled during local testing, or modified to allow SELECT if user_id = DEFAULT_USER_ID
        // or auth.uid() is null/different. This is a conflict in MVP rules.
        // Assuming for this MVP, RLS is permissive enough for DEFAULT_USER_ID queries *or* temporarily disabled.
        if ((error as any).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          // Re-throw as 500, hiding specific RLS error
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summaries from database.");
      }

      if (!data) {
        console.warn("GET /api/summaries (DEFAULT_USER): Select query returned no data and no error.");
        return []; // Return empty array if no data
      }

      // Map DB rows to frontend DTOs
      const summariesDto: MeetingSummaryListEntryDto[] = data.map((row) => ({
        id: row.id,
        title: row.title,
        file_name: row.file_name,
        created_at: row.created_at,
        updated_at: row.modified_at, // Map DB modified_at to API updated_at
      }));

      return summariesDto;
    } catch (error: any) {
      // Fix: Type error as any
      console.error("Error in SummaryService.listDefaultUserSummaries:", error);
      // Pass status code if available, otherwise default to 500
      const typedError = error as any; // Use typedError for potential custom properties
      throw new Error(typedError.message || "An internal server error occurred");
    }
  }

  // Method to get details of a single summary for the DEFAULT_USER_ID
  // FIX: Correct return type to MeetingSummaryFullRow as returned by DB query
  async getDefaultUserSummaryDetails(id: string): Promise<MeetingSummaryFullRow | null> {
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID for details (MVP ONLY).`
    );
    try {
      // Select ALL columns (including user_id needed for mapping to FullRow)
      // FIX: select("*") or list all columns for FullRow type
      const query = this.supabase
        .from("meeting_summaries")
        .select("*") // Select all columns to match MeetingSummaryFullRow
        .eq("id", id)
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Use single() for one expected row

      const { data, error } = await query;

      if (error && error.code === "PGRST116") {
        // Supabase specific error code for "no rows found"
        console.warn(`Summary not found for ID ${id} or not owned by DEFAULT user ${DEFAULT_USER_ID}.`);
        return null; // Return null for 404 case
      } else if (error) {
        console.error(
          `Database error fetching summary details for ID ${id} and DEFAULT user ${DEFAULT_USER_ID}:`,
          error
        );
        if ((error as any).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summary details from database.");
      }

      // Data will be of type MeetingSummaryFullRow | null
      return data; // Return the raw data
    } catch (error: any) {
      // Fix: Type error as any
      console.error(`Error in SummaryService.getDefaultUserDetails for ID ${id}:`, error);
      // Pass status code if available, otherwise default to 500
      const typedError = error as any;
      throw new Error(typedError.message || "An internal server error occurred"); // Re-throw to be caught by API handler
    }
  }

  // Method to create a new summary for the DEFAULT_USER_ID
  async createDefaultUserSummary(data: CreateSummaryRequestDTO): Promise<MeetingSummaryFullRow> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for creation (MVP ONLY).`);
    // Prepare data for insertion, explicitly setting user_id to DEFAULT_USER_ID
    const dataToInsert: MeetingSummaryInsertData = {
      user_id: DEFAULT_USER_ID, // Assign to DEFAULT user
      file_name: data.file_name,
      transcription: data.transcription,
      summary: data.summary,
      llm_generated: data.llm_generated,
      notes: data.notes, // notes can be string or null from validation
      title:
        data.file_name && data.file_name.trim().length > 0
          ? data.file_name.trim()
          : data.transcription.trim().substring(0, 50) + (data.transcription.trim().length > 50 ? "..." : ""), // Generate title
    };

    console.log("Attempting to insert data into DB for DEFAULT user:", dataToInsert);
    try {
      // Execute the insert query
      // If RLS insert policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .insert([dataToInsert]) // Insert the prepared data
        .select() // Select the inserted row
        .single(); // Expect a single row

      if (result.error) {
        console.error("Database insertion failed for DEFAULT user:", result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Insert for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows insert for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to save summary to database.");
      }

      if (!result.data) {
        console.error("SummaryService.createDefaultUserSummary: Insert returned no error but no data.");
        throw new Error("Database insertion failed unexpectedly.");
      }

      console.log("Database insertion successful for DEFAULT user. New summary ID:", result.data.id);
      return result.data;
    } catch (error: any) {
      // Fix: Type error as any
      console.error("Error in SummaryService.createDefaultUserSummary:", error);
      // Pass status code if available, otherwise default to 500
      const typedError = error as any;
      throw new Error(typedError.message || "An internal server error occurred");
    }
  }

  // Method to update an existing summary for the DEFAULT_USER_ID
  // FIX: Correct return type to MeetingSummaryFullRow as returned by DB query
  async updateDefaultUserSummary(id: string, data: UpdateSummaryRequestDTO): Promise<MeetingSummaryFullRow | null> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for update (MVP ONLY).`);
    console.log(`Attempting to update summary ${id} for DEFAULT user with data:`, data);
    try {
      // Execute the update query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS update policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .update(data) // Update with the provided data
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .select() // Select the updated row
        .single(); // Expect a single row

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows updated"
        console.warn(`Update attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        // Return null or throw specific error for handler to return 404
        const notFoundError = new Error(`Summary with ID ${id} not found or access denied.`);
        (notFoundError as any).status = 404; // Tag error for handler
        throw notFoundError; // Throw the error for the handler to catch and return 404
      } else if (result.error) {
        console.error(`Database update failed for ID ${id} and DEFAULT user:`, result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Update for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows update for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to update summary in database.");
      }

      // Data will be of type MeetingSummaryFullRow | null. If no error, data should exist due to single().
      if (!result.data) {
        console.error(`SummaryService.updateDefaultUserSummary: Update returned no error but no data for ID ${id}.`);
        // This state is unexpected if PGRST116 is caught, but safety check
        throw new Error("Database update failed unexpectedly.");
      }

      console.log(`Database update successful for ID ${id} and DEFAULT user.`);
      return result.data; // Return the updated data
    } catch (error: any) {
      // Fix: Type error as any
      console.error(`Error in SummaryService.updateDefaultUserSummary for ID ${id}:`, error);
      // Pass status code if available, otherwise default to 500
      const typedError = error as any;
      // Re-throw the error including custom status if set
      const throwError = new Error(typedError.message || "An internal server error occurred");
      (throwError as any).status = typedError.status; // Preserve status if available
      throw throwError; // Re-throw to be caught by API handler
    }
  }

  // Method to delete an existing summary for the DEFAULT_USER_ID
  async deleteDefaultUserSummary(id: string): Promise<void> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for delete (MVP ONLY).`);
    console.log(`Attempting to delete summary ${id} for DEFAULT user ${DEFAULT_USER_ID}`);
    try {
      // Execute the delete query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS delete policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<null> = await this.supabase
        .from("meeting_summaries")
        .delete() // Perform deletion
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Expect a single row deleted or none (returns null on success)

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows found" for delete
        console.warn(`Delete attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        const notFoundError = new Error(`Summary with ID ${id} not found or access denied.`);
        (notFoundError as any).status = 404; // Tag error for handler
        throw notFoundError; // Throw the error for the handler to catch and return 404
      } else if (result.error) {
        console.error(`Database delete failed for ID ${id} and DEFAULT user:`, result.error);
        if ((result.error as any).code === "42501") {
          console.error("Potential RLS conflict: Delete for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows delete for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to delete summary from database.");
      }

      // Success! result.data will be null for delete single().
      console.log(`Database delete successful for ID ${id} and DEFAULT user.`);
      return; // Return void on success
    } catch (error: any) {
      // Fix: Type error as any
      console.error(`Error in SummaryService.deleteDefaultUserSummary for ID ${id}:`, error);
      // Pass status code if available, otherwise default to 500
      const typedError = error as any;
      // Re-throw the error including custom status if set
      const throwError = new Error(typedError.message || "An internal server error occurred");
      (throwError as any).status = typedError.status; // Preserve status if available
      throw throwError; // Re-throw to be caught by API handler
    }
  }
}

// --- Handler endpoint GET /api/summaries ---
// Implements the List Summaries endpoint.
// Authentication check is SKIPPED. Data filtered by DEFAULT_USER_ID.
export const GET: APIRoute = async ({ url, locals }) => {
  const supabase = locals.supabase as SupabaseClient;

  // --- Get Supabase client from context.locals ---
  if (!supabase) {
    console.error("GET /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "GET /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data filtered by DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used

  // --- Use Zod for parameter validation (GET) ---
  const queryParams = Object.fromEntries(url.searchParams.entries());
  const validationResult = listSummariesParamsSchema.safeParse(queryParams);

  if (!validationResult.success) {
    console.error("GET /api/summaries: Query parameter validation failed:", validationResult.error);
    return new Response(
      JSON.stringify({
        message: "Invalid query parameters",
        errors: validationResult.error.format(),
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  const validatedParams = validationResult.data;

  // --- Determine Date Range ---
  let fromDate: Date | undefined;
  let toDate: Date | undefined;

  if (validatedParams.from_dt === undefined && validatedParams.to_dt === undefined) {
    // Default to last 7 days
    const now = new Date();
    toDate = endOfDay(now); // End of today
    fromDate = startOfDay(new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)); // Start of 7 days ago
    console.log(`DEBUG: Using default 7-day filter: from ${fromDate.toISOString()} to ${toDate.toISOString()}`);
  } else {
    if (validatedParams.from_dt !== undefined) {
      // Parse the date string provided
      fromDate = parseISO(validatedParams.from_dt);
      if (isNaN(fromDate.getTime())) fromDate = undefined; // Handle potential parse failure after refine
    }
    if (validatedParams.to_dt !== undefined) {
      // Parse the date string provided
      toDate = parseISO(validatedParams.to_dt);
      if (isNaN(toDate.getTime())) toDate = undefined; // Handle potential parse failure after refine
    }
    console.log(
      `DEBUG: Using provided date filters: from ${fromDate?.toISOString() || "none"} to ${toDate?.toISOString() || "none"}`
    );
  }

  // Map API sort_by terms to DB column names for the Service layer
  const dbSortBy: ListSummariesServiceParams["sortParams"]["by"] =
    validatedParams.sort_by === "updated_at" ? "modified_at" : "created_at";
  const sortOrder: ListSummariesServiceParams["sortParams"]["order"] = validatedParams.sort_order;

  try {
    const summaryService = new SummaryService(supabase);

    const serviceParams: ListSummariesServiceParams = {
      userId: DEFAULT_USER_ID, // Pass DEFAULT user ID to service
      dateRange: { from: fromDate, to: toDate },
      sortParams: { by: dbSortBy, order: sortOrder },
    };

    // Use the specific service method for the default user
    const summariesDto: MeetingSummaryListEntryDto[] = await summaryService.listDefaultUserSummaries(serviceParams);

    return new Response(JSON.stringify(summariesDto), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });
  } catch (error: any) {
    // Fix: Type error as any
    console.error("Caught error in GET /api/summaries handler (DEFAULT_USER):", error);
    if ((error as any).status === 404 || (error as any).status === 403) {
      return new Response(JSON.stringify({ message: (error as any).message || "Access Denied/Not Found" }), {
        status: (error as any).status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ message: "An internal server error occurred" }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint POST /api/summaries ---
// Implements the Create New Summary endpoint.
// Authentication check is SKIPPED. Data assigned to DEFAULT_USER_ID.
export const POST: APIRoute = async ({ request, locals }) => {
  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("POST /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "POST /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data assigned to DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;

  try {
    requestBody = await request.json();
  } catch (error) {
    console.error("POST /api/summaries: Failed to parse request body as JSON:", error);
    return new Response(
      JSON.stringify({
        error: "Invalid JSON body",
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  try {
    const validationResult = createSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error("POST /api/summaries: Input validation failed:", validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        {
          status: 400,
          headers: { "Content-Type": "application/json" },
        }
      );
    }

    const validatedData = validationResult.data;

    // --- Call Service to insert data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass validated data to service. Service will use DEFAULT_USER_ID internally.
    const newSummaryRecord: MeetingSummaryFullRow = await summaryService.createDefaultUserSummary(validatedData);

    console.log(
      "POST /api/summaries: Successfully created new summary record with ID:",
      newSummaryRecord.id,
      "for DEFAULT user."
    );

    // Map DB row to frontend DTO
    const responseData: CreateSummaryResponseDTO = {
      id: newSummaryRecord.id,
      user_id: newSummaryRecord.user_id,
      file_name: newSummaryRecord.file_name,
      created_at: newSummaryRecord.created_at,
      updated_at: newSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: newSummaryRecord.transcription,
      summary: newSummaryRecord.summary,
      llm_generated: newSummaryRecord.llm_generated,
      notes: newSummaryRecord.notes,
      title: newSummaryRecord.title,
    };

    return new Response(JSON.stringify(responseData), {
      status: 201, // 201 Created
      headers: {
        "Content-Type": "application/json",
        Location: `/api/summaries/${responseData.id}`, // HATEOAS principle
      },
    });
  } catch (error: any) {
    // Fix: Type error as any
    console.error("Caught error in POST /api/summaries handler (DEFAULT_USER):", error);
    if ((error as any).status === 404 || (error as any).status === 403) {
      return new Response(JSON.stringify({ message: (error as any).message || "Access Denied/Not Found" }), {
        status: (error as any).status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ error: "An internal server error occurred while saving the summary." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint PUT /api/summaries/{id} ---
// Implements the Update Existing Summary endpoint.
// Authentication check is SKIPPED. Updates summary for DEFAULT_USER_ID.
export const PUT: APIRoute = async ({ params, request, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("PUT /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("PUT /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `PUT /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Updates summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;
  try {
    // --- Parse Request Body ---
    requestBody = await request.json();
  } catch (error) {
    console.error(`PUT /api/summaries/${summaryId}: Failed to parse request body as JSON:`, error);
    return new Response(JSON.stringify({ error: "Invalid JSON body" }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  try {
    // --- Input Validation (zod) ---
    const validationResult = updateSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error(`PUT /api/summaries/${summaryId}: Input validation failed:`, validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }

    const validatedData: UpdateSummaryRequestDTO = validationResult.data;

    // Ensure there's at least one field being updated
    if (Object.keys(validatedData).length === 0) {
      console.warn(`PUT /api/summaries/${summaryId}: Request body is empty, no fields to update.`);
      return new Response(JSON.stringify({ error: "Request body must contain fields to update." }), {
        status: 400,
        headers: { "Content-Type": "application/json" },
      });
    }

    // --- Call Service to update data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass updated data and summaryId to service. Service will use DEFAULT_USER_ID internally.
    // FIX: Expect MeetingSummaryFullRow or null return type from service
    const updatedSummaryRecord: MeetingSummaryFullRow | null = await summaryService.updateDefaultUserSummary(
      summaryId,
      validatedData
    );

    // FIX: Handle null return (404 Not Found)
    if (!updatedSummaryRecord) {
      console.warn(`PUT /api/summaries/${summaryId}: Service returned null, likely 404 Not Found.`);
      return new Response(JSON.stringify({ message: `Summary with ID ${summaryId} not found or access denied.` }), {
        status: 404,
        headers: { "Content-Type": "application/json" },
      });
    }

    console.log(`PUT /api/summaries/${summaryId}: Successfully updated summary record for DEFAULT user.`);

    // Map DB row to frontend DTO (MeetingSummaryDetailsDto for consistency with GET details)
    const responseData: MeetingSummaryDetailsDto = {
      id: updatedSummaryRecord.id,
      title: updatedSummaryRecord.title, // Include title as it's in the DB row
      file_name: updatedSummaryRecord.file_name,
      created_at: updatedSummaryRecord.created_at,
      updated_at: updatedSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: updatedSummaryRecord.transcription,
      summary: updatedSummaryRecord.summary,
      llm_generated: updatedSummaryRecord.llm_generated,
      notes: updatedSummaryRecord.notes,
      // user_id is omitted from this DTO
    };

    return new Response(JSON.stringify(responseData), {
      status: 200, // 200 OK
      headers: { "Content-Type": "application/json" },
    });
  } catch (error: any) {
    // Fix: Type error as any
    console.error(`PUT /api/summaries/${summaryId}: Caught error after validation (DEFAULT_USER):`, error);
    // Check if it's a known error type from service
    if ((error as any).status === 404) {
      // Service indicates Not Found/Not Owned - redundant if null check above works
      return new Response(
        JSON.stringify({
          message: (error as any).message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    if ((error as any).code === "42501" || (error as any).status === 403) {
      // Service indicates Permission Denied
      return new Response(
        JSON.stringify({
          message:
            (error as any).message ||
            `Permission denied for summary ID ${summaryId}. Ensure RLS allows access for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while updating summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

// --- Handler endpoint DELETE /api/summaries/{id} ---
// Implements the Delete Summary endpoint.
// Authentication check is SKIPPED. Deletes summary for DEFAULT_USER_ID.
export const DELETE: APIRoute = async ({ params, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("DELETE /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("DELETE /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `DELETE /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Deletes summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  try {
    // --- Call Service to delete data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass summaryId to service. Service will use DEFAULT_USER_ID internally.
    await summaryService.deleteDefaultUserSummary(summaryId);

    console.log(`DELETE /api/summaries/${summaryId}: Successfully deleted summary record for DEFAULT user.`);

    return new Response(null, {
      // 204 No Content
      status: 204,
      // No body for 204 response
    });
  } catch (error: any) {
    // Fix: Type error as any
    console.error(`DELETE /api/summaries/${summaryId}: Caught error (DEFAULT_USER):`, error);
    if ((error as any).status === 404) {
      return new Response(
        JSON.stringify({
          message: (error as any).message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    if ((error as any).code === "42501" || (error as any).status === 403) {
      // This might happen if RLS is still partially active
      return new Response(
        JSON.stringify({
          message:
            (error as any).message ||
            `Permission denied for summary ID ${summaryId}. Ensure RLS allows delete for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while deleting summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

export const prerender = false; // Needed for server routes



================================================
File: .history/src/pages/api/summaries_20250421141346.ts
================================================
/* eslint-disable no-console */
/* eslint-disable @typescript-eslint/no-unused-vars */ // Disabled as per previous discussion
// src/pages/api/summaries.ts -- Handlers for /api/summaries (GET, POST, PUT, DELETE)

import type { APIRoute, APIContext } from "astro";
import { z } from "zod"; // Import the Zod library

// Import your local SupabaseClient type alias AND the default user ID
// IMPORTANT: Using DEFAULT_USER_ID instead of auth.uid() for DB operations in this MVP!
import type { SupabaseClient } from "../../db/supabase.client";
import { DEFAULT_USER_ID } from "../../db/supabase.client"; // Import the default user ID

// Import Supabase specific types for better error handling and results
// FIX: Import PostgrestError for specific error checking
import type { PostgrestSingleResponse, PostgrestResponse, PostgrestError } from "@supabase/supabase-js";

// Import shared DTOs and DB internal types from central types file
import type {
  MeetingSummaryListEntryDto,
  CreateSummaryRequestDTO,
  CreateSummaryResponseDTO,
  UpdateSummaryRequestDTO,
  MeetingSummaryInsertData,
  MeetingSummaryFullRow,
  MeetingSummarySelectedColumns,
  ListSummariesServiceParams,
  MeetingSummaryDetailsDto, // Ensure this is imported if used in service method return types or mapping
} from "../../types"; // Adjust the path if necessary

// Import date-fns parseISO for robust date parsing and date helpers
import { parseISO, startOfDay, endOfDay } from "date-fns";

// FIX: Define a custom error type that includes status
interface ApiErrorWithStatus extends Error {
  status?: number;
}

// --- Zod Schema for List Summaries Query Parameters (for GET /api/summaries) ---
const listSummariesParamsSchema = z.object({
  sort_by: z.enum(["created_at", "updated_at"]).optional().default("created_at"),
  sort_order: z.enum(["asc", "desc"]).optional().default("desc"),
  // Accept date strings (YYYY-MM-DD from input type="date") or full ISO 8601
  from_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'from_dt'.",
    }),
  to_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'to_dt'.",
    }),
});

// --- Zod Schema for Create Summary Request Body (for POST /api/summaries) ---
const createSummaryRequestSchema = z.object({
  file_name: z.string().nullable().optional(), // nullable() allows null, optional() allows undefined
  transcription: z.string().min(1, { message: "Transcription cannot be empty." }),
  summary: z
    .string()
    .min(1, { message: "Summary cannot be empty." })
    .max(500, { message: "Summary cannot exceed 500 characters." }),
  llm_generated: z.boolean({ required_error: "Field 'llm_generated' is required and must be a boolean." }),
  notes: z
    .string()
    .nullable()
    .optional()
    .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
});

// --- Zod Schema for Update Summary Request Body (for PUT /api/summaries/{id}) ---
// Allows partial updates
const updateSummaryRequestSchema = z
  .object({
    file_name: z.string().nullable().optional(),
    transcription: z.string().min(1, { message: "Transcription cannot be empty." }).optional(),
    summary: z
      .string()
      .min(1, { message: "Summary cannot be empty." })
      .max(500, { message: "Summary cannot exceed 500 characters." })
      .optional(),
    llm_generated: z.boolean().optional(),
    notes: z
      .string()
      .nullable()
      .optional()
      .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
  })
  .partial(); // Make all fields optional at the top level

// --- SummaryService Class (Central logic for DB interaction) ---
// IMPORTANT: In this MVP version, this service uses DEFAULT_USER_ID for DB operations
// instead of relying on auth.uid() via RLS. This is INSECURE and for MVP ONLY.
class SummaryService {
  constructor(private supabase: SupabaseClient) {}

  // Method to list summaries for the DEFAULT_USER_ID
  async listDefaultUserSummaries(params: ListSummariesServiceParams): Promise<MeetingSummaryListEntryDto[]> {
    // userId parameter is included for type compatibility but ignored in this MVP implementation
    // as we are hardcoding DEFAULT_USER_ID.
    const { dateRange, sortParams } = params;
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID (MVP ONLY).`
    );

    try {
      // Select specific columns for the list view
      let query = this.supabase.from("meeting_summaries").select("id, title, file_name, created_at, modified_at");

      // Explicitly filter by DEFAULT_USER_ID, overriding standard RLS based on auth.uid()
      query = query.eq("user_id", DEFAULT_USER_ID);

      if (dateRange.from) {
        // Use >= for 'from' date (start of the day)
        query = query.gte("created_at", startOfDay(dateRange.from).toISOString());
      }
      if (dateRange.to) {
        // Use <= for 'to' date (end of the day)
        query = query.lte("created_at", endOfDay(dateRange.to).toISOString());
      }

      // Map API sort_by terms to DB column names
      // FIX: Correct the comparison from "updated_at" to "modified_at" as used in state/params type
      const dbSortBy = sortParams.by === "updated_at" ? "modified_at" : "created_at";

      // Apply sorting
      query = query.order(dbSortBy, { ascending: sortParams.order === "asc" });

      // Execute the query
      const result: PostgrestResponse<MeetingSummarySelectedColumns> = await query;
      const { data, error } = result;

      if (error) {
        console.error("Database error fetching summaries for DEFAULT user", DEFAULT_USER_ID, ":", error);
        // Even with DEFAULT_USER_ID, RLS might still be active on the table!
        // If RLS is active and configured to check auth.uid(), this query might fail with 42501
        // because auth.uid() will be null or different from DEFAULT_USER_ID.
        // For this MVP phase using DEFAULT_USER_ID, you might need RLS on meeting_summaries
        // temporarily disabled during local testing, or modified to allow SELECT if user_id = DEFAULT_USER_ID
        // or auth.uid() is null/different. This is a conflict in MVP rules.
        // Assuming for this MVP, RLS is permissive enough for DEFAULT_USER_ID queries *or* temporarily disabled.
        // FIX: Use type guard for error code
        if ((error as unknown as PostgrestError).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          // Re-throw as 500, hiding specific RLS error
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summaries from database.");
      }

      if (!data) {
        console.warn("GET /api/summaries (DEFAULT_USER): Select query returned no data and no error.");
        return []; // Return empty array if no data
      }

      // Map DB rows to frontend DTOs
      const summariesDto: MeetingSummaryListEntryDto[] = data.map((row) => ({
        id: row.id,
        title: row.title,
        file_name: row.file_name,
        created_at: row.created_at,
        updated_at: row.modified_at, // Map DB modified_at to API updated_at
      }));

      return summariesDto;
    } catch (error: unknown) {
      // FIX: Changed type to unknown
      console.error("Error in SummaryService.listDefaultUserSummaries:", error);
      // Pass status code if available, otherwise default to 500
      // FIX: Use type guard for status and message
      const message = error instanceof Error ? error.message : String(error);
      const status =
        error && typeof error === "object" && "status" in error && typeof error.status === "number"
          ? error.status
          : 500;
      const throwError = new Error(message);
      (throwError as ApiErrorWithStatus).status = status;
      throw throwError;
    }
  }

  // Method to get details of a single summary for the DEFAULT_USER_ID
  // FIX: Correct return type to MeetingSummaryFullRow | null as returned by DB query
  async getDefaultUserSummaryDetails(id: string): Promise<MeetingSummaryFullRow | null> {
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID for details (MVP ONLY).`
    );
    try {
      // Select ALL columns (including user_id needed for mapping to FullRow)
      // FIX: select("*") or list all columns for FullRow type
      const query = this.supabase
        .from("meeting_summaries")
        .select("*") // Select all columns to match MeetingSummaryFullRow
        .eq("id", id)
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Use single() for one expected row

      const { data, error } = await query;

      if (error && error.code === "PGRST116") {
        // Supabase specific error code for "no rows found"
        console.warn(`Summary not found for ID ${id} or not owned by DEFAULT user ${DEFAULT_USER_ID}.`);
        return null; // Return null for 404 case
      } else if (error) {
        console.error(
          `Database error fetching summary details for ID ${id} and DEFAULT user ${DEFAULT_USER_ID}:`,
          error
        );
        // FIX: Use type guard for error code
        if ((error as unknown as PostgrestError).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summary details from database.");
      }

      // Data will be of type MeetingSummaryFullRow | null
      return data; // Return the raw data
    } catch (error: unknown) {
      // FIX: Changed type to unknown
      console.error(`Error in SummaryService.getDefaultUserDetails for ID ${id}:`, error);
      // Pass status code if available, otherwise default to 500
      // FIX: Use type guard for status and message
      const message = error instanceof Error ? error.message : String(error);
      const status =
        error && typeof error === "object" && "status" in error && typeof error.status === "number"
          ? error.status
          : 500;
      const throwError = new Error(message);
      (throwError as ApiErrorWithStatus).status = status;
      throw throwError; // Re-throw to be caught by API handler
    }
  }

  // Method to create a new summary for the DEFAULT_USER_ID
  async createDefaultUserSummary(data: CreateSummaryRequestDTO): Promise<MeetingSummaryFullRow> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for creation (MVP ONLY).`);
    // Prepare data for insertion, explicitly setting user_id to DEFAULT_USER_ID
    const dataToInsert: MeetingSummaryInsertData = {
      user_id: DEFAULT_USER_ID, // Assign to DEFAULT user
      file_name: data.file_name,
      transcription: data.transcription,
      summary: data.summary,
      llm_generated: data.llm_generated,
      notes: data.notes, // notes can be string or null from validation
      title:
        data.file_name && data.file_name.trim().length > 0
          ? data.file_name.trim()
          : data.transcription.trim().substring(0, 50) + (data.transcription.trim().length > 50 ? "..." : ""), // Generate title
    };

    console.log("Attempting to insert data into DB for DEFAULT user:", dataToInsert);
    try {
      // Execute the insert query
      // If RLS insert policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .insert([dataToInsert]) // Insert the prepared data
        .select() // Select the inserted row
        .single(); // Expect a single row

      if (result.error) {
        console.error("Database insertion failed for DEFAULT user:", result.error);
        // FIX: Use type guard for error code
        if ((result.error as unknown as PostgrestError).code === "42501") {
          console.error("Potential RLS conflict: Insert for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows insert for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to save summary to database.");
      }

      if (!result.data) {
        console.error("SummaryService.createDefaultUserSummary: Insert returned no error but no data.");
        throw new Error("Database insertion failed unexpectedly.");
      }

      console.log("Database insertion successful for DEFAULT user. New summary ID:", result.data.id);
      return result.data;
    } catch (error: unknown) {
      // FIX: Changed type to unknown
      console.error("Error in SummaryService.createDefaultUserSummary:", error);
      // Pass status code if available, otherwise default to 500
      // FIX: Use type guard for status and message
      const message = error instanceof Error ? error.message : String(error);
      const status =
        error && typeof error === "object" && "status" in error && typeof error.status === "number"
          ? error.status
          : 500;
      const throwError = new Error(message);
      (throwError as ApiErrorWithStatus).status = status;
      throw throwError;
    }
  }

  // Method to update an existing summary for the DEFAULT_USER_ID
  // FIX: Correct return type to MeetingSummaryFullRow as returned by DB query
  async updateDefaultUserSummary(id: string, data: UpdateSummaryRequestDTO): Promise<MeetingSummaryFullRow | null> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for update (MVP ONLY).`);
    console.log(`Attempting to update summary ${id} for DEFAULT user with data:`, data);
    try {
      // Execute the update query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS update policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .update(data) // Update with the provided data
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .select() // Select the updated row
        .single(); // Expect a single row

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows updated"
        console.warn(`Update attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        // Return null or throw specific error for handler to return 404
        // FIX: Use a proper error type with status
        const notFoundError: ApiErrorWithStatus = new Error(`Summary with ID ${id} not found or access denied.`);
        notFoundError.status = 404; // Tag error for handler
        throw notFoundError; // Throw the error for the handler to catch and return 404
      } else if (result.error) {
        console.error(`Database update failed for ID ${id} and DEFAULT user:`, result.error);
        // FIX: Use type guard for error code
        if ((result.error as unknown as PostgrestError).code === "42501") {
          console.error("Potential RLS conflict: Update for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows update for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to update summary in database.");
      }

      // Data will be of type MeetingSummaryFullRow | null. If no error, data should exist due to single().
      if (!result.data) {
        console.error(`SummaryService.updateDefaultUserSummary: Update returned no error but no data for ID ${id}.`);
        throw new Error("Database update failed unexpectedly.");
      }

      console.log(`Database update successful for ID ${id} and DEFAULT user.`);
      return result.data; // Return the updated data
    } catch (error: unknown) {
      // FIX: Changed type to unknown
      console.error(`Error in SummaryService.updateDefaultUserSummary for ID ${id}:`, error);
      // Pass status code if available, otherwise default to 500
      // FIX: Use type guard for status and message
      const message = error instanceof Error ? error.message : String(error);
      const status =
        error && typeof error === "object" && "status" in error && typeof error.status === "number"
          ? error.status
          : 500;
      const throwError = new Error(message);
      (throwError as ApiErrorWithStatus).status = status; // Preserve status if available
      throw throwError; // Re-throw to be caught by API handler
    }
  }

  // Method to delete an existing summary for the DEFAULT_USER_ID
  async deleteDefaultUserSummary(id: string): Promise<void> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for delete (MVP ONLY).`);
    console.log(`Attempting to delete summary ${id} for DEFAULT user ${DEFAULT_USER_ID}`);
    try {
      // Execute the delete query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS delete policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<null> = await this.supabase
        .from("meeting_summaries")
        .delete() // Perform deletion
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Expect a single row deleted or none (returns null on success)

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows found" for delete
        console.warn(`Delete attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        // FIX: Use a proper error type with status
        const notFoundError: ApiErrorWithStatus = new Error(`Summary with ID ${id} not found or access denied.`);
        notFoundError.status = 404; // Tag error for handler
        throw notFoundError; // Throw the error for the handler to catch and return 404
      } else if (result.error) {
        console.error(`Database delete failed for ID ${id} and DEFAULT user:`, result.error);
        // FIX: Use type guard for error code
        if ((result.error as unknown as PostgrestError).code === "42501") {
          console.error("Potential RLS conflict: Delete for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows delete for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to delete summary from database.");
      }

      // Success! result.data will be null for delete single().
      console.log(`Database delete successful for ID ${id} and DEFAULT user.`);
      return; // Return void on success
    } catch (error: unknown) {
      // FIX: Changed type to unknown
      console.error(`Error in SummaryService.deleteDefaultUserSummary for ID ${id}:`, error);
      // Pass status code if available, otherwise default to 500
      // FIX: Use type guard for status and message
      const message = error instanceof Error ? error.message : String(error);
      const status =
        error && typeof error === "object" && "status" in error && typeof error.status === "number"
          ? error.status
          : 500;
      const throwError = new Error(message);
      (throwError as ApiErrorWithStatus).status = status; // Preserve status if available
      throw throwError; // Re-throw to be caught by API handler
    }
  }
}

// --- Handler endpoint GET /api/summaries ---
// Implements the List Summaries endpoint.
// Authentication check is SKIPPED. Data filtered by DEFAULT_USER_ID.
export const GET: APIRoute = async ({ url, locals }) => {
  const supabase = locals.supabase as SupabaseClient;

  // --- Get Supabase client from context.locals ---
  if (!supabase) {
    console.error("GET /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "GET /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data filtered by DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used

  // --- Use Zod for parameter validation (GET) ---
  const queryParams = Object.fromEntries(url.searchParams.entries());
  const validationResult = listSummariesParamsSchema.safeParse(queryParams);

  if (!validationResult.success) {
    console.error("GET /api/summaries: Query parameter validation failed:", validationResult.error);
    return new Response(
      JSON.stringify({
        message: "Invalid query parameters",
        errors: validationResult.error.format(),
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  const validatedParams = validationResult.data;

  // --- Determine Date Range ---
  let fromDate: Date | undefined;
  let toDate: Date | undefined;

  if (validatedParams.from_dt === undefined && validatedParams.to_dt === undefined) {
    // Default to last 7 days
    const now = new Date();
    toDate = endOfDay(now); // End of today
    fromDate = startOfDay(new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)); // Start of 7 days ago
    console.log(`DEBUG: Using default 7-day filter: from ${fromDate.toISOString()} to ${toDate.toISOString()}`);
  } else {
    if (validatedParams.from_dt !== undefined) {
      // Parse the date string provided
      fromDate = parseISO(validatedParams.from_dt);
      if (isNaN(fromDate.getTime())) fromDate = undefined; // Handle potential parse failure after refine
    }
    if (validatedParams.to_dt !== undefined) {
      // Parse the date string provided
      toDate = parseISO(validatedParams.to_dt);
      if (isNaN(toDate.getTime())) toDate = undefined; // Handle potential parse failure after refine
    }
    console.log(
      `DEBUG: Using provided date filters: from ${fromDate?.toISOString() || "none"} to ${toDate?.toISOString() || "none"}`
    );
  }

  // Map API sort_by terms to DB column names for the Service layer
  const dbSortBy: ListSummariesServiceParams["sortParams"]["by"] =
    validatedParams.sort_by === "updated_at" ? "modified_at" : "created_at";
  const sortOrder: ListSummariesServiceParams["sortParams"]["order"] = validatedParams.sort_order;

  try {
    const summaryService = new SummaryService(supabase);

    const serviceParams: ListSummariesServiceParams = {
      userId: DEFAULT_USER_ID, // Pass DEFAULT user ID to service
      dateRange: { from: fromDate, to: toDate },
      sortParams: { by: dbSortBy, order: sortOrder },
    };

    // Use the specific service method for the default user
    const summariesDto: MeetingSummaryListEntryDto[] = await summaryService.listDefaultUserSummaries(serviceParams);

    return new Response(JSON.stringify(summariesDto), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });
  } catch (error: unknown) {
    // FIX: Changed type to unknown
    // FIX: Use type guards for status and message
    const message = error instanceof Error ? error.message : String(error);
    const status =
      error && typeof error === "object" && "status" in error && typeof error.status === "number" ? error.status : 500;

    console.error("Caught error in GET /api/summaries handler (DEFAULT_USER):", error);

    if (status === 404 || status === 403) {
      return new Response(JSON.stringify({ message: message || "Access Denied/Not Found" }), {
        status: status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ message: "An internal server error occurred" }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint POST /api/summaries ---
// Implements the Create New Summary endpoint.
// Authentication check is SKIPPED. Data assigned to DEFAULT_USER_ID.
export const POST: APIRoute = async ({ request, locals }) => {
  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("POST /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "POST /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data assigned to DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;

  try {
    requestBody = await request.json();
  } catch (error) {
    console.error("POST /api/summaries: Failed to parse request body as JSON:", error);
    return new Response(
      JSON.stringify({
        error: "Invalid JSON body",
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  try {
    const validationResult = createSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error("POST /api/summaries: Input validation failed:", validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        {
          status: 400,
          headers: { "Content-Type": "application/json" },
        }
      );
    }

    const validatedData = validationResult.data;

    // --- Call Service to insert data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass validated data to service. Service will use DEFAULT_USER_ID internally.
    const newSummaryRecord: MeetingSummaryFullRow = await summaryService.createDefaultUserSummary(validatedData);

    console.log(
      "POST /api/summaries: Successfully created new summary record with ID:",
      newSummaryRecord.id,
      "for DEFAULT user."
    );

    // Map DB row to frontend DTO
    const responseData: CreateSummaryResponseDTO = {
      id: newSummaryRecord.id,
      user_id: newSummaryRecord.user_id,
      file_name: newSummaryRecord.file_name,
      created_at: newSummaryRecord.created_at,
      updated_at: newSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: newSummaryRecord.transcription,
      summary: newSummaryRecord.summary,
      llm_generated: newSummaryRecord.llm_generated,
      notes: newSummaryRecord.notes,
      title: newSummaryRecord.title,
    };

    return new Response(JSON.stringify(responseData), {
      status: 201, // 201 Created
      headers: {
        "Content-Type": "application/json",
        Location: `/api/summaries/${responseData.id}`, // HATEOAS principle
      },
    });
  } catch (error: unknown) {
    // FIX: Changed type to unknown
    // FIX: Use type guards for status and message
    const message = error instanceof Error ? error.message : String(error);
    const status =
      error && typeof error === "object" && "status" in error && typeof error.status === "number" ? error.status : 500;

    console.error("Caught error in POST /api/summaries handler (DEFAULT_USER):", error);

    if (status === 404 || status === 403) {
      return new Response(JSON.stringify({ message: message || "Access Denied/Not Found" }), {
        status: status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ error: "An internal server error occurred while saving the summary." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint PUT /api/summaries/{id} ---
// Implements the Update Existing Summary endpoint.
// Authentication check is SKIPPED. Updates summary for DEFAULT_USER_ID.
export const PUT: APIRoute = async ({ params, request, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("PUT /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("PUT /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `PUT /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Updates summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;
  try {
    // --- Parse Request Body ---
    requestBody = await request.json();
  } catch (error) {
    console.error(`PUT /api/summaries/${summaryId}: Failed to parse request body as JSON:`, error);
    return new Response(JSON.stringify({ error: "Invalid JSON body" }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  try {
    // --- Input Validation (zod) ---
    const validationResult = updateSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error(`PUT /api/summaries/${summaryId}: Input validation failed:`, validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }

    const validatedData: UpdateSummaryRequestDTO = validationResult.data;

    // Ensure there's at least one field being updated
    if (Object.keys(validatedData).length === 0) {
      console.warn(`PUT /api/summaries/${summaryId}: Request body is empty, no fields to update.`);
      return new Response(JSON.stringify({ error: "Request body must contain fields to update." }), {
        status: 400,
        headers: { "Content-Type": "application/json" },
      });
    }

    // --- Call Service to update data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass updated data and summaryId to service. Service will use DEFAULT_USER_ID internally.
    // FIX: Expect MeetingSummaryFullRow or null return type from service
    const updatedSummaryRecord: MeetingSummaryFullRow | null = await summaryService.updateDefaultUserSummary(
      summaryId,
      validatedData
    );

    // FIX: Handle null return (404 Not Found)
    if (!updatedSummaryRecord) {
      console.warn(`PUT /api/summaries/${summaryId}: Service returned null, likely 404 Not Found.`);
      return new Response(JSON.stringify({ message: `Summary with ID ${summaryId} not found or access denied.` }), {
        status: 404,
        headers: { "Content-Type": "application/json" },
      });
    }

    console.log(`PUT /api/summaries/${summaryId}: Successfully updated summary record for DEFAULT user.`);

    // Map DB row to frontend DTO (MeetingSummaryDetailsDto for consistency with GET details)
    const responseData: MeetingSummaryDetailsDto = {
      id: updatedSummaryRecord.id,
      title: updatedSummaryRecord.title, // Include title as it's in the DB row
      file_name: updatedSummaryRecord.file_name,
      created_at: updatedSummaryRecord.created_at,
      updated_at: updatedSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: updatedSummaryRecord.transcription,
      summary: updatedSummaryRecord.summary,
      llm_generated: updatedSummaryRecord.llm_generated,
      notes: updatedSummaryRecord.notes,
      // user_id is omitted from this DTO
    };

    return new Response(JSON.stringify(responseData), {
      status: 200, // 200 OK
      headers: { "Content-Type": "application/json" },
    });
  } catch (error: unknown) {
    // FIX: Changed type to unknown
    // FIX: Use type guards for status and message
    const message = error instanceof Error ? error.message : String(error);
    const status =
      error && typeof error === "object" && "status" in error && typeof error.status === "number" ? error.status : 500;

    console.error(`PUT /api/summaries/${summaryId}: Caught error after validation (DEFAULT_USER):`, error);
    // Check if it's a known error type from service
    if (status === 404) {
      // Service indicates Not Found/Not Owned - redundant if null check above works
      return new Response(
        JSON.stringify({
          message: message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    // FIX: Use type guard for error code
    if (
      (error &&
        typeof error === "object" &&
        "code" in error &&
        typeof error.code === "string" &&
        error.code === "42501") ||
      status === 403
    ) {
      // Service indicates Permission Denied
      return new Response(
        JSON.stringify({
          message:
            message || `Permission denied for summary ID ${summaryId}. Ensure RLS allows access for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while updating summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

// --- Handler endpoint DELETE /api/summaries/{id} ---
// Implements the Delete Summary endpoint.
// Authentication check is SKIPPED. Deletes summary for DEFAULT_USER_ID.
export const DELETE: APIRoute = async ({ params, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("DELETE /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("DELETE /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `DELETE /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Deletes summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  try {
    // --- Call Service to delete data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass summaryId to service. Service will use DEFAULT_USER_ID internally.
    await summaryService.deleteDefaultUserSummary(summaryId);

    console.log(`DELETE /api/summaries/${summaryId}: Successfully deleted summary record for DEFAULT user.`);

    return new Response(null, {
      // 204 No Content
      status: 204,
      // No body for 204 response
    });
  } catch (error: unknown) {
    // FIX: Changed type to unknown
    // FIX: Use type guards for status and message
    const message = error instanceof Error ? error.message : String(error);
    const status =
      error && typeof error === "object" && "status" in error && typeof error.status === "number" ? error.status : 500;

    console.error(`DELETE /api/summaries/${summaryId}: Caught error (DEFAULT_USER):`, error);

    if (status === 404) {
      return new Response(
        JSON.stringify({
          message: message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    // FIX: Use type guard for error code
    if (
      (error &&
        typeof error === "object" &&
        "code" in error &&
        typeof error.code === "string" &&
        error.code === "42501") ||
      status === 403
    ) {
      // This might happen if RLS is still partially active
      return new Response(
        JSON.stringify({
          message:
            message || `Permission denied for summary ID ${summaryId}. Ensure RLS allows delete for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while deleting summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

export const prerender = false; // Needed for server routes



================================================
File: .history/src/pages/api/summaries_20250421141357.ts
================================================
/* eslint-disable no-console */
/* eslint-disable @typescript-eslint/no-unused-vars */ // Disabled as per previous discussion
// src/pages/api/summaries.ts -- Handlers for /api/summaries (GET, POST, PUT, DELETE)

import type { APIRoute, APIContext } from "astro";
import { z } from "zod"; // Import the Zod library

// Import your local SupabaseClient type alias AND the default user ID
// IMPORTANT: Using DEFAULT_USER_ID instead of auth.uid() for DB operations in this MVP!
import type { SupabaseClient } from "../../db/supabase.client";
import { DEFAULT_USER_ID } from "../../db/supabase.client"; // Import the default user ID

// Import Supabase specific types for better error handling and results
// FIX: Import PostgrestError for specific error checking
import type { PostgrestSingleResponse, PostgrestResponse, PostgrestError } from "@supabase/supabase-js";

// Import shared DTOs and DB internal types from central types file
import type {
  MeetingSummaryListEntryDto,
  CreateSummaryRequestDTO,
  CreateSummaryResponseDTO,
  UpdateSummaryRequestDTO,
  MeetingSummaryInsertData,
  MeetingSummaryFullRow,
  MeetingSummarySelectedColumns,
  ListSummariesServiceParams,
  MeetingSummaryDetailsDto, // Ensure this is imported if used in service method return types or mapping
} from "../../types"; // Adjust the path if necessary

// Import date-fns parseISO for robust date parsing and date helpers
import { parseISO, startOfDay, endOfDay } from "date-fns";

// FIX: Define a custom error type that includes status
interface ApiErrorWithStatus extends Error {
  status?: number;
}

// --- Zod Schema for List Summaries Query Parameters (for GET /api/summaries) ---
const listSummariesParamsSchema = z.object({
  sort_by: z.enum(["created_at", "updated_at"]).optional().default("created_at"),
  sort_order: z.enum(["asc", "desc"]).optional().default("desc"),
  // Accept date strings (YYYY-MM-DD from input type="date") or full ISO 8601
  from_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'from_dt'.",
    }),
  to_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'to_dt'.",
    }),
});

// --- Zod Schema for Create Summary Request Body (for POST /api/summaries) ---
const createSummaryRequestSchema = z.object({
  file_name: z.string().nullable().optional(), // nullable() allows null, optional() allows undefined
  transcription: z.string().min(1, { message: "Transcription cannot be empty." }),
  summary: z
    .string()
    .min(1, { message: "Summary cannot be empty." })
    .max(500, { message: "Summary cannot exceed 500 characters." }),
  llm_generated: z.boolean({ required_error: "Field 'llm_generated' is required and must be a boolean." }),
  notes: z
    .string()
    .nullable()
    .optional()
    .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
});

// --- Zod Schema for Update Summary Request Body (for PUT /api/summaries/{id}) ---
// Allows partial updates
const updateSummaryRequestSchema = z
  .object({
    file_name: z.string().nullable().optional(),
    transcription: z.string().min(1, { message: "Transcription cannot be empty." }).optional(),
    summary: z
      .string()
      .min(1, { message: "Summary cannot be empty." })
      .max(500, { message: "Summary cannot exceed 500 characters." })
      .optional(),
    llm_generated: z.boolean().optional(),
    notes: z
      .string()
      .nullable()
      .optional()
      .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
  })
  .partial(); // Make all fields optional at the top level

// --- SummaryService Class (Central logic for DB interaction) ---
// IMPORTANT: In this MVP version, this service uses DEFAULT_USER_ID for DB operations
// instead of relying on auth.uid() via RLS. This is INSECURE and for MVP ONLY.
class SummaryService {
  constructor(private supabase: SupabaseClient) {}

  // Method to list summaries for the DEFAULT_USER_ID
  async listDefaultUserSummaries(params: ListSummariesServiceParams): Promise<MeetingSummaryListEntryDto[]> {
    // userId parameter is included for type compatibility but ignored in this MVP implementation
    // as we are hardcoding DEFAULT_USER_ID.
    const { dateRange, sortParams } = params;
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID (MVP ONLY).`
    );

    try {
      // Select specific columns for the list view
      let query = this.supabase.from("meeting_summaries").select("id, title, file_name, created_at, modified_at");

      // Explicitly filter by DEFAULT_USER_ID, overriding standard RLS based on auth.uid()
      query = query.eq("user_id", DEFAULT_USER_ID);

      if (dateRange.from) {
        // Use >= for 'from' date (start of the day)
        query = query.gte("created_at", startOfDay(dateRange.from).toISOString());
      }
      if (dateRange.to) {
        // Use <= for 'to' date (end of the day)
        query = query.lte("created_at", endOfDay(dateRange.to).toISOString());
      }

      // Map API sort_by terms to DB column names
      // FIX: Correct the comparison from "updated_at" to "modified_at" as used in state/params type
      const dbSortBy = sortParams.by === "updated_at" ? "modified_at" : "created_at";

      // Apply sorting
      query = query.order(dbSortBy, { ascending: sortParams.order === "asc" });

      // Execute the query
      const result: PostgrestResponse<MeetingSummarySelectedColumns> = await query;
      const { data, error } = result;

      if (error) {
        console.error("Database error fetching summaries for DEFAULT user", DEFAULT_USER_ID, ":", error);
        // Even with DEFAULT_USER_ID, RLS might still be active on the table!
        // If RLS is active and configured to check auth.uid(), this query might fail with 42501
        // because auth.uid() will be null or different from DEFAULT_USER_ID.
        // For this MVP phase using DEFAULT_USER_ID, you might need RLS on meeting_summaries
        // temporarily disabled during local testing, or modified to allow SELECT if user_id = DEFAULT_USER_ID
        // or auth.uid() is null/different. This is a conflict in MVP rules.
        // Assuming for this MVP, RLS is permissive enough for DEFAULT_USER_ID queries *or* temporarily disabled.
        // FIX: Use type guard for error code
        if ((error as unknown as PostgrestError).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          // Re-throw as 500, hiding specific RLS error
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summaries from database.");
      }

      if (!data) {
        console.warn("GET /api/summaries (DEFAULT_USER): Select query returned no data and no error.");
        return []; // Return empty array if no data
      }

      // Map DB rows to frontend DTOs
      const summariesDto: MeetingSummaryListEntryDto[] = data.map((row) => ({
        id: row.id,
        title: row.title,
        file_name: row.file_name,
        created_at: row.created_at,
        updated_at: row.modified_at, // Map DB modified_at to API updated_at
      }));

      return summariesDto;
    } catch (error: unknown) {
      // FIX: Changed type to unknown
      console.error("Error in SummaryService.listDefaultUserSummaries:", error);
      // Pass status code if available, otherwise default to 500
      // FIX: Use type guard for status and message
      const message = error instanceof Error ? error.message : String(error);
      const status =
        error && typeof error === "object" && "status" in error && typeof error.status === "number"
          ? error.status
          : 500;
      const throwError = new Error(message);
      (throwError as ApiErrorWithStatus).status = status;
      throw throwError;
    }
  }

  // Method to get details of a single summary for the DEFAULT_USER_ID
  // FIX: Correct return type to MeetingSummaryFullRow | null as returned by DB query
  async getDefaultUserSummaryDetails(id: string): Promise<MeetingSummaryFullRow | null> {
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID for details (MVP ONLY).`
    );
    try {
      // Select ALL columns (including user_id needed for mapping to FullRow)
      // FIX: select("*") or list all columns for FullRow type
      const query = this.supabase
        .from("meeting_summaries")
        .select("*") // Select all columns to match MeetingSummaryFullRow
        .eq("id", id)
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Use single() for one expected row

      const { data, error } = await query;

      if (error && error.code === "PGRST116") {
        // Supabase specific error code for "no rows found"
        console.warn(`Summary not found for ID ${id} or not owned by DEFAULT user ${DEFAULT_USER_ID}.`);
        return null; // Return null for 404 case
      } else if (error) {
        console.error(
          `Database error fetching summary details for ID ${id} and DEFAULT user ${DEFAULT_USER_ID}:`,
          error
        );
        // FIX: Use type guard for error code
        if ((error as unknown as PostgrestError).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summary details from database.");
      }

      // Data will be of type MeetingSummaryFullRow | null
      return data; // Return the raw data
    } catch (error: unknown) {
      // FIX: Changed type to unknown
      console.error(`Error in SummaryService.getDefaultUserDetails for ID ${id}:`, error);
      // Pass status code if available, otherwise default to 500
      // FIX: Use type guard for status and message
      const message = error instanceof Error ? error.message : String(error);
      const status =
        error && typeof error === "object" && "status" in error && typeof error.status === "number"
          ? error.status
          : 500;
      const throwError = new Error(message);
      (throwError as ApiErrorWithStatus).status = status;
      throw throwError; // Re-throw to be caught by API handler
    }
  }

  // Method to create a new summary for the DEFAULT_USER_ID
  async createDefaultUserSummary(data: CreateSummaryRequestDTO): Promise<MeetingSummaryFullRow> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for creation (MVP ONLY).`);
    // Prepare data for insertion, explicitly setting user_id to DEFAULT_USER_ID
    const dataToInsert: MeetingSummaryInsertData = {
      user_id: DEFAULT_USER_ID, // Assign to DEFAULT user
      file_name: data.file_name,
      transcription: data.transcription,
      summary: data.summary,
      llm_generated: data.llm_generated,
      notes: data.notes, // notes can be string or null from validation
      title:
        data.file_name && data.file_name.trim().length > 0
          ? data.file_name.trim()
          : data.transcription.trim().substring(0, 50) + (data.transcription.trim().length > 50 ? "..." : ""), // Generate title
    };

    console.log("Attempting to insert data into DB for DEFAULT user:", dataToInsert);
    try {
      // Execute the insert query
      // If RLS insert policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .insert([dataToInsert]) // Insert the prepared data
        .select() // Select the inserted row
        .single(); // Expect a single row

      if (result.error) {
        console.error("Database insertion failed for DEFAULT user:", result.error);
        // FIX: Use type guard for error code
        if ((result.error as unknown as PostgrestError).code === "42501") {
          console.error("Potential RLS conflict: Insert for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows insert for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to save summary to database.");
      }

      if (!result.data) {
        console.error("SummaryService.createDefaultUserSummary: Insert returned no error but no data.");
        throw new Error("Database insertion failed unexpectedly.");
      }

      console.log("Database insertion successful for DEFAULT user. New summary ID:", result.data.id);
      return result.data;
    } catch (error: unknown) {
      // FIX: Changed type to unknown
      console.error("Error in SummaryService.createDefaultUserSummary:", error);
      // Pass status code if available, otherwise default to 500
      // FIX: Use type guard for status and message
      const message = error instanceof Error ? error.message : String(error);
      const status =
        error && typeof error === "object" && "status" in error && typeof error.status === "number"
          ? error.status
          : 500;
      const throwError = new Error(message);
      (throwError as ApiErrorWithStatus).status = status;
      throw throwError;
    }
  }

  // Method to update an existing summary for the DEFAULT_USER_ID
  // FIX: Correct return type to MeetingSummaryFullRow as returned by DB query
  async updateDefaultUserSummary(id: string, data: UpdateSummaryRequestDTO): Promise<MeetingSummaryFullRow | null> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for update (MVP ONLY).`);
    console.log(`Attempting to update summary ${id} for DEFAULT user with data:`, data);
    try {
      // Execute the update query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS update policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .update(data) // Update with the provided data
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .select() // Select the updated row
        .single(); // Expect a single row

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows updated"
        console.warn(`Update attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        // Return null or throw specific error for handler to return 404
        // FIX: Use a proper error type with status
        const notFoundError: ApiErrorWithStatus = new Error(`Summary with ID ${id} not found or access denied.`);
        notFoundError.status = 404; // Tag error for handler
        throw notFoundError; // Throw the error for the handler to catch and return 404
      } else if (result.error) {
        console.error(`Database update failed for ID ${id} and DEFAULT user:`, result.error);
        // FIX: Use type guard for error code
        if ((result.error as unknown as PostgrestError).code === "42501") {
          console.error("Potential RLS conflict: Update for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows update for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to update summary in database.");
      }

      // Data will be of type MeetingSummaryFullRow | null. If no error, data should exist due to single().
      if (!result.data) {
        console.error(`SummaryService.updateDefaultUserSummary: Update returned no error but no data for ID ${id}.`);
        throw new Error("Database update failed unexpectedly.");
      }

      console.log(`Database update successful for ID ${id} and DEFAULT user.`);
      return result.data; // Return the updated data
    } catch (error: unknown) {
      // FIX: Changed type to unknown
      console.error(`Error in SummaryService.updateDefaultUserSummary for ID ${id}:`, error);
      // Pass status code if available, otherwise default to 500
      // FIX: Use type guard for status and message
      const message = error instanceof Error ? error.message : String(error);
      const status =
        error && typeof error === "object" && "status" in error && typeof error.status === "number"
          ? error.status
          : 500;
      const throwError = new Error(message);
      (throwError as ApiErrorWithStatus).status = status; // Preserve status if available
      throw throwError; // Re-throw to be caught by API handler
    }
  }

  // Method to delete an existing summary for the DEFAULT_USER_ID
  async deleteDefaultUserSummary(id: string): Promise<void> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for delete (MVP ONLY).`);
    console.log(`Attempting to delete summary ${id} for DEFAULT user ${DEFAULT_USER_ID}`);
    try {
      // Execute the delete query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS delete policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<null> = await this.supabase
        .from("meeting_summaries")
        .delete() // Perform deletion
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Expect a single row deleted or none (returns null on success)

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows found" for delete
        console.warn(`Delete attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        // FIX: Use a proper error type with status
        const notFoundError: ApiErrorWithStatus = new Error(`Summary with ID ${id} not found or access denied.`);
        notFoundError.status = 404; // Tag error for handler
        throw notFoundError; // Throw the error for the handler to catch and return 404
      } else if (result.error) {
        console.error(`Database delete failed for ID ${id} and DEFAULT user:`, result.error);
        // FIX: Use type guard for error code
        if ((result.error as unknown as PostgrestError).code === "42501") {
          console.error("Potential RLS conflict: Delete for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows delete for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to delete summary from database.");
      }

      // Success! result.data will be null for delete single().
      console.log(`Database delete successful for ID ${id} and DEFAULT user.`);
      return; // Return void on success
    } catch (error: unknown) {
      // FIX: Changed type to unknown
      console.error(`Error in SummaryService.deleteDefaultUserSummary for ID ${id}:`, error);
      // Pass status code if available, otherwise default to 500
      // FIX: Use type guard for status and message
      const message = error instanceof Error ? error.message : String(error);
      const status =
        error && typeof error === "object" && "status" in error && typeof error.status === "number"
          ? error.status
          : 500;
      const throwError = new Error(message);
      (throwError as ApiErrorWithStatus).status = status; // Preserve status if available
      throw throwError; // Re-throw to be caught by API handler
    }
  }
}

// --- Handler endpoint GET /api/summaries ---
// Implements the List Summaries endpoint.
// Authentication check is SKIPPED. Data filtered by DEFAULT_USER_ID.
export const GET: APIRoute = async ({ url, locals }) => {
  const supabase = locals.supabase as SupabaseClient;

  // --- Get Supabase client from context.locals ---
  if (!supabase) {
    console.error("GET /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "GET /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data filtered by DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used

  // --- Use Zod for parameter validation (GET) ---
  const queryParams = Object.fromEntries(url.searchParams.entries());
  const validationResult = listSummariesParamsSchema.safeParse(queryParams);

  if (!validationResult.success) {
    console.error("GET /api/summaries: Query parameter validation failed:", validationResult.error);
    return new Response(
      JSON.stringify({
        message: "Invalid query parameters",
        errors: validationResult.error.format(),
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  const validatedParams = validationResult.data;

  // --- Determine Date Range ---
  let fromDate: Date | undefined;
  let toDate: Date | undefined;

  if (validatedParams.from_dt === undefined && validatedParams.to_dt === undefined) {
    // Default to last 7 days
    const now = new Date();
    toDate = endOfDay(now); // End of today
    fromDate = startOfDay(new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)); // Start of 7 days ago
    console.log(`DEBUG: Using default 7-day filter: from ${fromDate.toISOString()} to ${toDate.toISOString()}`);
  } else {
    if (validatedParams.from_dt !== undefined) {
      // Parse the date string provided
      fromDate = parseISO(validatedParams.from_dt);
      if (isNaN(fromDate.getTime())) fromDate = undefined; // Handle potential parse failure after refine
    }
    if (validatedParams.to_dt !== undefined) {
      // Parse the date string provided
      toDate = parseISO(validatedParams.to_dt);
      if (isNaN(toDate.getTime())) toDate = undefined; // Handle potential parse failure after refine
    }
    console.log(
      `DEBUG: Using provided date filters: from ${fromDate?.toISOString() || "none"} to ${toDate?.toISOString() || "none"}`
    );
  }

  // Map API sort_by terms to DB column names for the Service layer
  const dbSortBy: ListSummariesServiceParams["sortParams"]["by"] =
    validatedParams.sort_by === "updated_at" ? "modified_at" : "created_at";
  const sortOrder: ListSummariesServiceParams["sortParams"]["order"] = validatedParams.sort_order;

  try {
    const summaryService = new SummaryService(supabase);

    const serviceParams: ListSummariesServiceParams = {
      userId: DEFAULT_USER_ID, // Pass DEFAULT user ID to service
      dateRange: { from: fromDate, to: toDate },
      sortParams: { by: dbSortBy, order: sortOrder },
    };

    // Use the specific service method for the default user
    const summariesDto: MeetingSummaryListEntryDto[] = await summaryService.listDefaultUserSummaries(serviceParams);

    return new Response(JSON.stringify(summariesDto), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });
  } catch (error: unknown) {
    // FIX: Changed type to unknown
    // FIX: Use type guards for status and message
    const message = error instanceof Error ? error.message : String(error);
    const status =
      error && typeof error === "object" && "status" in error && typeof error.status === "number" ? error.status : 500;

    console.error("Caught error in GET /api/summaries handler (DEFAULT_USER):", error);

    if (status === 404 || status === 403) {
      return new Response(JSON.stringify({ message: message || "Access Denied/Not Found" }), {
        status: status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ message: "An internal server error occurred" }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint POST /api/summaries ---
// Implements the Create New Summary endpoint.
// Authentication check is SKIPPED. Data assigned to DEFAULT_USER_ID.
export const POST: APIRoute = async ({ request, locals }) => {
  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("POST /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "POST /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data assigned to DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;

  try {
    requestBody = await request.json();
  } catch (error) {
    console.error("POST /api/summaries: Failed to parse request body as JSON:", error);
    return new Response(
      JSON.stringify({
        error: "Invalid JSON body",
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  try {
    const validationResult = createSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error("POST /api/summaries: Input validation failed:", validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        {
          status: 400,
          headers: { "Content-Type": "application/json" },
        }
      );
    }

    const validatedData = validationResult.data;

    // --- Call Service to insert data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass validated data to service. Service will use DEFAULT_USER_ID internally.
    const newSummaryRecord: MeetingSummaryFullRow = await summaryService.createDefaultUserSummary(validatedData);

    console.log(
      "POST /api/summaries: Successfully created new summary record with ID:",
      newSummaryRecord.id,
      "for DEFAULT user."
    );

    // Map DB row to frontend DTO
    const responseData: CreateSummaryResponseDTO = {
      id: newSummaryRecord.id,
      user_id: newSummaryRecord.user_id,
      file_name: newSummaryRecord.file_name,
      created_at: newSummaryRecord.created_at,
      updated_at: newSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: newSummaryRecord.transcription,
      summary: newSummaryRecord.summary,
      llm_generated: newSummaryRecord.llm_generated,
      notes: newSummaryRecord.notes,
      title: newSummaryRecord.title,
    };

    return new Response(JSON.stringify(responseData), {
      status: 201, // 201 Created
      headers: {
        "Content-Type": "application/json",
        Location: `/api/summaries/${responseData.id}`, // HATEOAS principle
      },
    });
  } catch (error: unknown) {
    // FIX: Changed type to unknown
    // FIX: Use type guards for status and message
    const message = error instanceof Error ? error.message : String(error);
    const status =
      error && typeof error === "object" && "status" in error && typeof error.status === "number" ? error.status : 500;

    console.error("Caught error in POST /api/summaries handler (DEFAULT_USER):", error);

    if (status === 404 || status === 403) {
      return new Response(JSON.stringify({ message: message || "Access Denied/Not Found" }), {
        status: status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ error: "An internal server error occurred while saving the summary." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint PUT /api/summaries/{id} ---
// Implements the Update Existing Summary endpoint.
// Authentication check is SKIPPED. Updates summary for DEFAULT_USER_ID.
export const PUT: APIRoute = async ({ params, request, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("PUT /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("PUT /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `PUT /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Updates summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;
  try {
    // --- Parse Request Body ---
    requestBody = await request.json();
  } catch (error) {
    console.error(`PUT /api/summaries/${summaryId}: Failed to parse request body as JSON:`, error);
    return new Response(JSON.stringify({ error: "Invalid JSON body" }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  try {
    // --- Input Validation (zod) ---
    const validationResult = updateSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error(`PUT /api/summaries/${summaryId}: Input validation failed:`, validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }

    const validatedData: UpdateSummaryRequestDTO = validationResult.data;

    // Ensure there's at least one field being updated
    if (Object.keys(validatedData).length === 0) {
      console.warn(`PUT /api/summaries/${summaryId}: Request body is empty, no fields to update.`);
      return new Response(JSON.stringify({ error: "Request body must contain fields to update." }), {
        status: 400,
        headers: { "Content-Type": "application/json" },
      });
    }

    // --- Call Service to update data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass updated data and summaryId to service. Service will use DEFAULT_USER_ID internally.
    // FIX: Expect MeetingSummaryFullRow or null return type from service
    const updatedSummaryRecord: MeetingSummaryFullRow | null = await summaryService.updateDefaultUserSummary(
      summaryId,
      validatedData
    );

    // FIX: Handle null return (404 Not Found)
    if (!updatedSummaryRecord) {
      console.warn(`PUT /api/summaries/${summaryId}: Service returned null, likely 404 Not Found.`);
      return new Response(JSON.stringify({ message: `Summary with ID ${summaryId} not found or access denied.` }), {
        status: 404,
        headers: { "Content-Type": "application/json" },
      });
    }

    console.log(`PUT /api/summaries/${summaryId}: Successfully updated summary record for DEFAULT user.`);

    // Map DB row to frontend DTO (MeetingSummaryDetailsDto for consistency with GET details)
    const responseData: MeetingSummaryDetailsDto = {
      id: updatedSummaryRecord.id,
      title: updatedSummaryRecord.title, // Include title as it's in the DB row
      file_name: updatedSummaryRecord.file_name,
      created_at: updatedSummaryRecord.created_at,
      updated_at: updatedSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: updatedSummaryRecord.transcription,
      summary: updatedSummaryRecord.summary,
      llm_generated: updatedSummaryRecord.llm_generated,
      notes: updatedSummaryRecord.notes,
      // user_id is omitted from this DTO
    };

    return new Response(JSON.stringify(responseData), {
      status: 200, // 200 OK
      headers: { "Content-Type": "application/json" },
    });
  } catch (error: unknown) {
    // FIX: Changed type to unknown
    // FIX: Use type guards for status and message
    const message = error instanceof Error ? error.message : String(error);
    const status =
      error && typeof error === "object" && "status" in error && typeof error.status === "number" ? error.status : 500;

    console.error(`PUT /api/summaries/${summaryId}: Caught error after validation (DEFAULT_USER):`, error);
    // Check if it's a known error type from service
    if (status === 404) {
      // Service indicates Not Found/Not Owned - redundant if null check above works
      return new Response(
        JSON.stringify({
          message: message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    // FIX: Use type guard for error code
    if (
      (error &&
        typeof error === "object" &&
        "code" in error &&
        typeof error.code === "string" &&
        error.code === "42501") ||
      status === 403
    ) {
      // Service indicates Permission Denied
      return new Response(
        JSON.stringify({
          message:
            message || `Permission denied for summary ID ${summaryId}. Ensure RLS allows access for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while updating summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

// --- Handler endpoint DELETE /api/summaries/{id} ---
// Implements the Delete Summary endpoint.
// Authentication check is SKIPPED. Deletes summary for DEFAULT_USER_ID.
export const DELETE: APIRoute = async ({ params, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("DELETE /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("DELETE /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `DELETE /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Deletes summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  try {
    // --- Call Service to delete data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass summaryId to service. Service will use DEFAULT_USER_ID internally.
    await summaryService.deleteDefaultUserSummary(summaryId);

    console.log(`DELETE /api/summaries/${summaryId}: Successfully deleted summary record for DEFAULT user.`);

    return new Response(null, {
      // 204 No Content
      status: 204,
      // No body for 204 response
    });
  } catch (error: unknown) {
    // FIX: Changed type to unknown
    // FIX: Use type guards for status and message
    const message = error instanceof Error ? error.message : String(error);
    const status =
      error && typeof error === "object" && "status" in error && typeof error.status === "number" ? error.status : 500;

    console.error(`DELETE /api/summaries/${summaryId}: Caught error (DEFAULT_USER):`, error);

    if (status === 404) {
      return new Response(
        JSON.stringify({
          message: message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    // FIX: Use type guard for error code
    if (
      (error &&
        typeof error === "object" &&
        "code" in error &&
        typeof error.code === "string" &&
        error.code === "42501") ||
      status === 403
    ) {
      // This might happen if RLS is still partially active
      return new Response(
        JSON.stringify({
          message:
            message || `Permission denied for summary ID ${summaryId}. Ensure RLS allows delete for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while deleting summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

export const prerender = false; // Needed for server routes



================================================
File: .history/src/pages/api/summaries_20250421141525.ts
================================================
/* eslint-disable no-console */
/* eslint-disable @typescript-eslint/no-unused-vars */ // Disabled as per previous discussion
// src/pages/api/summaries.ts -- Handlers for /api/summaries (GET, POST, PUT, DELETE)

import type { APIRoute, APIContext } from "astro";
import { z } from "zod"; // Import the Zod library

// Import your local SupabaseClient type alias AND the default user ID
// IMPORTANT: Using DEFAULT_USER_ID instead of auth.uid() for DB operations in this MVP!
import type { SupabaseClient } from "../../db/supabase.client";
import { DEFAULT_USER_ID } from "../../db/supabase.client"; // Import the default user ID

// Import Supabase specific types for better error handling and results
// FIX: Import PostgrestError for specific error checking
import type { PostgrestSingleResponse, PostgrestResponse, PostgrestError } from "@supabase/supabase-js";

// Import shared DTOs and DB internal types from central types file
import type {
  MeetingSummaryListEntryDto,
  CreateSummaryRequestDTO,
  CreateSummaryResponseDTO,
  UpdateSummaryRequestDTO,
  MeetingSummaryInsertData,
  MeetingSummaryFullRow,
  MeetingSummarySelectedColumns,
  ListSummariesServiceParams,
  MeetingSummaryDetailsDto, // Ensure this is imported if used in service method return types or mapping
} from "../../types"; // Adjust the path if necessary

// Import date-fns parseISO for robust date parsing and date helpers
import { parseISO, startOfDay, endOfDay } from "date-fns";

// FIX: Define a custom error type that includes status
interface ApiErrorWithStatus extends Error {
  status?: number;
}

// --- Zod Schema for List Summaries Query Parameters (for GET /api/summaries) ---
const listSummariesParamsSchema = z.object({
  sort_by: z.enum(["created_at", "updated_at"]).optional().default("created_at"),
  sort_order: z.enum(["asc", "desc"]).optional().default("desc"),
  // Accept date strings (YYYY-MM-DD from input type="date") or full ISO 8601
  from_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'from_dt'.",
    }),
  to_dt: z
    .string()
    .optional()
    .refine((val) => !val || !isNaN(parseISO(val).getTime()), {
      message: "Invalid date format for 'to_dt'.",
    }),
});

// --- Zod Schema for Create Summary Request Body (for POST /api/summaries) ---
const createSummaryRequestSchema = z.object({
  file_name: z.string().nullable().optional(), // nullable() allows null, optional() allows undefined
  transcription: z.string().min(1, { message: "Transcription cannot be empty." }),
  summary: z
    .string()
    .min(1, { message: "Summary cannot be empty." })
    .max(500, { message: "Summary cannot exceed 500 characters." }),
  llm_generated: z.boolean({ required_error: "Field 'llm_generated' is required and must be a boolean." }),
  notes: z
    .string()
    .nullable()
    .optional()
    .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
});

// --- Zod Schema for Update Summary Request Body (for PUT /api/summaries/{id}) ---
// Allows partial updates
const updateSummaryRequestSchema = z
  .object({
    file_name: z.string().nullable().optional(),
    transcription: z.string().min(1, { message: "Transcription cannot be empty." }).optional(),
    summary: z
      .string()
      .min(1, { message: "Summary cannot be empty." })
      .max(500, { message: "Summary cannot exceed 500 characters." })
      .optional(),
    llm_generated: z.boolean().optional(),
    notes: z
      .string()
      .nullable()
      .optional()
      .transform((e) => (e === "" ? null : e)), // Convert empty string to null, allow undefined/null input
  })
  .partial(); // Make all fields optional at the top level

// --- SummaryService Class (Central logic for DB interaction) ---
// IMPORTANT: In this MVP version, this service uses DEFAULT_USER_ID for DB operations
// instead of relying on auth.uid() via RLS. This is INSECURE and for MVP ONLY.
class SummaryService {
  constructor(private supabase: SupabaseClient) {}

  // Method to list summaries for the DEFAULT_USER_ID
  async listDefaultUserSummaries(params: ListSummariesServiceParams): Promise<MeetingSummaryListEntryDto[]> {
    // userId parameter is included for type compatibility but ignored in this MVP implementation
    // as we are hardcoding DEFAULT_USER_ID.
    const { dateRange, sortParams } = params;
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID (MVP ONLY).`
    );

    try {
      // Select specific columns for the list view
      let query = this.supabase.from("meeting_summaries").select("id, title, file_name, created_at, modified_at");

      // Explicitly filter by DEFAULT_USER_ID, overriding standard RLS based on auth.uid()
      query = query.eq("user_id", DEFAULT_USER_ID);

      if (dateRange.from) {
        // Use >= for 'from' date (start of the day)
        query = query.gte("created_at", startOfDay(dateRange.from).toISOString());
      }
      if (dateRange.to) {
        // Use <= for 'to' date (end of the day)
        query = query.lte("created_at", endOfDay(dateRange.to).toISOString());
      }

      // Map API sort_by terms to DB column names
      // FIX: Correct the comparison from "updated_at" to "modified_at" as used in state/params type
      const dbSortBy = sortParams.by === "updated_at" ? "modified_at" : "created_at";

      // Apply sorting
      query = query.order(dbSortBy, { ascending: sortParams.order === "asc" });

      // Execute the query
      const result: PostgrestResponse<MeetingSummarySelectedColumns> = await query;
      const { data, error } = result;

      if (error) {
        console.error("Database error fetching summaries for DEFAULT user", DEFAULT_USER_ID, ":", error);
        // Even with DEFAULT_USER_ID, RLS might still be active on the table!
        // If RLS is active and configured to check auth.uid(), this query might fail with 42501
        // because auth.uid() will be null or different from DEFAULT_USER_ID.
        // For this MVP phase using DEFAULT_USER_ID, you might need RLS on meeting_summaries
        // temporarily disabled during local testing, or modified to allow SELECT if user_id = DEFAULT_USER_ID
        // or auth.uid() is null/different. This is a conflict in MVP rules.
        // Assuming for this MVP, RLS is permissive enough for DEFAULT_USER_ID queries *or* temporarily disabled.
        // FIX: Use type guard for error code
        if ((error as unknown as PostgrestError).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          // Re-throw as 500, hiding specific RLS error
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summaries from database.");
      }

      if (!data) {
        console.warn("GET /api/summaries (DEFAULT_USER): Select query returned no data and no error.");
        return []; // Return empty array if no data
      }

      // Map DB rows to frontend DTOs
      const summariesDto: MeetingSummaryListEntryDto[] = data.map((row) => ({
        id: row.id,
        title: row.title,
        file_name: row.file_name,
        created_at: row.created_at,
        updated_at: row.modified_at, // Map DB modified_at to API updated_at
      }));

      return summariesDto;
    } catch (error: unknown) {
      // FIX: Changed type to unknown
      console.error("Error in SummaryService.listDefaultUserSummaries:", error);
      // Pass status code if available, otherwise default to 500
      // FIX: Use type guard for status and message
      const message = error instanceof Error ? error.message : String(error);
      const status =
        error && typeof error === "object" && "status" in error && typeof error.status === "number"
          ? error.status
          : 500;
      const throwError = new Error(message);
      (throwError as ApiErrorWithStatus).status = status;
      throw throwError;
    }
  }

  // Method to get details of a single summary for the DEFAULT_USER_ID
  // FIX: Correct return type to MeetingSummaryFullRow | null as returned by DB query
  async getDefaultUserSummaryDetails(id: string): Promise<MeetingSummaryFullRow | null> {
    console.warn(
      `SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} instead of authenticated user ID for details (MVP ONLY).`
    );
    try {
      // Select ALL columns (including user_id needed for mapping to FullRow)
      // FIX: select("*") or list all columns for FullRow type
      const query = this.supabase
        .from("meeting_summaries")
        .select("*") // Select all columns to match MeetingSummaryFullRow
        .eq("id", id)
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Use single() for one expected row

      const { data, error } = await query;

      if (error && error.code === "PGRST116") {
        // Supabase specific error code for "no rows found"
        console.warn(`Summary not found for ID ${id} or not owned by DEFAULT user ${DEFAULT_USER_ID}.`);
        return null; // Return null for 404 case
      } else if (error) {
        console.error(
          `Database error fetching summary details for ID ${id} and DEFAULT user ${DEFAULT_USER_ID}:`,
          error
        );
        // FIX: Use type guard for error code
        if ((error as unknown as PostgrestError).code === "42501") {
          console.error("Potential RLS conflict: Query for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows access for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to fetch summary details from database.");
      }

      // Data will be of type MeetingSummaryFullRow | null
      return data; // Return the raw data
    } catch (error: unknown) {
      // FIX: Changed type to unknown
      console.error(`Error in SummaryService.getDefaultUserDetails for ID ${id}:`, error);
      // Pass status code if available, otherwise default to 500
      // FIX: Use type guard for status and message
      const message = error instanceof Error ? error.message : String(error);
      const status =
        error && typeof error === "object" && "status" in error && typeof error.status === "number"
          ? error.status
          : 500;
      const throwError = new Error(message);
      (throwError as ApiErrorWithStatus).status = status;
      throw throwError; // Re-throw to be caught by API handler
    }
  }

  // Method to create a new summary for the DEFAULT_USER_ID
  async createDefaultUserSummary(data: CreateSummaryRequestDTO): Promise<MeetingSummaryFullRow> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for creation (MVP ONLY).`);
    // Prepare data for insertion, explicitly setting user_id to DEFAULT_USER_ID
    const dataToInsert: MeetingSummaryInsertData = {
      user_id: DEFAULT_USER_ID, // Assign to DEFAULT user
      file_name: data.file_name,
      transcription: data.transcription,
      summary: data.summary,
      llm_generated: data.llm_generated,
      notes: data.notes, // notes can be string or null from validation
      title:
        data.file_name && data.file_name.trim().length > 0
          ? data.file_name.trim()
          : data.transcription.trim().substring(0, 50) + (data.transcription.trim().length > 50 ? "..." : ""), // Generate title
    };

    console.log("Attempting to insert data into DB for DEFAULT user:", dataToInsert);
    try {
      // Execute the insert query
      // If RLS insert policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .insert([dataToInsert]) // Insert the prepared data
        .select() // Select the inserted row
        .single(); // Expect a single row

      if (result.error) {
        console.error("Database insertion failed for DEFAULT user:", result.error);
        // FIX: Use type guard for error code
        if ((result.error as unknown as PostgrestError).code === "42501") {
          console.error("Potential RLS conflict: Insert for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows insert for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to save summary to database.");
      }

      if (!result.data) {
        console.error("SummaryService.createDefaultUserSummary: Insert returned no error but no data.");
        throw new Error("Database insertion failed unexpectedly.");
      }

      console.log("Database insertion successful for DEFAULT user. New summary ID:", result.data.id);
      return result.data;
    } catch (error: unknown) {
      // FIX: Changed type to unknown
      console.error("Error in SummaryService.createDefaultUserSummary:", error);
      // Pass status code if available, otherwise default to 500
      // FIX: Use type guard for status and message
      const message = error instanceof Error ? error.message : String(error);
      const status =
        error && typeof error === "object" && "status" in error && typeof error.status === "number"
          ? error.status
          : 500;
      const throwError = new Error(message);
      (throwError as ApiErrorWithStatus).status = status;
      throw throwError;
    }
  }

  // Method to update an existing summary for the DEFAULT_USER_ID
  // FIX: Correct return type to MeetingSummaryFullRow as returned by DB query
  async updateDefaultUserSummary(id: string, data: UpdateSummaryRequestDTO): Promise<MeetingSummaryFullRow | null> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for update (MVP ONLY).`);
    console.log(`Attempting to update summary ${id} for DEFAULT user with data:`, data);
    try {
      // Execute the update query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS update policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<MeetingSummaryFullRow> = await this.supabase
        .from("meeting_summaries")
        .update(data) // Update with the provided data
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .select() // Select the updated row
        .single(); // Expect a single row

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows updated"
        console.warn(`Update attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        // Return null or throw specific error for handler to return 404
        // FIX: Use a proper error type with status
        const notFoundError: ApiErrorWithStatus = new Error(`Summary with ID ${id} not found or access denied.`);
        notFoundError.status = 404; // Tag error for handler
        throw notFoundError; // Throw the error for the handler to catch and return 404
      } else if (result.error) {
        console.error(`Database update failed for ID ${id} and DEFAULT user:`, result.error);
        // FIX: Use type guard for error code
        if ((result.error as unknown as PostgrestError).code === "42501") {
          console.error("Potential RLS conflict: Update for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows update for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to update summary in database.");
      }

      // Data will be of type MeetingSummaryFullRow | null. If no error, data should exist due to single().
      if (!result.data) {
        console.error(`SummaryService.updateDefaultUserSummary: Update returned no error but no data for ID ${id}.`);
        throw new Error("Database update failed unexpectedly.");
      }

      console.log(`Database update successful for ID ${id} and DEFAULT user.`);
      return result.data; // Return the updated data
    } catch (error: unknown) {
      // FIX: Changed type to unknown
      console.error(`Error in SummaryService.updateDefaultUserSummary for ID ${id}:`, error);
      // Pass status code if available, otherwise default to 500
      // FIX: Use type guard for status and message
      const message = error instanceof Error ? error.message : String(error);
      const status =
        error && typeof error === "object" && "status" in error && typeof error.status === "number"
          ? error.status
          : 500;
      const throwError = new Error(message);
      (throwError as ApiErrorWithStatus).status = status; // Preserve status if available
      throw throwError; // Re-throw to be caught by API handler
    }
  }

  // Method to delete an existing summary for the DEFAULT_USER_ID
  async deleteDefaultUserSummary(id: string): Promise<void> {
    console.warn(`SummaryService: Using hardcoded DEFAULT_USER_ID ${DEFAULT_USER_ID} for delete (MVP ONLY).`);
    console.log(`Attempting to delete summary ${id} for DEFAULT user ${DEFAULT_USER_ID}`);
    try {
      // Execute the delete query, explicitly filtering by ID and DEFAULT_USER_ID
      // If RLS delete policy checks auth.uid() = user_id, this will fail unless RLS is disabled or adjusted.
      const result: PostgrestSingleResponse<null> = await this.supabase
        .from("meeting_summaries")
        .delete() // Perform deletion
        .eq("id", id) // Target the specific row by ID
        .eq("user_id", DEFAULT_USER_ID) // Explicitly filter by DEFAULT_USER_ID
        .single(); // Expect a single row deleted or none (returns null on success)

      if (result.error && result.error.code === "PGRST116") {
        // Supabase "no rows found" for delete
        console.warn(`Delete attempted on summary ${id} for DEFAULT user but row not found or RLS denied.`);
        // FIX: Use a proper error type with status
        const notFoundError: ApiErrorWithStatus = new Error(`Summary with ID ${id} not found or access denied.`);
        notFoundError.status = 404; // Tag error for handler
        throw notFoundError; // Throw the error for the handler to catch and return 404
      } else if (result.error) {
        console.error(`Database delete failed for ID ${id} and DEFAULT user:`, result.error);
        // FIX: Use type guard for error code
        if ((result.error as unknown as PostgrestError).code === "42501") {
          console.error("Potential RLS conflict: Delete for DEFAULT_USER_ID failed RLS.");
          throw new Error(
            "Database permission error. Ensure RLS allows delete for DEFAULT_USER_ID or is temporarily adjusted."
          );
        }
        throw new Error("Failed to delete summary from database.");
      }

      // Success! result.data will be null for delete single().
      console.log(`Database delete successful for ID ${id} and DEFAULT user.`);
      return; // Return void on success
    } catch (error: unknown) {
      // FIX: Changed type to unknown
      console.error(`Error in SummaryService.deleteDefaultUserSummary for ID ${id}:`, error);
      // Pass status code if available, otherwise default to 500
      // FIX: Use type guard for status and message
      const message = error instanceof Error ? error.message : String(error);
      const status =
        error && typeof error === "object" && "status" in error && typeof error.status === "number"
          ? error.status
          : 500;
      const throwError = new Error(message);
      (throwError as ApiErrorWithStatus).status = status; // Preserve status if available
      throw throwError; // Re-throw to be caught by API handler
    }
  }
}

// --- Handler endpoint GET /api/summaries ---
// Implements the List Summaries endpoint.
// Authentication check is SKIPPED. Data filtered by DEFAULT_USER_ID.
export const GET: APIRoute = async ({ url, locals }) => {
  const supabase = locals.supabase as SupabaseClient;

  // --- Get Supabase client from context.locals ---
  if (!supabase) {
    console.error("GET /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "GET /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data filtered by DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used

  // --- Use Zod for parameter validation (GET) ---
  const queryParams = Object.fromEntries(url.searchParams.entries());
  const validationResult = listSummariesParamsSchema.safeParse(queryParams);

  if (!validationResult.success) {
    console.error("GET /api/summaries: Query parameter validation failed:", validationResult.error);
    return new Response(
      JSON.stringify({
        message: "Invalid query parameters",
        errors: validationResult.error.format(),
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  const validatedParams = validationResult.data;

  // --- Determine Date Range ---
  let fromDate: Date | undefined;
  let toDate: Date | undefined;

  if (validatedParams.from_dt === undefined && validatedParams.to_dt === undefined) {
    // Default to last 7 days
    const now = new Date();
    toDate = endOfDay(now); // End of today
    fromDate = startOfDay(new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)); // Start of 7 days ago
    console.log(`DEBUG: Using default 7-day filter: from ${fromDate.toISOString()} to ${toDate.toISOString()}`);
  } else {
    if (validatedParams.from_dt !== undefined) {
      // Parse the date string provided
      fromDate = parseISO(validatedParams.from_dt);
      if (isNaN(fromDate.getTime())) fromDate = undefined; // Handle potential parse failure after refine
    }
    if (validatedParams.to_dt !== undefined) {
      // Parse the date string provided
      toDate = parseISO(validatedParams.to_dt);
      if (isNaN(toDate.getTime())) toDate = undefined; // Handle potential parse failure after refine
    }
    console.log(
      `DEBUG: Using provided date filters: from ${fromDate?.toISOString() || "none"} to ${toDate?.toISOString() || "none"}`
    );
  }

  // Map API sort_by terms to DB column names for the Service layer
  const dbSortBy: ListSummariesServiceParams["sortParams"]["by"] =
    validatedParams.sort_by === "updated_at" ? "modified_at" : "created_at";
  const sortOrder: ListSummariesServiceParams["sortParams"]["order"] = validatedParams.sort_order;

  try {
    const summaryService = new SummaryService(supabase);

    const serviceParams: ListSummariesServiceParams = {
      userId: DEFAULT_USER_ID, // Pass DEFAULT user ID to service
      dateRange: { from: fromDate, to: toDate },
      sortParams: { by: dbSortBy, order: sortOrder },
    };

    // Use the specific service method for the default user
    const summariesDto: MeetingSummaryListEntryDto[] = await summaryService.listDefaultUserSummaries(serviceParams);

    return new Response(JSON.stringify(summariesDto), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });
  } catch (error: unknown) {
    // FIX: Changed type to unknown
    // FIX: Use type guards for status and message
    const message = error instanceof Error ? error.message : String(error);
    const status =
      error && typeof error === "object" && "status" in error && typeof error.status === "number" ? error.status : 500;

    console.error("Caught error in GET /api/summaries handler (DEFAULT_USER):", error);

    if (status === 404 || status === 403) {
      return new Response(JSON.stringify({ message: message || "Access Denied/Not Found" }), {
        status: status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ message: "An internal server error occurred" }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint POST /api/summaries ---
// Implements the Create New Summary endpoint.
// Authentication check is SKIPPED. Data assigned to DEFAULT_USER_ID.
export const POST: APIRoute = async ({ request, locals }) => {
  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("POST /api/summaries: Supabase client not available in context.locals.");
    return new Response(
      JSON.stringify({
        error: "Internal server error: Database client not available.",
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    "POST /api/summaries: Authentication check SKIPPED as per specific MVP rule. Data assigned to DEFAULT_USER_ID."
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;

  try {
    requestBody = await request.json();
  } catch (error) {
    console.error("POST /api/summaries: Failed to parse request body as JSON:", error);
    return new Response(
      JSON.stringify({
        error: "Invalid JSON body",
      }),
      {
        status: 400,
        headers: { "Content-Type": "application/json" },
      }
    );
  }

  try {
    const validationResult = createSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error("POST /api/summaries: Input validation failed:", validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        {
          status: 400,
          headers: { "Content-Type": "application/json" },
        }
      );
    }

    const validatedData = validationResult.data;

    // --- Call Service to insert data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass validated data to service. Service will use DEFAULT_USER_ID internally.
    const newSummaryRecord: MeetingSummaryFullRow = await summaryService.createDefaultUserSummary(validatedData);

    console.log(
      "POST /api/summaries: Successfully created new summary record with ID:",
      newSummaryRecord.id,
      "for DEFAULT user."
    );

    // Map DB row to frontend DTO
    const responseData: CreateSummaryResponseDTO = {
      id: newSummaryRecord.id,
      user_id: newSummaryRecord.user_id,
      file_name: newSummaryRecord.file_name,
      created_at: newSummaryRecord.created_at,
      updated_at: newSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: newSummaryRecord.transcription,
      summary: newSummaryRecord.summary,
      llm_generated: newSummaryRecord.llm_generated,
      notes: newSummaryRecord.notes,
      title: newSummaryRecord.title,
    };

    return new Response(JSON.stringify(responseData), {
      status: 201, // 201 Created
      headers: {
        "Content-Type": "application/json",
        Location: `/api/summaries/${responseData.id}`, // HATEOAS principle
      },
    });
  } catch (error: unknown) {
    // FIX: Changed type to unknown
    // FIX: Use type guards for status and message
    const message = error instanceof Error ? error.message : String(error);
    const status =
      error && typeof error === "object" && "status" in error && typeof error.status === "number" ? error.status : 500;

    console.error("Caught error in POST /api/summaries handler (DEFAULT_USER):", error);

    if (status === 404 || status === 403) {
      return new Response(JSON.stringify({ message: message || "Access Denied/Not Found" }), {
        status: status, // Preserve status if service tagged it
        headers: { "Content-Type": "application/json" },
      });
    }
    return new Response(JSON.stringify({ error: "An internal server error occurred while saving the summary." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// --- Handler endpoint PUT /api/summaries/{id} ---
// Implements the Update Existing Summary endpoint.
// Authentication check is SKIPPED. Updates summary for DEFAULT_USER_ID.
export const PUT: APIRoute = async ({ params, request, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("PUT /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("PUT /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `PUT /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Updates summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  let requestBody: unknown;
  try {
    // --- Parse Request Body ---
    requestBody = await request.json();
  } catch (error) {
    console.error(`PUT /api/summaries/${summaryId}: Failed to parse request body as JSON:`, error);
    return new Response(JSON.stringify({ error: "Invalid JSON body" }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  try {
    // --- Input Validation (zod) ---
    const validationResult = updateSummaryRequestSchema.safeParse(requestBody);

    if (!validationResult.success) {
      console.error(`PUT /api/summaries/${summaryId}: Input validation failed:`, validationResult.error.errors);
      return new Response(
        JSON.stringify({
          error: "Validation failed",
          details: validationResult.error.errors,
        }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }

    const validatedData: UpdateSummaryRequestDTO = validationResult.data;

    // Ensure there's at least one field being updated
    if (Object.keys(validatedData).length === 0) {
      console.warn(`PUT /api/summaries/${summaryId}: Request body is empty, no fields to update.`);
      return new Response(JSON.stringify({ error: "Request body must contain fields to update." }), {
        status: 400,
        headers: { "Content-Type": "application/json" },
      });
    }

    // --- Call Service to update data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass updated data and summaryId to service. Service will use DEFAULT_USER_ID internally.
    // FIX: Expect MeetingSummaryFullRow or null return type from service
    const updatedSummaryRecord: MeetingSummaryFullRow | null = await summaryService.updateDefaultUserSummary(
      summaryId,
      validatedData
    );

    // FIX: Handle null return (404 Not Found)
    if (!updatedSummaryRecord) {
      console.warn(`PUT /api/summaries/${summaryId}: Service returned null, likely 404 Not Found.`);
      return new Response(JSON.stringify({ message: `Summary with ID ${summaryId} not found or access denied.` }), {
        status: 404,
        headers: { "Content-Type": "application/json" },
      });
    }

    console.log(`PUT /api/summaries/${summaryId}: Successfully updated summary record for DEFAULT user.`);

    // Map DB row to frontend DTO (MeetingSummaryDetailsDto for consistency with GET details)
    const responseData: MeetingSummaryDetailsDto = {
      id: updatedSummaryRecord.id,
      title: updatedSummaryRecord.title, // Include title as it's in the DB row
      file_name: updatedSummaryRecord.file_name,
      created_at: updatedSummaryRecord.created_at,
      updated_at: updatedSummaryRecord.modified_at, // Map DB modified_at to API updated_at
      transcription: updatedSummaryRecord.transcription,
      summary: updatedSummaryRecord.summary,
      llm_generated: updatedSummaryRecord.llm_generated,
      notes: updatedSummaryRecord.notes,
      // user_id is omitted from this DTO
    };

    return new Response(JSON.stringify(responseData), {
      status: 200, // 200 OK
      headers: { "Content-Type": "application/json" },
    });
  } catch (error: unknown) {
    // FIX: Changed type to unknown
    // FIX: Use type guards for status and message
    const message = error instanceof Error ? error.message : String(error);
    const status =
      error && typeof error === "object" && "status" in error && typeof error.status === "number" ? error.status : 500;

    console.error(`PUT /api/summaries/${summaryId}: Caught error after validation (DEFAULT_USER):`, error);
    // Check if it's a known error type from service
    if (status === 404) {
      // Service indicates Not Found/Not Owned - redundant if null check above works
      return new Response(
        JSON.stringify({
          message: message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    // FIX: Use type guard for error code
    if (
      (error &&
        typeof error === "object" &&
        "code" in error &&
        typeof error.code === "string" &&
        error.code === "42501") ||
      status === 403
    ) {
      // Service indicates Permission Denied
      return new Response(
        JSON.stringify({
          message:
            message || `Permission denied for summary ID ${summaryId}. Ensure RLS allows access for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while updating summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

// --- Handler endpoint DELETE /api/summaries/{id} ---
// Implements the Delete Summary endpoint.
// Authentication check is SKIPPED. Deletes summary for DEFAULT_USER_ID.
export const DELETE: APIRoute = async ({ params, locals }) => {
  const summaryId = params.id; // Get ID from URL parameters

  if (!summaryId) {
    console.warn("DELETE /api/summaries: Missing summary ID in URL.");
    return new Response(JSON.stringify({ error: "Summary ID is required in the URL." }), {
      status: 400,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Get Supabase client from context.locals ---
  const supabase: SupabaseClient = locals.supabase;

  if (!supabase) {
    console.error("DELETE /api/summaries: Supabase client not available in context.locals.");
    return new Response(JSON.stringify({ error: "Internal server error: Database client not available." }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }

  // --- Authentication Check (SKIPPED per MVP rule) ---
  console.log(
    `DELETE /api/summaries/${summaryId}: Authentication check SKIPPED as per specific MVP rule. Deletes summary for DEFAULT_USER_ID.`
  );
  // const { data: { user }, error: authError } = await supabase.auth.getUser(); // Not used
  // const userId = user.id; // Not used

  try {
    // --- Call Service to delete data for DEFAULT_USER_ID ---
    const summaryService = new SummaryService(supabase);
    // Pass summaryId to service. Service will use DEFAULT_USER_ID internally.
    await summaryService.deleteDefaultUserSummary(summaryId);

    console.log(`DELETE /api/summaries/${summaryId}: Successfully deleted summary record for DEFAULT user.`);

    return new Response(null, {
      // 204 No Content
      status: 204,
      // No body for 204 response
    });
  } catch (error: unknown) {
    // FIX: Changed type to unknown
    // FIX: Use type guards for status and message
    const message = error instanceof Error ? error.message : String(error);
    const status =
      error && typeof error === "object" && "status" in error && typeof error.status === "number" ? error.status : 500;

    console.error(`DELETE /api/summaries/${summaryId}: Caught error (DEFAULT_USER):`, error);

    if (status === 404) {
      return new Response(
        JSON.stringify({
          message: message || `Summary with ID ${summaryId} not found or access denied.`,
        }),
        {
          status: 404, // Return 404 Not Found
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    // FIX: Use type guard for error code
    if (
      (error &&
        typeof error === "object" &&
        "code" in error &&
        typeof error.code === "string" &&
        error.code === "42501") ||
      status === 403
    ) {
      // This might happen if RLS is still partially active
      return new Response(
        JSON.stringify({
          message:
            message || `Permission denied for summary ID ${summaryId}. Ensure RLS allows delete for DEFAULT_USER_ID.`,
        }),
        {
          status: 403,
          headers: { "Content-Type": "application/json" },
        }
      );
    }
    return new Response(
      JSON.stringify({ error: `An internal server error occurred while deleting summary ID ${summaryId}.` }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
};

export const prerender = false; // Needed for server routes



================================================
File: .husky/pre-commit
================================================
npx lint-staged


